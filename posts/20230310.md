---
title: "Caso pr√°ctico TDD"
date: Fri Mar 10 2023 21:24:00 GMT+0100 (hora est√°ndar de Europa central)
categories: ["Testing"]
---

Por poner el broche de oro a esta mini-serie de [art√≠culos sobre TDD](https://jafs.es/4060/testing-y-tdd/), vamos a ver un caso pr√°ctico con algo muy sencillo que todos conoc√©is: una pila. Por si queda alg√∫n despistado o despistada, una pila es una lista ordenada que permite almacenar y recuperar valores. El acceso a estos datos sigue el patr√≥n LIFO (del ingl√©s Last In, First Out, "el √∫ltimo en entrar es el primero en salir"). B√°sicamente, pod√©is pensar en la t√≠pica pila de platos, en la que el √∫ltimo plato que se pone encima, ser√° el primero que quitemos.

Para este caso, se usar√° JavaScript est√°ndar, haciendo uso de clases. De todas formas, si alguien tiene dudas sobre algo del lenguaje, pod√©is preguntarme en comentarios que responder√© con todo gusto.

## Primer test. Crear una instancia

Como estamos usando TDD, lo primero de todo ser√° definir el test a probar:

```typescript
describe("Stack", () => {
    test("should create a stack instance", () => {
        const stack = new Stack();
        expect(typeof stack).toBe("object");
     });
});
```

Si ahora ejecutamos el test, fallar√° como cabe espera:

```text
    ReferenceError: Stack is not defined

      1 | describe("Stack", () => {
      2 |       test("should create a stack instance", () => {
    > 3 |               const stack = new Stack();
        |                             ^
      4 |
      5 |               expect(typeof stack).toBe("object");
      6 |       });

      at Object.<anonymous> (stack.test.js:3:17)
```

Tenemos que escribir el c√≥digo m√≠nimo para que el test pase, as√≠ que, crearemos la clase:

```typescript
class Stack {
}
```

Y tendremos nuestro test pasado:

```text
 PASS  ./stack.test.js
  Stack
    ‚àö should create a stack instance (2 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        0.412 s, estimated 1 s
```

De aqu√≠ en adelante, ya no os pondr√© la salida de error y de passed por consola üòâ.

## Segundo test. Null al quitar un elemento de la pila vac√≠a

En este segundo test, vamos a verificar que si ejecutamos la operaci√≥n de quitar un elemento de la pila, y esta se encuentra vac√≠a, se devuelve el valor `null`.

```typescript
test("should return null when pop an empty stack", () => {
    const stack = new Stack();

    expect(stack.pop()).toBeNull();
});
```

Para hacer que el test pase, como tenemos que escribir el c√≥digo m√≠nimo, simplemente crearemos un m√©todo `pop()` que devolver√° `null` al ejecutarlo.

```typescript
class Stack {
    pop() {
        return null;
    }
}
```

## Tercer test. A√±adir un valor y eliminarlo

Ahora tenemos que probar que si a√±adimos un valor y lo eliminamos se obtiene ese mismo valor.

```typescript
test("should add value in the top of the stack and return this value when do a pop", () => {
    const stack = new Stack();

    stack.push("hello");

    expect(stack.pop()).toBe("hello");
});
```

Ahora el c√≥digo de la clase deber√≠a seguir haciendo lo m√≠nimo posible, pero vamos a ir un paso m√°s all√° (para no eternizar el ejemplo), y nos vamos a la fase de refactor, tras la que tendr√≠amos:

```typescript
class Stack {
    #lastValue = null;

    push(value) {
        this.#lastValue = value;
    }

    pop() {
        return this.#lastValue;
    }
}
```

## Cuarto test. Devolver null si no quedan elementos por quitar

```typescript
test("should return null after pop the last element", () => {
    const stack = new Stack();

    stack.push("value");
    stack.pop();

    expect(stack.pop()).toBeNull();
});

class Stack {
    #lastValue = null;

    push(value) {
        this.#lastValue = value;
    }

    pop() {
        const lastValue = this.#lastValue;
        this.#lastValue = null;
        return lastValue;
    }
}
```

Obs√©rvese que como a√∫n no hemos gestionado m√°s de un objeto en la cola, no estamos controlando que haya varios, es por ello que en este paso, asignaremos a `null` el valor, en cuanto llamemos a `pop()`. Y esto es por la regla de escribir el m√≠nimo c√≥digo posible.

## Quinto test. A√±adir y eliminar varios valores a la pila

```typescript
test("should add several values to the top and remove then until arrive to null", () => {
    const stack = new Stack();

    stack.push("value1");
    stack.push("value2");
    stack.push("value3");

    expect(stack.pop()).toBe("value3");
    expect(stack.pop()).toBe("value2");
    expect(stack.pop()).toBe("value1");
    expect(stack.pop()).toBeNull();
});
```

Es necesario hacer una aclaraci√≥n en esta parte, ya que si en el test, s√≥lo hubi√©semos a√±adido la √∫ltima comprobaci√≥n, omitiendo el resto de `expects`, no se hubiera podido verificar la pila nos devuelve cada valor eliminado, y seg√∫n el c√≥digo que ya ten√≠amos, el test pasar√≠a. Es por ello, que tenemos que dar mucha importancia a qu√© se quiere probar, porque un test que no est√© bien escrito, es como si no existiera. En estos casos tambi√©n es importante tener en cuenta, que si escribimos un test, y pasa sin tocar nada de c√≥digo, puede que no estemos probando lo que queremos.

Tras un refactor, en este caso tendremos lo siguiente:

```typescript
class StackElement {
    #value = null;
    #previousElement = null;

    constructor(value, previousElement) {
        this.#value = value;
        this.#previousElement = previousElement;
    }

    get Value() {
        return this.#value;
    }

    get PreviousElement() {
        return this.#previousElement;
    }
}

class Stack {
    #lastElement = null;

    push(value) {
        this.#lastElement = new StackElement(value, this.#lastElement);
    }

    pop() {
        if (!this.#lastElement) {
            return null;
        }

        const lastValue = this.#lastElement.Value;
        this.#lastElement = this.#lastElement.PreviousElement;
        return lastValue;
    }
}
```

Se ha incluido una nueva clase, y en este caso, no hemos a√±adido tests para dicha clase, ya que es un getter/setter. A√±adir tests en estos casos no tendr√≠a mucho sentido. Sin embargo, si hubi√©semos necesitado una clase m√°s compleja. Si que en este momento pausar√≠amos el test actual, para comenzar el desarrollo de la nueva clase con TDD. Una vez que hiciera todo lo que necesitamos, volver√≠amos a este test.

## Sexto test. Devolver longitud 0 cuando la pila est√° vac√≠a

```typescript
test("should return zero when stack is empty", () => {
    const stack = new Stack();

    expect(stack.Length).toBe(0);
});

class Stack {
    #lastElement = null;

    get Length() {
        return 0;
    }
    
    // El resto del c√≥digo no tiene cambios
}
```

## S√©ptimo test. Obtener el n√∫mero de elementos a√±adidos

```typescript
test("should return the number of elements in stack after add some values", () => {
    const stack = new Stack();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    expect(stack.Length).toBe(3);
});

class Stack {
    #lastElement = null;
    #length = 0;

    get Length() {
        return this.#length;
    }

    push(value) {
        this.#lastElement = new StackElement(value, this.#lastElement);
        ++this.#length;
    }

    // El resto del c√≥digo no tiene cambios
}
```

En este punto, como el test s√≥lo ha probado el a√±adir elementos, no tenemos que tocar el resto del c√≥digo, s√≥lo la parte de a√±adir. Aunque sea cansino, recordad que vamos a m√≠nimos en cada paso.

## √öltimo test. Obtener el n√∫mero de elementos tras a√±adir y eliminar varios elementos

```typescript
test("should return the number of elements in stack after add and remove some values", () => {
    const stack = new Stack();

    stack.push(1);
    stack.push(2);
    stack.pop();
    stack.push(3);
    stack.pop();

    expect(stack.Length).toBe(1);
});

class Stack {
    #lastElement = null;
    #length = 0;

    get Length() {
        return this.#length;
    }

    push(value) {
        this.#lastElement = new StackElement(value, this.#lastElement);
        ++this.#length;
    }

    pop() {
        if (!this.#lastElement) {
            return null;
        }

        const lastValue = this.#lastElement.Value;
        this.#lastElement = this.#lastElement.PreviousElement;
        --this.#length;
        return lastValue;
    }
}
```

## Conclusiones

Despu√©s de haber visto un caso de uso de TDD, creo que podemos concluir que esta t√©cnica es una herramienta valiosa para garantizar la calidad del software y mejorar la eficiencia del proceso de desarrollo. Al escribir las pruebas antes de escribir el c√≥digo, se obliga a pensar cuidadosamente en los requisitos del software y en c√≥mo se comportar√° en diferentes situaciones. El enfoque incremental de TDD tambi√©n significa que el software se desarrolla en peque√±os pasos, lo que facilita la detecci√≥n de errores y la resoluci√≥n de problemas antes de que se conviertan en problemas mayores.

¬øOs ha parecido interesante? ¬øten√©is dudas o sugerencias? Pues ya sab√©is, pod√©is dejar un mensajito en la caja de comentarios.
