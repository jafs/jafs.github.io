[
  {
    "slug": "20260221.html",
    "title": "DDD en un apocalipsis zombi. Parte 1",
    "description": "Imaginemos que estamos en pleno apocalipsis zombi. Tu grupo de supervivientes ha encontrado refugio en una vieja central eléctrica abandonada, pero la situación es crítica: hay que gestionar refugios, coordinar reabastecimientos, controlar infecciones y tomar decisiones que pueden significar vida o muerte. Decides crear un sistema para ayudar a gestionar todo esto.\r\n\r\nMeses después, el sistema funciona, pero hay un problema: cada vez que el líder del grupo (nuestro \"experto de negocio\") pide un cambio, tú y tu equipo os perdéis en traducciones. Él habla de \"supervivientes en cuarentena\", tú piensas en `user.status = 3`. Él menciona \"refugio en capacidad crítica\", tú ves `shelter.count >= shelter.max`. El código funciona, pero nadie entiende realmente qué hace sin abrir cada archivo y desentrañar la lógica. Y en un apocalipsis zombi, perder tiempo tratando de entender el código puede costarte la vida.\r\n\r\nEste es exactamente el tipo de problema que **Domain-Driven Design** vino a resolver. Y no, **DDD no es una arquitectura** ni un framework mágico que instalas con npm. Es una filosofía de desarrollo que propone algo radical y a la vez obvio: el código debe ser un espejo fiel de cómo funcionan las cosas en el mundo real del negocio (o en nuestro caso, del apocalipsis).\r\n\r\nLa idea la plasmó **Eric Evans** en 2003 en su libro Domain-Driven Design: Tackling Complexity in the Heart of Software, y aunque ya han pasado más de dos décadas, la premisa sigue siendo igual de potente: si el líder de supervivientes y el desarrollador miran el modelo del sistema, ambos deberían ver lo mismo. Mismos conceptos, mismas palabras, mismas reglas.\r\n\r\n¿Suena simple? Lo es. ¿Es fácil de implementar? Para nada. Pero cuando funciona, la diferencia es brutal: el código deja de ser una caja negra incomprensible y se convierte en una representación viva del dominio.\r\n\r\n## ¿Por qué DDD en un apocalipsis zombi?\r\n\r\nNuestro dominio de supervivencia tiene todo lo que necesita un buen modelo de DDD:\r\n\r\n- **Actores claros**: Supervivientes, Refugios, Suministros, Infectados\r\n- **Reglas firmes**: capacidad máxima de refugio, riesgo de contagio por proximidad, prioridad de evacuación\r\n- **Eventos que importan**: `SupervivienteInfectado`, `RefugioReabastecido`, `CuarentenaActivada`\r\n- **Consecuencias inmediatas**: un error en la lógica de cuarentena puede significar un brote masivo\r\n\r\nSi el código habla ese mismo idioma del apocalipsis, las decisiones serán más rápidas y menos peligrosas. Si en cambio tenemos un `User.status = 2` en lugar de un `Superviviente.infectar()`, alguien va a acabar mordido porque no entendió qué hacía ese \"2\".\r\n\r\nAhora que entendemos el problema, veamos cómo DDD nos da las herramientas para solucionarlo.\r\n\r\n!Ciudad post-apocalíptica\r\n\r\n## 1. Lenguaje ubicuo (Ubiquitous Language)\r\n\r\nEl primer pilar de DDD es establecer un **lenguaje común** entre todos los que participan en el proyecto. Y cuando digo común, me refiero a que las mismas palabras que usa el líder de supervivientes cuando describe cómo funciona la gestión del refugio, deben ser exactamente las mismas que aparecen en el código, en los tests, en la documentación y en las reuniones de equipo.\r\n\r\n¿Por qué es esto tan importante? Pensemos en un ejemplo concreto del apocalipsis:\r\n\r\nImagina que el líder del grupo dice: \"Cuando un superviviente muestra síntomas de infección, debe entrar inmediatamente en cuarentena hasta que un médico lo evalúe\". Si tú como desarrollador traduces esto internamente a `user.status = 2` y `user.quarantine = true`, ¿qué pasa cuando dentro de tres meses otro desarrollador tenga que modificar esa lógica? Va a tener que hacer arqueología de código para descifrar qué significa `status = 2`.\r\n\r\nEl lenguaje ubicuo elimina esa traducción mental. En nuestro refugio:\r\n\r\n- No decimos `Usuario`, decimos `Superviviente`. Porque en un apocalipsis zombi no hay \"usuarios\", hay personas luchando por sobrevivir.\r\n- No tenemos un método `setSalud(valor)`, tenemos `sufrirHerida()`, `curar()` o `aplicarVendaje()`. Son acciones que cualquiera entiende sin necesidad de abrir la documentación.\r\n- No hay un `status = 5`, hay un método `ponerEnCuarentena()` que hace exactamente lo que dice.\r\n\r\n### ¿Qué pasa si no usamos lenguaje ubicuo?\r\n\r\nLa consecuencia directa es la **pérdida de conocimiento del dominio**. El código se vuelve críptico, lleno de abreviaciones y abstracciones que solo el desarrollador original entiende. Cuando esa persona se va (o peor, se convierta en zombi), su conocimiento desaparecerá con ella.\r\n\r\nAdemás, cada conversación con el equipo de negocio se convierte en un ejercicio de traducción simultánea: ellos hablan de \"reabastecimiento de urgencia\", tú piensas en `supply.priority = 1`. Ellos dicen \"ruta segura\", tú ves `route.safe = true`. Es agotador y, lo peor de todo, propenso a errores de comunicación.\r\n\r\n### En la práctica\r\n\r\nSi en una especificación la líder del grupo menciona \"cuarentena\", en el código tendremos una clase o concepto llamado `Cuarentena`, no `IsolationZone` ni `StatusType2`. Si hablan de \"suministros críticos\", el código tendrá `SuministrosCriticos`, no `ImportantSupplies`.\r\n\r\nEste lenguaje compartido se convierte en el diccionario viviente del proyecto. Y debe estar documentado: un simple glosario donde se definan los términos clave del dominio puede salvar a tu equipo de horas de confusión.\r\n\r\n!La líder y el desarrollador hablan el mismo idioma\r\n\r\n*En la imagen superior podemos ver cómo el desarrollador tiene que dejar de pensar en tecnicismos para comenzar a hablar con la líder el mismo idioma.*\r\n\r\nLa diferencia entre el código de la izquierda y el de la derecha parece cosmética, pero en la práctica es enorme:\r\n\r\n```typescript\r\n// ❌ Sin lenguaje ubicuo\r\nuser.status = 2;\r\nuser.quarantine = true;\r\n\r\n// ✅ Con lenguaje ubicuo\r\nsuperviviente.ponerEnCuarentena();\r\n```\r\n\r\nEn el primer caso, ¿qué significa `status = 2`? ¿Hay un `status = 1`? ¿Y un `status = 3`? ¿Quién sabe qué implica cada número? En el segundo caso, la intención es cristalina. Y si en el futuro la cuarentena implica también bloquear el acceso al comedor o notificar al médico, ¿dónde pones esa lógica? En el método `ponerEnCuarentena()`, claro. El código se organiza solo cuando el lenguaje es el correcto.\r\n\r\n## 2. Bounded Contexts (Contextos delimitados)\r\n\r\nAquí viene uno de los conceptos más potentes de DDD y, a la vez, uno de los más malinterpretados. Un **Bounded Context** (Contexto Delimitado) es básicamente una frontera donde un modelo específico tiene sentido y es coherente.\r\n\r\n¿Por qué necesitamos esto? Porque en sistemas grandes, la misma palabra puede significar cosas completamente diferentes dependiendo de quién la use. Y esto no es un error, es natural.\r\n\r\nPongamos un ejemplo del apocalipsis: la palabra **\"Superviviente\"**.\r\n\r\n- Para el equipo de **Logística**, es alguien que consume recursos, tiene una ubicación y puede transportar suministros. Les interesa su capacidad de carga y su ruta.\r\n- Para el equipo de **Sanidad**, es un o una paciente potencial con un historial médico, un nivel de salud y un riesgo de infección. Les importa su temperatura corporal y si se ha expuesto a mordeduras.\r\n- Para el equipo de **Comando**, es una unidad con habilidades específicas que puede asignarse a refugios o misiones. Les interesa su experiencia en combate o sus conocimientos técnicos.\r\n\r\n¿Ves el problema? Si intentamos meter todo esto en una única clase `Superviviente`, acabaremos con un monstruo de 50 propiedades donde la mitad no tienen sentido en cada contexto. Y peor aún, cuando Logística quiera cambiar cómo se calcula la capacidad de carga, podría romper accidentalmente algo en Sanidad.\r\n\r\n### Dividir para reinar\r\n\r\nLa solución es dividir nuestro sistema en **contextos delimitados**, cada uno con su propio modelo:\r\n\r\n#### Contexto de Logística\r\n\r\n- Gestiona rutas de reabastecimiento entre refugios\r\n- Controla niveles de stock y consumo estimado\r\n- Calcula costes de transporte y riesgos de las rutas\r\n- Su `Superviviente` tiene: ubicación, capacidad de carga, estado de movilidad\r\n\r\n#### Contexto de Sanidad\r\n\r\n- Rastrea infecciones y posibles brotes\r\n- Gestiona vacunas y tratamientos médicos\r\n- Monitoriza el estado de salud general\r\n- Su `Superviviente` tiene: historial médico, síntomas, nivel de inmunidad\r\n\r\n#### Contexto de Comando\r\n\r\n- Asigna supervivientes a refugios\r\n- Decide evacuaciones y redistribuciones\r\n- Planifica misiones y estrategias\r\n- Su `Superviviente` tiene: habilidades, experiencia, refugio asignado\r\n\r\nDentro de cada contexto, el modelo y el lenguaje son coherentes y enfocados. No hay propiedades \"de más\" ni responsabilidades que no correspondan.\r\n\r\n!Los tres contextos delimitados de nuestro apocalipsis\r\n\r\n*En la imagen superior podemos ver los tres contextos delimitados de nuestro apocalipsis: logística, sanidad y comando.*\r\n\r\n### Comunicación entre contextos\r\n\r\nPero claro, estos contextos no viven aislados. Cuando Sanidad detecta un brote de infección, Comando necesita saberlo para activar una evacuación. Cuando Logística actualiza el stock de un refugio, Comando debe conocer si hay escasez crítica.\r\n\r\nLa comunicación entre contextos se hace mediante **contratos bien definidos**:\r\n\r\n- **APIs**: interfaces claras que exponen solo lo necesario\r\n- **Eventos de dominio**: \"Ha ocurrido X\" (por ejemplo, `SupervivienteInfectado`, `RefugioReabastecido`)\r\n- **Anti-corruption layers**: capas que traducen entre los modelos de diferentes contextos, protegiendo a cada uno de los cambios del otro\r\n\r\nPor ejemplo, cuando Sanidad emite el evento `BroteDetectado`, Comando no necesita conocer los detalles médicos internos. Solo recibe la información que le importa: qué refugio está afectado y cuántas personas están en riesgo.\r\n\r\n!Diagrama de comunicación entre Sanidad, Logística y Comando\r\n\r\n*Diagrama de comunicación entre Sanidad, Logística y Comando*\r\n\r\n## 3. Entidades y Objetos de Valor\r\n\r\nUna de las distinciones más importantes en DDD es entender la diferencia entre algo que \"es\" y algo que \"tiene\". Suena filosófico, pero tiene implicaciones muy prácticas en cómo diseñamos nuestro código.\r\n\r\n### Entidad (Entity): lo que importa es quién ES\r\n\r\nUna **Entidad** es algo que tiene una **identidad única y continuada en el tiempo**, independientemente de cómo cambien sus atributos.\r\n\r\nPensemos en una superviviente llamada Gema. Cuando Gema entra al refugio, tiene 100 puntos de salud y no está infectada. A lo largo de los días, Gema sufre una herida (ahora tiene 80 de salud), luego le curan (recupera a 95), después contrae una leve infección... su estado cambia constantemente. Pero en todo momento seguimos hablando de **Gema**, la misma superviviente. Su identidad no cambia aunque sus atributos sí lo hagan.\r\n\r\nEso es una Entidad. Lo que importa es **quién es**, no **cómo está**.\r\n\r\nCaracterísticas de las Entidades:\r\n\r\n- Tienen un identificador único (ID) que las distingue\r\n- Su identidad persiste a lo largo del tiempo\r\n- Pueden cambiar de estado sin dejar de ser ellas mismas\r\n- Dos entidades con los mismos atributos pero diferente ID son diferentes\r\n  - Gema con 100 de salud ≠ Pedro con 100 de salud (son personas distintas)\r\n\r\n```typescript\r\n// Entidad - Tiene identidad propia a través del ID\r\nclass Survivor {\r\n  constructor(\r\n    public readonly id: string, // El ID nunca cambia\r\n    public name: string,\r\n    public health: number\r\n  ) {}\r\n\r\n  sufrirHerida(puntos: number): void {\r\n    this.health = Math.max(0, this.health - puntos);\r\n  }\r\n\r\n  curar(puntos: number): void {\r\n    this.health = Math.min(100, this.health + puntos);\r\n  }\r\n\r\n  // La igualdad se determina por ID, no por atributos\r\n  equals(other: Survivor): boolean {\r\n    return this.id === other.id;\r\n  }\r\n}\r\n\r\nconst gema = new Survivor(\"survivor-1\", \"Gema\", 100);\r\ngema.sufrirHerida(20); // salud: 80 → sigue siendo Gema\r\ngema.curar(15);        // salud: 95 → sigue siendo Gema\r\n\r\nconst otraPersona = new Survivor(\"survivor-2\", \"Gema\", 95);\r\n\r\n// Aunque tengan el mismo nombre y la misma salud, NO son la misma persona\r\nconsole.log(gema.equals(otraPersona)); // false → diferente ID\r\n```\r\n\r\n### Objeto de Valor (Value Object): lo que importa es QUÉ es\r\n\r\nUn **Objeto de Valor** es algo que se define completamente por sus atributos. No tiene identidad propia, simplemente **representa un valor**.\r\n\r\nPensemos en las coordenadas de un punto de suministro: `{ lat: 40.4168, lon: -3.7038 }`. Estas coordenadas no \"son\" nadie ni nada. Son simplemente un valor que describe una ubicación. Si mañana tienes otra posición con exactamente la misma latitud y longitud, es **la misma coordenada**, no importa quién la use o cuándo se creó.\r\n\r\nCaracterísticas de los Objetos de Valor:\r\n\r\n- No tienen identidad propia\r\n- Se definen completamente por sus atributos\r\n- Son **inmutables**: si necesitas cambiarlos, creas uno nuevo\r\n- Dos objetos de valor con los mismos atributos son idénticos\r\n  - Coordenadas(40.4168, -3.7038) === Coordenadas(40.4168, -3.7038)\r\n\r\nOtros ejemplos en nuestro apocalipsis:\r\n\r\n- **`Suministro`**: un pack de vendas es idéntico a otro pack de vendas del mismo tipo\r\n- **`FechaEvacuacion`**: el 25 de diciembre de 2026 es el mismo día para todo el mundo\r\n- **`CantidadMunicion`**: 50 balas son 50 balas, no importa quién las cuente\r\n\r\n```typescript\r\n// Value Object - Inmutable\r\nclass Coordinates {\r\n  constructor(\r\n    public readonly lat: number,\r\n    public readonly lon: number\r\n  ) {}\r\n\r\n  // Comparación por valor, no por referencia\r\n  equals(other: Coordinates): boolean {\r\n    return this.lat === other.lat && this.lon === other.lon;\r\n  }\r\n}\r\n\r\n// Si necesitas cambiar las coordenadas, creas unas nuevas\r\nconst punto1 = new Coordinates(40.4168, -3.7038);\r\nconst punto2 = new Coordinates(41.3851, 2.1734); // Nuevo objeto\r\n\r\n// Comparación\r\nconsole.log(punto1.equals(punto2)); // false\r\nconsole.log(punto1.equals(new Coordinates(40.4168, -3.7038))); // true\r\n```\r\n\r\n### ¿Por qué importa esta distinción?\r\n\r\nSi confundes Entidades con Objetos de Valor, puedes cometer errores críticos:\r\n\r\n- **Tratar una Entidad como Value Object**: Si comparas dos supervivientes solo por su salud actual, podrías pensar que son la misma persona. Catastrófico.\r\n- **Tratar un Value Object como Entidad**: Si das un ID único a cada conjunto de coordenadas, acabarás con miles de objetos \"diferentes\" que en realidad representan la misma posición. Desperdicio de memoria y lógica innecesariamente compleja.\r\n\r\nLa regla simple: si la pregunta \"¿es el mismo?\" se responde con un ID, es una Entidad. Si se responde comparando valores, es un Value Object.\r\n\r\n!Entidad vs Value Object\r\n\r\n## 4. Agregados: el guardián de las reglas\r\n\r\nAhora entramos en uno de los conceptos más poderosos de DDD: los **Agregados**. Si has llegado hasta aquí pensando \"vale, ya tengo Entidades y Value Objects, ¿qué más necesito?\", prepárate porque los Agregados son lo que realmente mantiene la integridad de tu dominio.\r\n\r\n### ¿Qué es un Agregado?\r\n\r\nUn **Agregado** es un grupo de Entidades y Objetos de Valor que se tratan como una unidad a la hora de aplicar cambios. Dentro de este grupo hay una **raíz del agregado** (Aggregate Root), que es la única puerta de entrada permitida para modificar cualquier cosa dentro del agregado.\r\n\r\nPiénsalo como un refugio con una sola puerta de acceso vigilada. Nadie puede entrar ni salir sin pasar por esa puerta. Nadie puede modificar nada dentro sin que el guardián lo autorice. Ese guardián es la raíz del agregado.\r\n\r\n### ¿Por qué necesitamos esto?\r\n\r\nEn nuestro apocalipsis zombi, imagina que tenemos un refugio con estas reglas críticas:\r\n\r\n1. **Capacidad máxima**: Un refugio solo puede albergar un número limitado de supervivientes (si no, se agota el oxígeno, la comida, o simplemente no caben).\r\n2. **Cuarentena obligatoria**: Si hay infectados sin cuarentena, no se puede admitir más gente (riesgo de contagio masivo).\r\n3. **Gestión de suministros**: Los suministros del refugio deben ser controlados y contabilizados.\r\n\r\nSi permitimos que cualquier parte del código pueda modificar directamente la lista de supervivientes o los suministros, ¿quién garantiza que se cumplan estas reglas? La respuesta: nadie. Y en cuanto alguien añade un superviviente sin verificar la capacidad, o asigna suministros sin control, el caos es inevitable.\r\n\r\n### El Refugio como Agregado\r\n\r\nVamos a modelar `Shelter` (Refugio) como la **raíz del agregado**. Todo lo que ocurre con los supervivientes y suministros de ese refugio debe pasar por él:\r\n\r\n- ✅ La raíz (`Shelter`) expone métodos que verifican las invariantes antes de realizar cambios\r\n- ✅ Los supervivientes y suministros son **privados**, nadie puede tocarlos directamente desde fuera\r\n- ✅ Cada operación (`admit()`, `addSupply()`) protege las reglas del negocio\r\n- ❌ No hay setters públicos ni acceso directo al estado interno\r\n\r\n```typescript\r\n// Value Object - Representa un suministro genérico\r\n// Como es un Value Object, es inmutable (readonly)\r\nclass Supply {\r\n  constructor(\r\n    public readonly name: string,\r\n    public readonly amount: number\r\n  ) {}\r\n}\r\n\r\n// Entity - Representa un superviviente individual\r\n// Tiene identidad única (id) y puede cambiar de estado\r\nclass Survivor {\r\n  constructor(\r\n    public readonly id: string,\r\n    public name: string,\r\n    public health: number\r\n  ) {}\r\n}\r\n\r\n// Aggregate Root - La \"puerta de entrada\" a nuestro agregado\r\n// Es la ÚNICA forma de modificar supervivientes y suministros\r\nexport class Shelter {\r\n  // CRÍTICO: Estos arrays son PRIVADOS\r\n  // Nadie fuera de esta clase puede modificarlos directamente\r\n  private survivors: Survivor[] = [];\r\n  private supplies: Supply[] = [];\r\n  private currentCount = 0;\r\n\r\n  constructor(\r\n    public readonly id: string,\r\n    public readonly capacity: number  // Invariante: no podemos superarla\r\n  ) {}\r\n\r\n  // Método público para admitir supervivientes\r\n  // Aquí es donde protegemos nuestras reglas de negocio\r\n  public admit(s: Survivor): void {\r\n    // INVARIANTE 1: Verificar capacidad ANTES de admitir\r\n    // Esta es la regla que no puede romperse NUNCA\r\n    if (this.currentCount + 1 > this.capacity) {\r\n      throw new Error(\"Refugio lleno: no podemos admitir más supervivientes\");\r\n    }\r\n\r\n    // Solo si pasa la verificación, modificamos el estado\r\n    this.survivors.push(s);\r\n    this.currentCount++;\r\n\r\n    // Aquí podríamos emitir un evento: SupervivienteAdmitido\r\n  }\r\n\r\n  // Método para añadir suministros\r\n  // La lógica de negocio: si ya existe el suministro, sumamos cantidades\r\n  public addSupply(supply: Supply): void {\r\n    const existing = this.supplies.find(x => x.name === supply.name);\r\n\r\n    if (existing) {\r\n      // Los Value Objects son inmutables, así que creamos uno nuevo\r\n      const merged = new Supply(existing.name, existing.amount + supply.amount);\r\n      // Reemplazamos el antiguo por el nuevo\r\n      this.supplies = this.supplies.map(x => x === existing ? merged : x);\r\n    } else {\r\n      // Si no existe, lo añadimos directamente\r\n      this.supplies.push(supply);\r\n    }\r\n  }\r\n\r\n  // Métodos de consulta: devolvemos COPIAS, no las referencias originales\r\n  // Esto evita que alguien pueda modificar el estado desde fuera\r\n  public getSurvivors(): Survivor[] {\r\n    return [...this.survivors];\r\n  }\r\n\r\n  public getSupplies(): Supply[] {\r\n    return [...this.supplies];\r\n  }\r\n}\r\n```\r\n\r\nVeamos cómo funciona esto en la práctica:\r\n\r\n```typescript\r\n// Creamos un refugio con capacidad para 3 supervivientes\r\nconst electricShelter = new Shelter(\"Central Eléctrica Abandonada\", 3);\r\n\r\n// Admitimos a tres supervivientes sin problema\r\nelectricShelter.admit(new Survivor(\"1\", \"Pepe\", 10));\r\nelectricShelter.admit(new Survivor(\"2\", \"Juana\", 8));\r\nelectricShelter.admit(new Survivor(\"3\", \"Atolón\", 9));\r\n\r\nconsole.log(electricShelter.getSurvivors());\r\n// [\r\n//   Survivor: { \"id\": \"1\", \"name\": \"Pepe\", \"health\": 10 },\r\n//   Survivor: { \"id\": \"2\", \"name\": \"Juana\", \"health\": 8},\r\n//   Survivor: { \"id\": \"3\", \"name\": \"Atolón\", \"health\": 9 }\r\n// ]\r\n\r\n// Si intentamos admitir un cuarto superviviente...\r\n// electricShelter.admit(new Survivor(\"4\", \"Ariel\", 7));\r\n// ❌ Error: \"Refugio lleno: no podemos admitir más supervivientes\"\r\n// La invariante nos protege de romper la regla\r\n\r\n// Añadimos suministros\r\nelectricShelter.addSupply(new Supply(\"vendas\", 10));\r\nconsole.log(electricShelter.getSupplies());\r\n// [Supply: { \"name\": \"vendas\", \"amount\": 10 }]\r\n\r\n// Si añadimos más vendas, se suman automáticamente\r\nelectricShelter.addSupply(new Supply(\"vendas\", 7));\r\nconsole.log(electricShelter.getSupplies());\r\n// [Supply: { \"name\": \"vendas\", \"amount\": 17 }]\r\n// Observa que no hay dos entradas de \"vendas\", se han consolidado\r\n```\r\n\r\n### Puntos clave del agregado\r\n\r\nFijémonos en lo que hace que este código sea un buen agregado:\r\n\r\n1. **Estado privado**: Los arrays `survivors` y `supplies` son privados. Imposible modificarlos desde fuera sin pasar por los métodos de la raíz.\r\n\r\n2. **Invariantes protegidas**: Antes de modificar cualquier estado, verificamos que no rompemos las reglas (`capacity`). Si la regla se viola, lanzamos un error y el estado permanece intacto.\r\n\r\n3. **Métodos con sentido de negocio**: No tenemos `setSurvivors()` ni `addSurvivorToArray()`. Tenemos `admit()`, que tiene significado en el lenguaje del dominio.\r\n\r\n4. **Copias defensivas**: Los getters devuelven copias (`[...this.survivors]`), no las referencias originales. Esto evita que alguien haga `shelter.getSurvivors().push(...)` y modifique el estado sin pasar por las validaciones.\r\n\r\n5. **Consistencia transaccional**: Cuando modificas un agregado, todos los cambios se hacen juntos. O se admite completamente al superviviente (con todas las verificaciones), o no se admite. No hay estados intermedios inválidos.\r\n\r\nLa siguiente imagen resume la estructura del agregado: `Shelter` es la raíz, los supervivientes y suministros son internos, y el acceso siempre pasa por los métodos públicos de la raíz:\r\n\r\n!Diagrama de clases del agregado\r\n\r\n*Diagrama de clases del agregado: `Shelter` como raíz, `Survivor` como Entidad y `Supply` como Value Object.*\r\n\r\nY si lo llevamos al mundo físico del apocalipsis, la analogía es perfecta:\r\n\r\n!El Refugio como Agregado: el guardián controla quién entra\r\n\r\nEl combatiente en la puerta es la raíz del agregado. No importa quién intente entrar ni cómo de urgente sea la situación, si el refugio está lleno, nadie entra. Las invariantes se respetan siempre. Y si el camión llega con suministros, también pasa por él antes de que las cajas entren al refugio.\r\n\r\n## Continuará\r\n\r\nEn esta primera parte hemos sentado las bases de DDD: el **lenguaje ubicuo** que elimina traducciones mentales, los **Bounded Contexts** que dividen el sistema de forma coherente, las **Entidades y Value Objects** que modelan la identidad y el valor, y los **Agregados** que protegen las invariantes del dominio.\r\n\r\nEn la segunda parte veremos cómo conectar todo esto con el exterior: **Servicios de Dominio**, **Eventos**, **Repositorios** y la **capa de Aplicación**. Además, veremos los antipatterns más comunes y cuándo tiene sentido (y cuándo no) aplicar DDD.",
    "url": "/articles/posts/20260221.html",
    "date": "2026-02-22",
    "categories": [
      "Programación",
      "DDD"
    ],
    "content": "Imaginemos que estamos en pleno apocalipsis zombi. Tu grupo de supervivientes ha encontrado refugio en una vieja central eléctrica abandonada, pero la situación es crítica: hay que gestionar refugios, coordinar reabastecimientos, controlar infecciones y tomar decisiones que pueden significar vida o muerte. Decides crear un sistema para ayudar a gestionar todo esto. Meses después, el sistema funciona, pero hay un problema: cada vez que el líder del grupo (nuestro &quot;experto de negocio&quot;) pide un cambio, tú y tu equipo os perdéis en traducciones. Él habla de &quot;supervivientes en cuarentena&quot;, tú piensas en user.status = 3 . Él menciona &quot;refugio en capacidad crítica&quot;, tú ves shelter.count &gt;= shelter.max . El código funciona, pero nadie entiende realmente qué hace sin abrir cada archivo y desentrañar la lógica. Y en un apocalipsis zombi, perder tiempo tratando de entender el código puede costarte la vida. Este es exactamente el tipo de problema que Domain-Driven Design vino a resolver. Y no, DDD no es una arquitectura ni un framework mágico que instalas con npm. Es una filosofía de desarrollo que propone algo radical y a la vez obvio: el código debe ser un espejo fiel de cómo funcionan las cosas en el mundo real del negocio (o en nuestro caso, del apocalipsis). La idea la plasmó Eric Evans en 2003 en su libro Domain-Driven Design: Tackling Complexity in the Heart of Software , y aunque ya han pasado más de dos décadas, la premisa sigue siendo igual de potente: si el líder de supervivientes y el desarrollador miran el modelo del sistema, ambos deberían ver lo mismo. Mismos conceptos, mismas palabras, mismas reglas. ¿Suena simple? Lo es. ¿Es fácil de implementar? Para nada. Pero cuando funciona, la diferencia es brutal: el código deja de ser una caja negra incomprensible y se convierte en una representación viva del dominio. ¿Por qué DDD en un apocalipsis zombi? Nuestro dominio de supervivencia tiene todo lo que necesita un buen modelo de DDD: Actores claros : Supervivientes, Refugios, Suministros, Infectados Reglas firmes : capacidad máxima de refugio, riesgo de contagio por proximidad, prioridad de evacuación Eventos que importan : SupervivienteInfectado , RefugioReabastecido , CuarentenaActivada Consecuencias inmediatas : un error en la lógica de cuarentena puede significar un brote masivo Si el código habla ese mismo idioma del apocalipsis, las decisiones serán más rápidas y menos peligrosas. Si en cambio tenemos un User.status = 2 en lugar de un Superviviente.infectar() , alguien va a acabar mordido porque no entendió qué hacía ese &quot;2&quot;. Ahora que entendemos el problema, veamos cómo DDD nos da las herramientas para solucionarlo. 1. Lenguaje ubicuo (Ubiquitous Language) El primer pilar de DDD es establecer un lenguaje común entre todos los que participan en el proyecto. Y cuando digo común, me refiero a que las mismas palabras que usa el líder de supervivientes cuando describe cómo funciona la gestión del refugio, deben ser exactamente las mismas que aparecen en el código, en los tests, en la documentación y en las reuniones de equipo. ¿Por qué es esto tan importante? Pensemos en un ejemplo concreto del apocalipsis: Imagina que el líder del grupo dice: &quot;Cuando un superviviente muestra síntomas de infección, debe entrar inmediatamente en cuarentena hasta que un médico lo evalúe&quot;. Si tú como desarrollador traduces esto internamente a user.status = 2 y user.quarantine = true , ¿qué pasa cuando dentro de tres meses otro desarrollador tenga que modificar esa lógica? Va a tener que hacer arqueología de código para descifrar qué significa status = 2 . El lenguaje ubicuo elimina esa traducción mental. En nuestro refugio: No decimos Usuario , decimos Superviviente . Porque en un apocalipsis zombi no hay &quot;usuarios&quot;, hay personas luchando por sobrevivir. No tenemos un método setSalud(valor) , tenemos sufrirHerida() , curar() o aplicarVendaje() . Son acciones que cualquiera entiende sin necesidad de abrir la documentación. No hay un status = 5 , hay un método ponerEnCuarentena() que hace exactamente lo que dice. ¿Qué pasa si no usamos lenguaje ubicuo? La consecuencia directa es la pérdida de conocimiento del dominio . El código se vuelve críptico, lleno de abreviaciones y abstracciones que solo el desarrollador original entiende. Cuando esa persona se va (o peor, se convierta en zombi), su conocimiento desaparecerá con ella. Además, cada conversación con el equipo de negocio se convierte en un ejercicio de traducción simultánea: ellos hablan de &quot;reabastecimiento de urgencia&quot;, tú piensas en supply.priority = 1 . Ellos dicen &quot;ruta segura&quot;, tú ves route.safe = true . Es agotador y, lo peor de todo, propenso a errores de comunicación. En la práctica Si en una especificación la líder del grupo menciona &quot;cuarentena&quot;, en el código tendremos una clase o concepto llamado Cuarentena , no IsolationZone ni StatusType2 . Si hablan de &quot;suministros críticos&quot;, el código tendrá SuministrosCriticos , no ImportantSupplies . Este lenguaje compartido se convierte en el diccionario viviente del proyecto. Y debe estar documentado: un simple glosario donde se definan los términos clave del dominio puede salvar a tu equipo de horas de confusión. En la imagen superior podemos ver cómo el desarrollador tiene que dejar de pensar en tecnicismos para comenzar a hablar con la líder el mismo idioma. La diferencia entre el código de la izquierda y el de la derecha parece cosmética, pero en la práctica es enorme: En el primer caso, ¿qué significa status = 2 ? ¿Hay un status = 1 ? ¿Y un status = 3 ? ¿Quién sabe qué implica cada número? En el segundo caso, la intención es cristalina. Y si en el futuro la cuarentena implica también bloquear el acceso al comedor o notificar al médico, ¿dónde pones esa lógica? En el método ponerEnCuarentena() , claro. El código se organiza solo cuando el lenguaje es el correcto. 2. Bounded Contexts (Contextos delimitados) Aquí viene uno de los conceptos más potentes de DDD y, a la vez, uno de los más malinterpretados. Un Bounded Context (Contexto Delimitado) es básicamente una frontera donde un modelo específico tiene sentido y es coherente. ¿Por qué necesitamos esto? Porque en sistemas grandes, la misma palabra puede significar cosas completamente diferentes dependiendo de quién la use. Y esto no es un error, es natural. Pongamos un ejemplo del apocalipsis: la palabra &quot;Superviviente&quot; . Para el equipo de Logística , es alguien que consume recursos, tiene una ubicación y puede transportar suministros. Les interesa su capacidad de carga y su ruta. Para el equipo de Sanidad , es un o una paciente potencial con un historial médico, un nivel de salud y un riesgo de infección. Les importa su temperatura corporal y si se ha expuesto a mordeduras. Para el equipo de Comando , es una unidad con habilidades específicas que puede asignarse a refugios o misiones. Les interesa su experiencia en combate o sus conocimientos técnicos. ¿Ves el problema? Si intentamos meter todo esto en una única clase Superviviente , acabaremos con un monstruo de 50 propiedades donde la mitad no tienen sentido en cada contexto. Y peor aún, cuando Logística quiera cambiar cómo se calcula la capacidad de carga, podría romper accidentalmente algo en Sanidad. Dividir para reinar La solución es dividir nuestro sistema en contextos delimitados , cada uno con su propio modelo: Contexto de Logística Gestiona rutas de reabastecimiento entre refugios Controla niveles de stock y consumo estimado Calcula costes de transporte y riesgos de las rutas Su Superviviente tiene: ubicación, capacidad de carga, estado de movilidad Contexto de Sanidad Rastrea infecciones y posibles brotes Gestiona vacunas y tratamientos médicos Monitoriza el estado de salud general Su Superviviente tiene: historial médico, síntomas, nivel de inmunidad Contexto de Comando Asigna supervivientes a refugios Decide evacuaciones y redistribuciones Planifica misiones y estrategias Su Superviviente tiene: habilidades, experiencia, refugio asignado Dentro de cada contexto, el modelo y el lenguaje son coherentes y enfocados. No hay propiedades &quot;de más&quot; ni responsabilidades que no correspondan. En la imagen superior podemos ver los tres contextos delimitados de nuestro apocalipsis: logística, sanidad y comando. Comunicación entre contextos Pero claro, estos contextos no viven aislados. Cuando Sanidad detecta un brote de infección, Comando necesita saberlo para activar una evacuación. Cuando Logística actualiza el stock de un refugio, Comando debe conocer si hay escasez crítica. La comunicación entre contextos se hace mediante contratos bien definidos : APIs : interfaces claras que exponen solo lo necesario Eventos de dominio : &quot;Ha ocurrido X&quot; (por ejemplo, SupervivienteInfectado , RefugioReabastecido ) Anti-corruption layers : capas que traducen entre los modelos de diferentes contextos, protegiendo a cada uno de los cambios del otro Por ejemplo, cuando Sanidad emite el evento BroteDetectado , Comando no necesita conocer los detalles médicos internos. Solo recibe la información que le importa: qué refugio está afectado y cuántas personas están en riesgo. Diagrama de comunicación entre Sanidad, Logística y Comando 3. Entidades y Objetos de Valor Una de las distinciones más importantes en DDD es entender la diferencia entre algo que &quot;es&quot; y algo que &quot;tiene&quot;. Suena filosófico, pero tiene implicaciones muy prácticas en cómo diseñamos nuestro código. Entidad (Entity): lo que importa es quién ES Una Entidad es algo que tiene una identidad única y continuada en el tiempo , independientemente de cómo cambien sus atributos. Pensemos en una superviviente llamada Gema. Cuando Gema entra al refugio, tiene 100 puntos de salud y no está infectada. A lo largo de los días, Gema sufre una herida (ahora tiene 80 de salud), luego le curan (recupera a 95), después contrae una leve infección... su estado cambia constantemente. Pero en todo momento seguimos hablando de Gema , la misma superviviente. Su identidad no cambia aunque sus atributos sí lo hagan. Eso es una Entidad. Lo que importa es quién es , no cómo está . Características de las Entidades: Tienen un identificador único (ID) que las distingue Su identidad persiste a lo largo del tiempo Pueden cambiar de estado sin dejar de ser ellas mismas Dos entidades con los mismos atributos pero diferente ID son diferentes Gema con 100 de salud ≠ Pedro con 100 de salud (son personas distintas) Objeto de Valor (Value Object): lo que importa es QUÉ es Un Objeto de Valor es algo que se define completamente por sus atributos. No tiene identidad propia, simplemente representa un valor . Pensemos en las coordenadas de un punto de suministro: { lat: 40.4168, lon: -3.7038 } . Estas coordenadas no &quot;son&quot; nadie ni nada. Son simplemente un valor que describe una ubicación. Si mañana tienes otra posición con exactamente la misma latitud y longitud, es la misma coordenada , no importa quién la use o cuándo se creó. Características de los Objetos de Valor: No tienen identidad propia Se definen completamente por sus atributos Son inmutables : si necesitas cambiarlos, creas uno nuevo Dos objetos de valor con los mismos atributos son idénticos Coordenadas(40.4168, -3.7038) === Coordenadas(40.4168, -3.7038) Otros ejemplos en nuestro apocalipsis: Suministro : un pack de vendas es idéntico a otro pack de vendas del mismo tipo FechaEvacuacion : el 25 de diciembre de 2026 es el mismo día para todo el mundo CantidadMunicion : 50 balas son 50 balas, no importa quién las cuente ¿Por qué importa esta distinción? Si confundes Entidades con Objetos de Valor, puedes cometer errores críticos: Tratar una Entidad como Value Object : Si comparas dos supervivientes solo por su salud actual, podrías pensar que son la misma persona. Catastrófico. Tratar un Value Object como Entidad : Si das un ID único a cada conjunto de coordenadas, acabarás con miles de objetos &quot;diferentes&quot; que en realidad representan la misma posición. Desperdicio de memoria y lógica innecesariamente compleja. La regla simple: si la pregunta &quot;¿es el mismo?&quot; se responde con un ID, es una Entidad. Si se responde comparando valores, es un Value Object. 4. Agregados: el guardián de las reglas Ahora entramos en uno de los conceptos más poderosos de DDD: los Agregados . Si has llegado hasta aquí pensando &quot;vale, ya tengo Entidades y Value Objects, ¿qué más necesito?&quot;, prepárate porque los Agregados son lo que realmente mantiene la integridad de tu dominio. ¿Qué es un Agregado? Un Agregado es un grupo de Entidades y Objetos de Valor que se tratan como una unidad a la hora de aplicar cambios. Dentro de este grupo hay una raíz del agregado (Aggregate Root), que es la única puerta de entrada permitida para modificar cualquier cosa dentro del agregado. Piénsalo como un refugio con una sola puerta de acceso vigilada. Nadie puede entrar ni salir sin pasar por esa puerta. Nadie puede modificar nada dentro sin que el guardián lo autorice. Ese guardián es la raíz del agregado. ¿Por qué necesitamos esto? En nuestro apocalipsis zombi, imagina que tenemos un refugio con estas reglas críticas: Capacidad máxima : Un refugio solo puede albergar un número limitado de supervivientes (si no, se agota el oxígeno, la comida, o simplemente no caben). Cuarentena obligatoria : Si hay infectados sin cuarentena, no se puede admitir más gente (riesgo de contagio masivo). Gestión de suministros : Los suministros del refugio deben ser controlados y contabilizados. Si permitimos que cualquier parte del código pueda modificar directamente la lista de supervivientes o los suministros, ¿quién garantiza que se cumplan estas reglas? La respuesta: nadie. Y en cuanto alguien añade un superviviente sin verificar la capacidad, o asigna suministros sin control, el caos es inevitable. El Refugio como Agregado Vamos a modelar Shelter (Refugio) como la raíz del agregado . Todo lo que ocurre con los supervivientes y suministros de ese refugio debe pasar por él: ✅ La raíz ( Shelter ) expone métodos que verifican las invariantes antes de realizar cambios ✅ Los supervivientes y suministros son privados , nadie puede tocarlos directamente desde fuera ✅ Cada operación ( admit() , addSupply() ) protege las reglas del negocio ❌ No hay setters públicos ni acceso directo al estado interno Veamos cómo funciona esto en la práctica: Puntos clave del agregado Fijémonos en lo que hace que este código sea un buen agregado: Estado privado : Los arrays survivors y supplies son privados. Imposible modificarlos desde fuera sin pasar por los métodos de la raíz. Invariantes protegidas : Antes de modificar cualquier estado, verificamos que no rompemos las reglas ( capacity ). Si la regla se viola, lanzamos un error y el estado permanece intacto. Métodos con sentido de negocio : No tenemos setSurvivors() ni addSurvivorToArray() . Tenemos admit() , que tiene significado en el lenguaje del dominio. Copias defensivas : Los getters devuelven copias ( [...this.survivors] ), no las referencias originales. Esto evita que alguien haga shelter.getSurvivors().push(...) y modifique el estado sin pasar por las validaciones. Consistencia transaccional : Cuando modificas un agregado, todos los cambios se hacen juntos. O se admite completamente al superviviente (con todas las verificaciones), o no se admite. No hay estados intermedios inválidos. La siguiente imagen resume la estructura del agregado: Shelter es la raíz, los supervivientes y suministros son internos, y el acceso siempre pasa por los métodos públicos de la raíz: Diagrama de clases del agregado: Shelter como raíz, Survivor como Entidad y Supply como Value Object. Y si lo llevamos al mundo físico del apocalipsis, la analogía es perfecta: El combatiente en la puerta es la raíz del agregado. No importa quién intente entrar ni cómo de urgente sea la situación, si el refugio está lleno, nadie entra. Las invariantes se respetan siempre. Y si el camión llega con suministros, también pasa por él antes de que las cajas entren al refugio. Continuará En esta primera parte hemos sentado las bases de DDD: el lenguaje ubicuo que elimina traducciones mentales, los Bounded Contexts que dividen el sistema de forma coherente, las Entidades y Value Objects que modelan la identidad y el valor, y los Agregados que protegen las invariantes del dominio. En la segunda parte veremos cómo conectar todo esto con el exterior: Servicios de Dominio , Eventos , Repositorios y la capa de Aplicación . Además, veremos los antipatterns más comunes y cuándo tiene sentido (y cuándo no) aplicar DDD.",
    "imageMini": "/images/ddd-mini.webp"
  },
  {
    "slug": "20250720.html",
    "title": "Introducción a las redes neuronales",
    "description": "En el artículo anterior pudimos revisar en qué consisten las neuronas artificiales, y además vimos cómo poder implementar una neurona en JavaScript. Si aún no lo has leído, te recomiendo que empieces por ahí para entender la base de lo que vamos a ver ahora.",
    "url": "/articles/posts/20250720.html",
    "date": "2025-07-20",
    "categories": [
      "Programación"
    ],
    "content": "En el artículo anterior pudimos revisar en qué consisten las neuronas artificiales, y además vimos cómo poder implementar una neurona en JavaScript. Si aún no lo has leído, te recomiendo que empieces por ahí para entender la base de lo que vamos a ver ahora. Si aún así quieres empezar a leer este artículo, a modo de resumen, en el anterior hablábamos de neuronas como pequeñas funciones matemáticas que ajustaban pesos y sesgos para intentar dar una salida lo más precisa posible a partir de unas entradas. Hasta ahí todo sencillo. Pero, si intentamos resolver un problema tan simple como la operación XOR , nos encontraremos con una sorpresa. Lo primero de todo, recordemos su tabla de la verdad: El problema de XOR es que no es linealmente separable . Una neurona, como la que programamos en el artículo anterior, sólo puede establecer un límite mediante una recta (o un plano si hablamos de más dimensiones) para separar las salidas, o dicho de otra forma, sólo puede crear separaciones lineales entre las entradas y las salidas. En cambio, las capas ocultas permiten que la red combine múltiples límites simples para formar decisiones más complejas y precisas. ¿Qué es una red neuronal? Una red neuronal artificial es un conjunto de neuronas conectadas entre sí que trabajan juntas para procesar información. Se inspiran en cómo funciona el cerebro humano, aunque de forma muy simplificada. Ya vimos, que cada neurona recibe entradas, las transforma aplicando una función matemática (lo que llamamos activación) y genera una salida. Pues bien, en una red neuronal, esta salida llega a otras neuronas conectadas. Al unir muchas neuronas, se consigue que la red pueda aprender patrones complejos que una sola neurona no es capaz de distinguir. Las redes al igual que las cebollas, como diría Shrek, se organizan en capas : Capa de entrada : Recibe los datos iniciales. Por ejemplo, si queremos reconocer imágenes, la capa de entrada recibe los píxeles. Capas ocultas : Son las encargadas de procesar la información internamente. Cada neurona en estas capas intenta encontrar relaciones, patrones o combinaciones que sean útiles para llegar a una salida correcta. Su nombre viene de que no vemos directamente sus resultados como usuarios. Capa de salida : Es la que tiene como entradas los resultados de las capas ocultas, y según estados resultados da la respuesta final. Las redes pueden tener tantas capas ocultas como queramos, pero incluso con una capa podemos resolver problemas como el XOR, como veremos a continuación. Ya que esta aproximación nos permite comenzar a usar la IA como realmente la conocemos, dejando atrás los problemas muy sencillos que podía resolver una única neurona, para pasar a resolver problemas más complejos como: Reconocimiento de imágenes Traducción automática Diagnóstico médico Coches autónomos Y un largo etcétera de posibilidades. Construyendo nuestra primera red neuronal Para resolver la operación XOR, nuestra red neuronal va a ser muy sencilla: La capa oculta tendrá dos neuronas. Y tendremos una neurona final de salida. Esto es suficiente para resolver XOR. Cada neurona de la capa oculta aprenderá a distinguir una de las condiciones necesarias para que XOR funcione. La neurona de salida simplemente combinará esa información. Para entender cómo &quot;mapeamos&quot; de las neuronas ocultas a la de salida, piensa que cada neurona oculta detecta un patrón concreto (por ejemplo, que A sea 1 y B sea 0). La neurona de salida aprenderá a usar esas &quot;pistas&quot; que proporcionan las neuronas de la capa oculta para decidir su salida. Código y explicación paso a paso Clase Neuron En el artículo anterior ya vimos la clase Neuron. Aquí os pongo que métodos públicos tiene a modo de recordatorio: Definiendo la red neuronal El constructor simplemente inicializa la capa oculta y genera la neurona de salida. Aunque sólo es necesario dos neurona para resolver la operación XOR, ya hemos dejado el código genérico para recibir cualquier número de neuronas. El método que activa la red neuronal, difiere del de una neurona. En este caso activaremos todas las neuronas de la capa oculta, y una vez obtenidos sus resultados, será lo que pasemos a la neurona de salida para que nos proporcione el resultado final: El método de entrenamiento público, será exactamente el mismo que el de una neurona ya que simplemente iterará el conjunto de datos el número de pasos (épocas) necesarias. En cada época, comenzaremos con el entrenamiento, algo que a nivel de código tampoco es demasiado complejo en su método principal: Y aquí comienza lo complicado, ya que como habréis visto en los comentarios del código anterior, es necesario propagar la desviación de error, no sólo de una neurona, sino a todas las de la red: Entrenando la red El entrenamiento es muy parecido al que realizamos con una sóla neurona, así que hemos aprovechado para hacer que la API pública de la red neuronal sea similar a la de una neurona. Bien, el código que hemos visto nos permite generar una red neuronal de forma muy sencilla. Hay formas de desarrollarla mucho más avanzadas y correctas como sería usar un gradiente descendente , pero como siempre digo, eso será tema para otros artículos. Resumiendo... Una neurona aislada es muy limitada, por lo que no sirve para operaciones complejas. Cuando unimos varias neuronas y les permitimos aprender juntas generamos una red neuronal . Incluso sin grandes frameworks, podemos construir pequeños ejemplos en JavaScript (o cualquier otro lenguage que se te ocurra) para entender las bases. Hemos pasado de una neurona que &quot;resolvía&quot; operaciones muy sencillas, a una pequeña red que es capaz de resolver problemas imposibles para una sola. Espero que os haya servido para entender un poco más las bases de este apasionante mundillo. El código del proyecto ya está actualizado en GitHub , con la red neuronal. Podéis descargarlo, mejorarlo, experimentar y todo lo que se os ocurra. Muchas gracias si habéis llegado hasta aquí. Nos vemos en el próximo artículo.",
    "imageMini": "/images/redes-neuronales-mini.webp"
  },
  {
    "slug": "20250622.html",
    "title": "Introducción a las neuronas artificiales",
    "description": "Para bien o para mal, la Inteligencia Artificial hoy está en todas partes. Muchas personas se centran en explicar los distintos modelos, pero en este artículo me gustaría que llegáramos hasta el nivel más bajo de este mundillo, lo que es la mínima unidad de inteligencia artificial: **una neurona**.",
    "url": "/articles/posts/20250622.html",
    "date": "2025-06-22",
    "categories": [
      "Programación",
      "IA",
      "neurona artificial"
    ],
    "content": "Para bien o para mal, la Inteligencia Artificial hoy está en todas partes. Muchas personas se centran en explicar los distintos modelos, pero en este artículo me gustaría que llegáramos hasta el nivel más bajo de este mundillo, lo que es la mínima unidad de inteligencia artificial: una neurona . A continuación aprenderemos desde los conceptos básicos, hasta como hacer que una sola neurona resuelva un problema lógico como una sencilla operación booleana AND. Y como quiero innovar un poco, esta última parte más práctica no será con código Python (del cual hay miles de ejemplos), sino con JavaScript, ya que la idea es demostrar que con cualquier lenguaje podemos llevar a cabo la mayor parte de ideas en general. ¿Qué es una neurona artificial? Básicamente, una neurona artificial es un modelo matemático inspirado en nuestras neuronas biológicas. Su algoritmo más básico consiste en lo siguiente: Empieza su aprendizaje con ejemplos . Le damos una lista de combinaciones de entradas junto con la salida que esperamos. Por ejemplo, para enseñarle la operación lógica AND: Ajusta los “pesos” de cada entrada . Estos pesos determinan cuánto influye cada entrada en el resultado. Al principio son aleatorios, pero tras ver muchos ejemplos, los va ajustando para acercarse cada vez más a la salida correcta según los errores que vaya obteniendo. -- Cuando ya ha practicado lo suficiente , le damos una nueva entrada y la neurona predice el resultado. Y sí, hablamos de una predicción , no de una fórmula exacta. A veces acierta, otras se aproxima... como cualquier modelo de IA. A este último paso, es decir, al de proporcionar entradas para obtener una salida lo llamamos activar la neurona. El usar dicho verbo viene directamente de cómo funcionan las neuronas reales en nuestro cerebro: una neurona recibe señales a través de sus conexiones, las procesa, y si la señal es suficientemente fuerte, se activa y dispara una respuesta eléctrica. El siguiente esquema muestra el flujo básico de aprendizaje: ¿Pero cómo “aprende”? El aprendizaje de una neurona artificial no es más que un proceso de prueba y error. Le damos ejemplos, calcula una salida, ve cuánto se ha equivocado y ajusta sus parámetros internos para hacerlo mejor la próxima vez. Este proceso seguro que te suena, pues lo que hacemos cuando aprendemos una habilidad nueva, ya sea programar, aprender a tocar un instrumento musical, etc. Pero yendo a la parte más técnica. ¿Qué parámetros son los que ajusta la neurona? Pesos : cada entrada tiene un peso asociado. Es como decirle a la neurona “esta entrada es más importante que esta otra”. Al principio, esos pesos son aleatorios, pero la neurona los ajusta poco a poco durante el entrenamiento. Sesgo (o bias ): es un valor adicional que se suma al total antes de aplicar la función de activación. Sirve como una especie de empujón extra, permitiendo que la neurona genere salidas más flexibles. Piensa en él como el “estado de ánimo” base de la neurona: si está muy alto o muy bajo, afecta al resultado aunque las entradas sean las mismas. Función de activación : una vez sumamos todas las entradas multiplicadas por sus pesos y le añadimos el sesgo, ese valor pasa por dicha función, que lo que hace básicamente, es convertir ese número a algo que tenga sentido como “respuesta”. Le da no linealidad al sistema, permitiendo que aprenda comportamientos complejos. Entonces, en cada iteración de la fase de aprendizaje, la neurona: Predice un resultado a partir de las entradas y los pesos que tenga guardados. Compara ese resultado con la salida esperada, o lo que es lo mismo calcula el error . Usa el error de la salida para ajustar los pesos y el sesgo , guiándose por la derivada de la función de activación. Repite el proceso. ¿Cuántas veces hay que entrenarla? Una pregunta común es: ¿cuántas veces hay que entrenar una neurona artificial? Para eso usamos el número de épocas o iteraciones , es decir, cuántas veces la neurona recorre todos los ejemplos para ajustar sus pesos y su sesgo. Si usamos muy pocas iteraciones , la neurona apenas aprende. Los pesos se quedan mal ajustados y la predicción será incorrecta en muchos casos. Pero si usamos demasiadas , también puede ser un problema. ¿Por qué? Sobreajuste (overfitting) : Aunque en un problema tan simple como un AND o un OR esto no se nota mucho, en problemas reales con muchos datos, entrenar en exceso puede hacer que la neurona “memorice” los datos de entrenamiento y no sea capaz de generalizar cuando le damos datos nuevos. Pérdida de tiempo y recursos : Cada iteración consume tiempo y potencia de cálculo. Si después de cierto punto el modelo ya no mejora, seguir entrenando es simplemente ineficiente. Oscilación de pesos : Si no se ha afinado bien la tasa de aprendizaje , demasiadas iteraciones pueden provocar que los pesos “se pasen de largo” en cada ajuste, impidiendo que la neurona estabilice una solución. Por eso, buscar el equilibrio es la clave . ¿Siempre deberemos usar el mismo número de iteraciones? Pues como diría Pau Donés: &quot;depende&quot;. En ejemplos sencillos como las operaciones AND u OR, 1000 iteraciones funcionan bien. Pero en problemas más grandes, elegir el número de iteraciones se convierte en toda una ciencia. Caso práctico La clase Neuron Esta clase representa una neurona artificial, y tiene todo lo necesario para poder entrenarse y activarse posteriormente. Sus atributos son los siguientes: learningRate : tasa o ratio de aprendizaje. Permite ajustar la desviación de los pesos en cada iteración del entrenamiento. bias : almacena el sesgo calculado. Puedes ver más arriba información sobre el sesgo. weights : almacena los pesos. Igualmente, puedes ver en qué consisten más arriba. inputsNumber : es importante almacenar el número de entradas que permite la neurona. Esté será el atributo que lo guarde. activationFunction : función que actuará como una especie de &quot;filtro&quot; que transforma el resultado en crudo calculado por la neurona es un valor normalizado. Hay varios tipos de funciones de activación según el uso que se le quiera dar a la neurona. Algo que comentaremos en futuros artículos. derivateFunction : sería la función derivada de la de activación. Nos servirá para ajustar el sesgo. Es por ello, que siempre dependerá de la función de activación. Además de los métodos: activate : se encarga de activar la neurona, es decir, darnos un resultado a partir de una serie de entradas. training : inicia el entrenamiento de la neurona. Recibe un conjunto de datos (por cada dato tenemos una o varias entradas y una salida). Además, recibe el número de iteraciones que hay que realizar para entrenar cada dato. train : método privado que realiza el entrenamiento de un dato. adjust : como su nombre indica, este método, se encargará de ajustar tanto los pesos como el sesgo a partir del error entre la salida real y la esperada. calculateError : nos devuelve el error entre la salida esperada y la generada por la neurona. calculateAdjust : obtiene el valor ajuste que hay que realizar a partir del error. Entrenamiento Para cada paso del entrenamiento tendríamos lo siguiente: Este método hace cuatro cosas muy importantes: Activa la neurona con las entradas actuales. O lo que es lo mismo, obtiene la salida calculada por la neurona con los pesos que tenemos actualmente ( computedOutput ) Calcula el error comparando lo que salió con lo que esperábamos. Usa la derivada de la función de activación para calcular cuánto debe ajustarse . Finalmente, ajusta pesos y sesgo . Para este ajuste de pesos tenemos el método privado #adjust . NOTA En JavaScript los atributos y métodos privados usan como prefijo la almohadilla # . Este es el método crucial para que funcione el proceso de aprendizaje de la neurona. Realiza el ajuste de pesos según el valor que calculamos de desviación con la derivada. Lo que debería ir reduciendo los errores entre la salida esperada y la obtenida. Además, en esta parte incluimos el ratio de aprendizaje ( learningRate en el código), que será un ajuste para poder usarlo en la desviación. Ahora para entrenar a nuestra neurona para realizar operaciones AND. Usaríamos los datos siguientes: De forma que a partir de esos datos y de usar la función de activación sigmoide, podríamos comenzar el entrenamiento: En este caso, estamos diciendo que la neurona: Tiene dos entradas Usa como función de activación, la función sigmoide y su derivada. Tiene una tasa de aprendizaje de 0.1. O lo que es lo mismo, irá haciendo ajustes de pesos de 0.1 por cada iteracion. Finalmente, le damos los datos con los que entrenar y le indicamos que itere 1000 veces con dichos datos. Activación Como indicamos anteriormente, cuando activamos la neurona, hacemos referencia al momento en el que &quot;piensa&quot; y da una respuesta. No está aprendiendo, está actuando según lo que ya aprendió. En nuestro código JavaScript la activación consistiría en lo siguiente: Recibe los inputs , por ejemplo [1, 1]. El valor inicial parte del sesgo que calculamos durante el aprendizaje. Multiplica cada input por su peso correspondiente , ya que durante el entrenamiento a cada entrada le dimos &quot;una importancia&quot; diferente. Suma la multiplicación de todos los pesos con el sesgo. Pasa ese resultado por la función de activación , que como vimos terminará actuando como un filtro. En este caso, al usar como función de activación, la función sigmoide, transforma ese número crudo en un valor entre 0 y 1. Con lo que al método anterior, si le damos [1, 1] como entrada, y está bien entrenada, nos devolverá algo cercano a 1. Si le damos [0, 1] o [1, 0], nos devolverá algo cercano a 0. Y es que cabe destacar que la salida no es un uno o un cero exacto . En nuestro ejemplo, como la función de activación devuelve valores continuos, puede darnos algo como 0.97 (que interpretamos como &quot;casi 1&quot;) o 0.04 (que interpretamos como &quot;casi 0&quot;). En nuestro caso real, la salida será algo como: Finalmente El código que he generado durante el desarrollo de este artículo lo he publicado en GitHub . En intentado poner bastantes comentarios, principalmente en la clase Neuron, para que os pueda ser más sencillo seguirlo. Ya que explicarlo al completo en este artículo se haría demasiado extenso. Aún nos queda mucho por aprender, por lo que en futuros artículos: Veremos que aunque con nuestro código actual podemos obtener buenos resultados para las operaciones AND y OR. Cuando pasamos a una operación XOR debemos subir un nivel y crear nuestra primera red neuronal. Hablaremos un poco más de las distintas funciones de activación y en qué casos deberíamos usar cada una. Aprenderemos a persistir la información de las neuronas, para evitar entrenarlas cada vez. Para terminar, como ejercicio sencillo si descargáis el código: probad a entrenar una neurona para que funcione con las operaciones OR.",
    "imageMini": "/images/neuronas-artificiales-mini.webp"
  },
  {
    "slug": "20240301.html",
    "title": "Aritmética binaria",
    "description": "Hoy vamos a ver algo que se sale un poco de la tónica habitual de este blog. Pero, siempre viene bien volver a las bases de la informática. Así que espero que esta pequeña introducción al sistema binario y a su aritmética, pueda serte útil.",
    "url": "/articles/posts/20240301.html",
    "date": "2024-03-01",
    "categories": [
      "programación",
      "binario",
      "aritmética"
    ],
    "content": "Hoy vamos a ver algo que se sale un poco de la tónica habitual de este blog. Pero, siempre viene bien volver a las bases de la informática. Así que espero que esta pequeña introducción al sistema binario y a su aritmética, pueda serte útil. Sistemas de Numeración Un sistema de numeración lo podemos definir como un conjunto de reglas y convenios que nos permiten la representación de todos los números mediante varias cifras o símbolos. Los múltiples sistemas de numeración que existen podemos agruparlos principalmente en dos familias: Por un lado, están los que se rigen por reglas estrictas sin importar dónde esté la cifra o el símbolo. Estos son los sistemas basados en el Valor Absoluto . Un ejemplo de esto es el sistema de numeración romana, que utiliza las letras I , V , X , L , C , D y M . En este sistema, el valor de una letra siempre es el mismo, sin importar su posición dentro del número. Por ejemplo, el valor de C siempre será 100 independientemente de su posición: Por otro lado tenemos a los sistemas basados en valores relativos . En este caso el mismo símbolo puede representar valores diferentes dependiendo de dónde esté ubicado en el número. El sistema decimal es el más destacado y conocido entre estos sistemas de numeración. El sistema decimal fue ideado en la India en el siglo V a.C., posteriormente traído a Europa por los árabes en la Edad Media. Su base es el número diez, habiéndose elegido este número por ser diez los dedos de las manos y emplearse habitualmente éstos para contar. Este sistema consta de diez dígitos diferentes: 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 y 9 ; con los que debidamente agrupados puede representarse cualquier número. En el sistema decimal cada signo tiene un valor dependiendo del lugar que ocupa. Y este valor viene dado por su valor absoluto multiplicado por potencias de 10 sucesivas (10⁰, 10¹, 10², etc.). Así el número cuatro mil trescientos cincuenta y dos equivaldrá a: Sistemas de numeración con valores relativos La construcción de un sistema de numeración basado en valores relativos seguirá la definición siguiente: El valor decimal de un número es igual a la suma de los valores de los dígitos o símbolos correspondientes, multiplicados por la base elevada a la potencia definida por su posición. es decir, si: será: Por ejemplo, si partimos del número 561₈, de tres cifras ( T = 3 ) y con base ocho ( B = 8 ), tendríamos la siguiente conversión a decimal: Con lo que tenemos que el valor decimal del número 561 en base 8 es 369 ; lo que podemos expresar como 591₈ = 369₁₀ . Equivalencias entre sistemas de valores relativos En la tabla siguiente se pueden observar las equivalencias de distintos sistemas de numeración. Decimal (10) Quinario (5) Octal (8) Duodecimal (12) Hexadecimal (16) 0 0 0 0 0 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 4 4 4 4 4 5 10 5 5 5 6 11 6 6 6 7 12 7 7 7 8 13 10 8 8 9 14 11 9 9 10 20 12 A A 11 21 13 B B 12 22 14 10 C 13 23 15 11 D 14 24 16 12 E 15 30 17 13 F Sistema Binario (Base 2) El sistema binario, es la piedra angular del mundo de la informática. Es más, sólo nos tenemos que detener en el significado de bit , para comprobar como es una abreviatura de &quot; binary digit &quot; o dígito binario. Este sistema utiliza solamente dos símbolos diferentes: 0 y 1 . En el mundo informático esto es justo lo que representa un bit de información, podemos hablar de verdadero y falso , encendido y apagado , etc. Pero, ¿por qué es tan crucial el sistema binario en la programación? Básicamente por dos razones entre otras: Eficiencia : Las computadoras digitales utilizan el sistema binario debido a su eficiencia. Es más fácil construir máquinas que solo necesitan distinguir entre dos estados. Operaciones lógicas : Las operaciones fundamentales de la lógica booleana ( AND , OR , NOT , etc.) se pueden representar y manipular fácilmente en el sistema binario. Conversión de decimal a binario Para convertir enteros decimales a la notación binaria, tan sólo hay que dividir el número decimal por 2 hasta que el cociente sea cero. Los restos de cada división formarán el número binario equivalente; el primer resto será la cifra que se encuentre más a la derecha mientras que el último resto será la cifra que se encuentre más a la izquierda. Como ejemplo, vamos a convertir el número 13 a su valor binario: Si ahora le damos la vuelta a los restos que hemos obtenido, nos queda que: Cuando el cociente sea 1, también puedes usar dicho cociente en lugar de tener que hacer una nueva división. Esto se ve mejor si expresamos la división con otro formato. Si paramos cuando el cociente sea 1 , usando el ejemplo anterior tendríamos lo siguiente: Conversión de binario a decimal Al igual que con el resto de sistemas de numeración, cada símbolo tiene un valor en función del lugar que ocupa. Así, por ejemplo, el valor decimal del número 101011₂ es: Otro método muy utilizado es el denominado duplicidad y suma . La manera de proceder en este método es la siguiente: Se multiplica por 2 la cifra de orden superior, la que está más a la izquierda del número. Al producto se le suma el valor de la cifra de la derecha. La suma obtenida se multiplica por 2. Al producto obtenido se le suma la cifra a la derecha. Se repite la operación hasta que no nos queden cifras a la derecha. Veamos la conversión por este sistema del mismo número del ejemplo del caso anterior, es decir con el número 101011₂: Fracciones Conversión de fracciones decimales en binarias En general el proceso de conversión de un sistema a otro de la parte fraccionaria de un número es diferente al utilizado para la parte entera. Con frecuencia este proceso es el inverso para la fracción. Para convertir una fracción decimal en binaria se multiplica la fracción binaria por 2, correspondiendo la parte entera del producto al primer dígito binario. Se repite la operación con la parte decimal del producto anterior obteniendo un nuevo entero que será el siguiente dígito binario. Así sucesivamente hasta que la fracción quede reducida a cero, o se haya quedado una cantidad suficiente de dígitos binarios, en el caso de una fracción periódica. Ejemplo: convertir la fracción decimal 0,828125 en fracción binaria. Si tuviéramos un número con parte decimal y fraccionaria, podemos hacer las conversiones en dos partes: Conversión de fracciones binarias a decimales El método más cómodo de conversión, resulta del desarrollo del número binario en sus respectivas potencias de 2, con exponente negativo descendente de izquierda a derecha. Suma binaria En esencia, la suma binaria es muy semejante a la suma decimal; la tabla de sumar binaria, es mucho más reducida que la decimal, como se puede observar a continuación. Al sumar 1 + 1 en sistema binario, se excede el límite de la cuenta, ya que sólo disponemos de los símbolos 0 y 1, y en consecuencia, el resultado será 0 con acarrreo de 1 a la posición inmediata superior. Veamos a continuación dos ejemplos de suma binaria. El primero no necesita comentarios, basta con seguir la tabla de sumar binaria. El segundo tiene varios acarreos de 1. Así que para que se pueda entender un poco mejor, se ha indicado con super-índices encima de los valores afectados: Resta binaria Las reglas de la resta binaria aparecen esquematizadas a continuación: Cuando en una columna la cifra del minuendo es menor que la del sustraendo, es preciso pedir una unidad a la columna inmediata superior, con lo que se aumenta en dos unidades el valor del minuendo en la que estamos trabajando (o lo que es lo mismo sumamos 10₂ ). Al restar en la columna superior hay que tener en cuenta la unidad del minuendo que se ha pasado a la columna inferior y descontarla de aquella. Pero mejor, veamos un ejemplo: Multiplicación binaria Las reglas de multiplicar en binario serían las siguientes: La multiplicación binaria sigue el mismo sistema que la decimal. Sólo debemos recordar que la suma final de los productor parciales obtenidos al multiplicar el multiplicando por cada una de las cifras del multiplicador, debe hacerse en binario, como es obvio. Como siempre, será mejor ver un ejemplo: Como se puede observar, sólo hay dos casos, o repetir el multiplicando cuando el valor a usar del multiplicador es 1 o tener el valor 0, en caso de que ese sea el valor a usar del multiplicador. División binaria La división binaria debe hacerse de idéntica manera a como se hace la división decimal con la salvedad de que la diferencia entre la parte correspondiente del dividendo y el producto obtenido al multiplicar el divisor por la cifra correspondiente del cociente, debe hacerse e binario. Veamos un ejemplo: Como se ha visto, en el caso anterior 100010₂ : 110₂ = 101₂ con resto 100₂. Podemos verificar si la operación ha sido correcta multiplicando divisor por cociente y sumando el resto:",
    "imageMini": "/images/aritmetica-binaria-mini.webp"
  },
  {
    "slug": "20230625.html",
    "title": "Hablemos de acoplamiento y cohesión. Parte 2. Cohesión",
    "description": "En el artículo anterior estuvimos viendo un poco por encima en qué consisten los conceptos de acoplamiento y cohesión. En esta segunda parte nos centraremos es ver los distintos tipos de cohesión que hay. Eso sí, dependiendo del autor o autora, puede variar la lista, así que he intentado unificar lo máximo posible para poner los tipos que hay en común.",
    "url": "/articles/posts/20230625.html",
    "date": "2023-06-25",
    "categories": [
      "Diseño y arquitectura"
    ],
    "content": "En el artículo anterior estuvimos viendo un poco por encima en qué consisten los conceptos de acoplamiento y cohesión. En esta segunda parte nos centraremos es ver los distintos tipos de cohesión que hay. Eso sí, dependiendo del autor o autora, puede variar la lista, así que he intentado unificar lo máximo posible para poner los tipos que hay en común. Tipos de cohesión Nombre Descripción &#x2b06; Alta Cohesión funcional Los elementos de un módulo realizan una tarea única y específica. Cohesión secuencial Los elementos de un módulo están conectados en una secuencia lógica. Cohesión comunicativa Los elementos de un módulo están relacionados porque trabajan juntos para producir un resultado común. Cohesión temporal Los elementos de un módulo están relacionados en el tiempo. Cohesión lógica Los elementos de un módulo están relacionados porque todos contribuyen a un resultado lógico común. &#x2b07; Baja Cohesión de coincidencia Los elementos de un módulo están relacionados porque todos están asociados con un evento o entidad común. Cohesión de coincidencia Los elementos de un módulo están relacionados porque todos están asociados con un evento o elemento común. Para explicar esto de una manera más práctica, consideremos un ejemplo. Imagina que tienes un módulo que se encarga de la validación de formularios. Este módulo contiene varias funciones, como validateEmail() , validatePassword() , validateName() , etc. Estas funciones comparten algunas constantes o variables globales, como las expresiones regulares para verificar el formato de entrada. En este caso, podríamos decir que el módulo tiene una cohesión de coincidencia, ya que las funciones no están conectadas entre sí, pero comparten algunos recursos. En lugar de esto, podríamos dividir el módulo en submódulos más pequeños y específicos, como uno para validar correos electrónicos, otro para contraseñas, etc. De esta manera, cada módulo tendría una mayor cohesión, lo que facilitaría su mantenimiento y escalabilidad. Es importante tener en cuenta que la cohesión de coincidencia no siempre es mala. De hecho, en algunos casos, puede ser difícil evitarla por completo. Sin embargo, es importante asegurarse de que la cohesión de coincidencia no se convierta en un problema en el futuro. Cohesión lógica La cohesión lógica implica que un conjunto de componentes que pueden trabajar para conseguir un fin deberían estar juntos, mientras que los que no tienen ninguna relación directa con ese fin deberían estar separados. Este tipo de cohesión, generalmente, resulta en un código compartido, que es difícil de modificar y que implica estar pasando parámetros entre módulos que en ocasiones pueden ser innecesarios. Si pensamos en el típico y tópico caso de una tienda online. Podríamos tener varios módulos que se relacionan entre sí, como el módulo de autenticación, el módulo de gestión de productos, y el módulo de gestión de pedidos. Cada uno de estos módulos tendría su propia funcionalidad, pero estarían lógicamente conectados entre sí. Cuando un usuario inicia sesión, el módulo de autenticación se encargaría de autenticar al usuario y el módulo de gestión de productos mostraría los productos disponibles en la tienda. El problema aparecerá si los módulos están muy entrelazados y se cambia el funcionamiento o el comportamiento, mejor dicho de alguno de ellos, ya que implicará que se adapte el resto de módulos. Si cada módulo es verdaderamente independiente, entonces podemos hacer cambios en uno, y no debería implicar la modificación del resto. Cohesión temporal La cohesión temporal es parecida a la lógica pero, como su nombre indica, en este caso los distintos módulos tienen relación en el tiempo. Un ejemplo muy claro se da cuando tenemos una parte en nuestro código que se encarga de inicializar la aplicación. En ese momento estaremos uniendo distintos módulos que sólo tienen tienen en común el actuar dentro de esa funcionalidad. Este tipo de cohesión tiende a presentar las desventajas de los módulos con cohesión lógica. Sin embargo, se considera una cohesión más fuerte, ya que los módulos tienden a ser más simples puesto que todos los elementos se ejecutan en un solo momento (es decir, normalmente no hay parámetros y lógica para determinar qué elemento ejecutar). Cohesión comunicativa En este tipo de cohesión, los elementos operan sobre los mismos datos o sobre un subconjunto de ellos. Por ejemplo, el elemento que gestiona el estado de conexión de un usuario o usuaria en un sistema de mensajería, y el que muestra el estado de los contactos. Operan sobre el mismo dato (estado de conexión), pero son elementos distintos. Cohesión secuencial Se da cuando la salida de un elemento es la entrada del siguiente. Un ejemplo de cohesión secuencial se puede dar cuando llega una llamada a una API para almacenar un dato. Se van pasando por distintas capas que convierten por ejemplo un JSON a un objeto, para terminar llegando a la persistencia. En este ejemplo, cuando termina un elemento de hacer su trabajo, el resultado es enviado al elemento siguiente en la cadena. Cohesión funcional En un módulo cohesionado funcionalmente, todos los elementos están relacionados para llevar a cabo una sola función, siendo lo suficientemente pequeños. Pensemos en una aplicación de procesamiento de imágenes. En este caso, podríamos tener diferentes módulos para la captura de imágenes, la edición de imágenes y la exportación de imágenes. Cada uno de estos módulos tiene una función específica, pero están conectados para permitir una edición y exportación efectiva de las imágenes. Si estos módulos no estuvieran funcionalmente conectados, podría ser difícil mantener y escalar el código. Por ejemplo, si el módulo de edición de imágenes no estuviera diseñado para trabajar de manera efectiva con el módulo de exportación de imágenes, las imágenes podrían no exportarse correctamente. En este tipo de cohesión cada módulo es lo suficientemente pequeño como para que se pueda comprender toda su implementación de una sola vez. En el momento en que empezamos a añadir distintos caminos y flujos, el módulo seguramente se pueda hacer aún más pequeño. ¿Cómo detectar el tipo de cohesión? Una técnica útil para determinar el tipo de cohesión de un módulo consiste en escribir una oración que describa el propósito del módulo y luego examinar la oración. Se pueden realizar las siguientes pruebas: Si la oración es compuesta, contiene una coma o más de un verbo, el módulo probablemente está realizando más de una función; de modo que, probablemente, tiene cohesión secuencial o comunicativa . Si la oración contiene palabras relacionadas con el tiempo, como &quot;primero&quot;, &quot;siguiente&quot;, &quot;entonces&quot;, &quot;después&quot;, &quot;cuando&quot;, &quot;comenzar&quot;, etc., entonces el módulo probablemente tiene cohesión secuencial o temporal . Si el predicado de la oración no contiene un objeto específico que siga al verbo, es probable que el módulo tenga cohesión lógica . Por ejemplo, &quot;Editar Todos los Datos&quot; tiene un cohesión lógica; sin embargo, &quot;Editar la Declaración de Origen&quot; puede tener cohesión funcional . Palabras como &quot;inicializar&quot;, &quot;limpiar&quot;, etc. implican cohesión temporal .",
    "imageMini": "/images/acoplamiento-cohesion-mini.webp"
  },
  {
    "slug": "20230324.html",
    "title": "Hablemos de acoplamiento y cohesión. Parte 1",
    "description": "Ya hemos hablado del Principio de Responsabilidad Única, y no, no es una idea original de Robert C. Martin, sino que este principio parte del concepto de \"**cohesión**\". Es más, el Principio de Inversión de Dependencias, tampoco es algo original y lo que nos habla es de \"**acoplamiento**\".",
    "url": "/articles/posts/20230324.html",
    "date": "2023-03-24",
    "categories": [
      "Diseño y arquitectura"
    ],
    "content": "Un poco de historia Ya hemos hablado del Principio de Responsabilidad Única , y no, no es una idea original de Robert C. Martin , sino que este principio parte del concepto de &quot; cohesión &quot;. Es más, el Principio de Inversión de Dependencias , tampoco es algo original y lo que nos habla es de &quot; acoplamiento &quot;. Las primeras personas que hablaron de estos dos conceptos, fueron Wayne P. Stevens , Glenford Myers y Larry Constantine en su artículo &quot; Structured Design &quot; publicado en 1968 en la revista IBM Systems Journal . Más tarde, en 1978, Tom DeMarco , en su libro &quot; Structured Analysis and System Specification &quot;, también describió la importancia de la cohesión como un factor clave para la calidad del software. Por lo que a lo largo de este artículo veremos que los conceptos de acoplamiento y cohesión, son la base y el origen de otros principios y patrones que ya conocemos. ¿Qué es la cohesión? La cohesión se refiere a la medida en que los elementos de un módulo((Con el término módulo nos estamos refiriendo a una parte de código con nombre que puede ser llamada desde otra parte y, preferentemente tiene su propio conjunto de variables)) están relacionados y trabajan juntos para cumplir una única función. Por lo tanto, podemos pensar en ella como un rompecabezas: cuanto mejor encajen las piezas, más alta será la cohesión. ¿Y qué significa esto? Pues ya que la cohesión nos dice cómo están relacionadas las diferentes partes de un módulo. Si las partes trabajan juntas de manera efectiva para cumplir una tarea específica, se dice que el sistema tiene alta cohesión. Pero si las partes no están bien conectadas o si cada parte hace muchas cosas diferentes, el sistema tendrá baja cohesión. Y como un ejemplo en código vale más que mil palabras. Comencemos con esta clase, en la que dejaremos los métodos vacíos porque lo importante es el nombre de éstos: Se puede ver que la clase Library hace demasiadas cosas. Si la introducimos en un módulo para gestión de bibliotecas, básicamente hará todo el trabajo ella. Y cualquier en cualquier tipo de gestión de la biblioteca, implicará un cambio en la propia clase. Para poder aumentar la cohesión del módulo necesitamos separar responsabilidades, para que haya distintas clases cada una con la suya, pero puedan trabajar en conjunto para conseguir el objetivo de gestionar una biblioteca. Como habéis podido ver tras el ejemplo en código... ¿esto no os suena del Principio de Responsabilidad Única? Efectivamente, en otras palabras, el principio nos dice que necesitamos tener una alta cohesión. ¿Y el acoplamiento? Con acoplamiento nos referimos a la forma de definir cómo están conectadas las diferentes partes de un sistema. Si dos módulos están altamente acoplados, significa que están muy interconectados y que cualquier cambio en uno de ellos puede afectar el funcionamiento del otro. Por otro lado, si dos módulos tienen un bajo acoplamiento, significa que están menos interconectados y que los cambios en uno de ellos no afectarán al otro. De forma que, lo ideal es que los módulos tengan un bajo acoplamiento, ya que al minimizar las conexiones entre módulos también se reducen los caminos por lo que se pueden propagar los cambios y los errores a otras partes del sistema. De este modo, se elimina el efecto de que un cambio en un módulo pueda causar errores en otro, así evitando realizar modificaciones adicionales para solventarlo. De todas formas, voy a poner un ejemplo para simplificarlo. En este caso, vamos a dos funciones que hacen los mismo (calcular el área de un cuadrado), pero tienen dos niveles de acoplamiento distinto. La primera función depende de recibir un input HTML del que se va a leer el valor del lado del cuadrado, para posteriormente devolver el área calculada. Si cambiamos el método de entrada, no nos quedará otra que modificar la función. Así que esta función representa un alto acoplamiento. Sin embargo, en la segunda función, no importa como se haya obtenido el dato que representa el lado del cuadrado, es por ello que presenta un bajo acoplamiento. Resumiendo, cuando hay un alto acoplamiento, es la señal de que debemos abstraer de la existencia de otros módulos en la medida de lo posible. Y como comentamos en el primer párrafo de este artículo, ¿esto a que os suena? Efectivamente, al Principio de Inversión de Dependencias. Bajo acoplamiento, alta cohesión El acoplamiento y la cohesión, son dos conceptos muy importantes y estrechamente relacionados. Ya que como vimos en los apartados anteriores, si los módulos de nuestro programa están altamente acoplados, significa que cualquier cambio en uno de ellos puede afectar a los demás y hacer que el código sea difícil de entender y mantener. Por otro lado, si los módulos tienen alta cohesión, significa que están altamente relacionados entre sí y que trabajan juntos para lograr una tarea específica. Por lo tanto, el objetivo es tener un código con alta cohesión y bajo acoplamiento. Esto hace que el código sea fácil de entender, modificar y mantener, lo que conduce a un software de mayor calidad y eficiencia. Es como tener un equipo de trabajo bien coordinado, donde cada miembro sabe exactamente lo que tiene que hacer y trabaja en armonía con los demás para conseguir un objetivo común. En resumen, podemos decir que el acoplamiento y la cohesión son dos caras de la misma moneda en la programación. Una buena gestión de ambos conceptos puede llevar a un código limpio, fácil de entender y mantener. Así que ya sabes, ¡reduce el acoplamiento y aumenta la cohesión para subir un nivel en el mundo de la programación! (con pareado de regalo). Espero que esta primera parte os haya servido para comprender los conceptos. En la segunda parte, veremos más en detalle cada una de ellas, centrándonos en los tipos de acoplamiento y cohesión existentes, incluyendo ejemplos de cada tipo.",
    "imageMini": "/images/acoplamiento-cohesion-mini.webp"
  },
  {
    "slug": "20230310.html",
    "title": "Caso práctico TDD",
    "description": "Por poner el broche de oro a esta mini-serie de artículos sobre TDD, vamos a ver un caso práctico con algo muy sencillo que todos conocéis: una pila. Por si queda algún despistado o despistada, una pila es una lista ordenada que permite almacenar y recuperar valores. El acceso a estos datos sigue el patrón LIFO (del inglés Last In, First Out, \"el último en entrar es el primero en salir\"). Básicamente, podéis pensar en la típica pila de platos, en la que el último plato que se pone encima, será el primero que quitemos.",
    "url": "/articles/posts/20230310.html",
    "date": "2023-03-10",
    "categories": [
      "Testing"
    ],
    "content": "Por poner el broche de oro a esta mini-serie de artículos sobre TDD , vamos a ver un caso práctico con algo muy sencillo que todos conocéis: una pila. Por si queda algún despistado o despistada, una pila es una lista ordenada que permite almacenar y recuperar valores. El acceso a estos datos sigue el patrón LIFO (del inglés Last In, First Out, &quot;el último en entrar es el primero en salir&quot;). Básicamente, podéis pensar en la típica pila de platos, en la que el último plato que se pone encima, será el primero que quitemos. Para este caso, se usará JavaScript estándar, haciendo uso de clases. De todas formas, si alguien tiene dudas sobre algo del lenguaje, podéis preguntarme en comentarios que responderé con todo gusto. Primer test. Crear una instancia Como estamos usando TDD, lo primero de todo será definir el test a probar: Si ahora ejecutamos el test, fallará como cabe espera: Tenemos que escribir el código mínimo para que el test pase, así que, crearemos la clase: Y tendremos nuestro test pasado: De aquí en adelante, ya no os pondré la salida de error y de passed por consola 😉. Segundo test. Null al quitar un elemento de la pila vacía En este segundo test, vamos a verificar que si ejecutamos la operación de quitar un elemento de la pila, y esta se encuentra vacía, se devuelve el valor null . Para hacer que el test pase, como tenemos que escribir el código mínimo, simplemente crearemos un método pop() que devolverá null al ejecutarlo. Tercer test. Añadir un valor y eliminarlo Ahora tenemos que probar que si añadimos un valor y lo eliminamos se obtiene ese mismo valor. Ahora el código de la clase debería seguir haciendo lo mínimo posible, pero vamos a ir un paso más allá (para no eternizar el ejemplo), y nos vamos a la fase de refactor, tras la que tendríamos: Cuarto test. Devolver null si no quedan elementos por quitar Obsérvese que como aún no hemos gestionado más de un objeto en la cola, no estamos controlando que haya varios, es por ello que en este paso, asignaremos a null el valor, en cuanto llamemos a pop() . Y esto es por la regla de escribir el mínimo código posible. Quinto test. Añadir y eliminar varios valores a la pila Es necesario hacer una aclaración en esta parte, ya que si en el test, sólo hubiésemos añadido la última comprobación, omitiendo el resto de expects , no se hubiera podido verificar la pila nos devuelve cada valor eliminado, y según el código que ya teníamos, el test pasaría. Es por ello, que tenemos que dar mucha importancia a qué se quiere probar, porque un test que no esté bien escrito, es como si no existiera. En estos casos también es importante tener en cuenta, que si escribimos un test, y pasa sin tocar nada de código, puede que no estemos probando lo que queremos. Tras un refactor, en este caso tendremos lo siguiente: Se ha incluido una nueva clase, y en este caso, no hemos añadido tests para dicha clase, ya que es un getter/setter. Añadir tests en estos casos no tendría mucho sentido. Sin embargo, si hubiésemos necesitado una clase más compleja. Si que en este momento pausaríamos el test actual, para comenzar el desarrollo de la nueva clase con TDD. Una vez que hiciera todo lo que necesitamos, volveríamos a este test. Sexto test. Devolver longitud 0 cuando la pila está vacía Séptimo test. Obtener el número de elementos añadidos En este punto, como el test sólo ha probado el añadir elementos, no tenemos que tocar el resto del código, sólo la parte de añadir. Aunque sea cansino, recordad que vamos a mínimos en cada paso. Último test. Obtener el número de elementos tras añadir y eliminar varios elementos Conclusiones Después de haber visto un caso de uso de TDD, creo que podemos concluir que esta técnica es una herramienta valiosa para garantizar la calidad del software y mejorar la eficiencia del proceso de desarrollo. Al escribir las pruebas antes de escribir el código, se obliga a pensar cuidadosamente en los requisitos del software y en cómo se comportará en diferentes situaciones. El enfoque incremental de TDD también significa que el software se desarrolla en pequeños pasos, lo que facilita la detección de errores y la resolución de problemas antes de que se conviertan en problemas mayores. ¿Os ha parecido interesante? ¿tenéis dudas o sugerencias? Pues ya sabéis, podéis dejar un mensajito en la caja de comentarios.",
    "imageMini": "/images/caso-practico-tdd-mini.webp"
  },
  {
    "slug": "20230225.html",
    "title": "Testing y TDD. Algunos consejos",
    "description": "Tras la introducción a TDD que tuvimos hace un tiempo, he creído conveniente ampliar un poco la información del anterior artículo, para exponer algunas anotaciones sobre esta técnica.",
    "url": "/articles/posts/20230225.html",
    "date": "2023-02-25",
    "categories": [
      "testing",
      "TDD"
    ],
    "content": "Tras la introducción a TDD que tuvimos hace un tiempo, he creído conveniente ampliar un poco la información del anterior artículo, para exponer algunas anotaciones sobre esta técnica. Si hacemos un repaso rápido, podemos recordar que con TDD tendremos los pasos siguientes (de forma resumida): Análiza : antes de escribir el primer test, nos conviene estudiar que comportamiento deseamos probar, sus posibles entradas y salidas, restricciones, etc. Escribir un test que falle : escribe un test que va a fallar. Ya sea porque falta código, o porque aunque ya existe parte de ese código aún no tiene todas las funcionalidades que se esperan de él. Haz que el test pase : realiza los cambios mínimos para que el test pase correctamente. Refactoriza : ahora puedes cambiar el código para mejorarlo. En este punto hay que probar todos los tests para asegurar que no se ha roto nada con el refactor. Escribir el siguiente test que falle . Una vez visto este mini-repaso, pasemos a realizar algunas anotaciones sobre TDD. Anotación 1. Conjunto de datos de testing incompleto Uno de los puntos más importantes a tener en cuenta a la hora de trabajar con TDD, es tener un conjunto de datos de entrada y salida que nos dé la seguridad de tener todas las posibilidades probadas (al menos dentro de lo razonablemente posible). Y es que tener pocos datos, puede provocar que haya casos específicos que no sean correctos. Como norma general deberíamos tener casos de prueba para lo siguientes tipos de datos: Datos límite : esto es, el mínimo y máximo permitido. Aplicado a nivel de valores, parámetros de entrada variables, elementos en una lista, etc. Datos erróneos : datos que podrían generar una excepción en el código. Datos que difieran para cubrir lo máximo posible : por ejemplo, en el caso de que la entrada sea un usuario, podrían ser combinaciones dejando campos vacíos. Datos que provoquen distintas lógicas : en el caso de una cesta de la compra, deberíamos tener pruebas con los distintos métodos de pago. Anotación 2. Refactorizar dividiendo el código Puede que durante un refáctor de una clase o función con TDD, veas necesario separar la lógica, ya que el código ha crecido mucho y puede que esté comenzando a incumplir alguno de los principios SOLID . Aquí tenemos dos posibilidades la lógica y un poco más costosa y la ilógica pero más rápida: La opción lógica , sería comenzar a hacer TDD con esa nueva clase o función. Lo bueno es que puedes aprovechar seguramente parte de los casos que tienes y que afectaban al código que ibas a extraer. Así se mantiene todo el flujo de TDD, teniendo tests independientes para esta nueva parte. La opción ilógica , implica seguir manteniendo los tests en el componente inicial para que prueben la otra parte. Es más rápido porque no requiere cambiar los tests, pero a cambio, tienes tests de una parte de tu código en otro elemento. Si este nuevo componente comienza a crecer, el mantenimiento comenzará a flaquear por todos lados, además de que no estarán bien organizados. Y recordemos que el código de tests, debe ser tan &quot;limpio&quot; como el código del proyecto. Anotación 3. Actuación ante errores Pese a seguir la técnica de TDD, pueden surgir bugs, por ejemplo por casuísticas que no se habían tenido en cuenta. En este caso, no resuelvas el problema directamente. Añade un test con la lógica para provocar el fallo. Una vez hecho esto, comienza a corregir el código. Anotación 4. Tests de código externo previo a una actualización En este caso, la técnica es parecida a la de la anotación anterior. Si vamos a actualizar un código externo (por ejemplo, una librería) y queremos usar una funcionalidad nueva. Nos podemos asegurar de que sabemos llamar a esa funcionalidad y que devuelve lo que esperamos, escribiendo primero un test que la intente usar. Posteriormente, actualizaremos la librería y probaremos de nuevo para ver si hemos entendido como funciona. Crear tests para código externo también nos permite asegurarnos de que al actualizar la versión de éste, no rompe ninguno de los flujos y comportamientos que esperábamos. Como ejemplo: se cambia una entrada de la API pública y ahora pasa a ser obligatorio un parámetro que antes era opcional. Al actualizar la librería y lanzar los tests, todos aquellos que no pasen ese parámetro obligatorio se romperán. Gracias a ello, estaremos en preaviso de que no somos aún compatibles con esa versión. En este caso, hablar de código externo daría casi para otro artículo. Conclusiones TDD es una herramienta muy potente y permite cierta libertad a la hora de tomar algunas decisiones. Pero ello, no implica que usemos el martillo cogiendo la cabeza en lugar del mango. Es importante tener en cuenta los datos y la utilidad de los tests que estamos creando.",
    "imageMini": "/images/tdd-consejos-mini.webp"
  },
  {
    "slug": "20221220.html",
    "title": "BDD y Gherkin. Una pequeña introducción",
    "description": "BDD (Behavior Driven Development) o Desarrollo Dirigido por Comportamiento es una metodología que lleva varios años en el tintero, pero día a día va cobrando más fuerza. En este artículo aprenderemos más sobre ella.",
    "url": "/articles/posts/20221220.html",
    "date": "2022-12-20",
    "categories": [
      "Testing"
    ],
    "content": "BDD (Behavior Driven Development) o Desarrollo Dirigido por Comportamiento es una metodología que lleva varios años en el tintero, pero día a día va cobrando más fuerza. En este artículo aprenderemos más sobre ella. Historia de BDD BDD partió de distintas metodologías ágiles, que primero fueron comentadas sobre los años 2000 por Dan North . Posteriormente, Dan publicó un artículo llamado Introducing BDD , donde comenzó a desarrollar más el tema. Finalmente, el concepto de BDD terminó haciéndose un estándar, con la ayuda de Elizabeth Keogh en las charlas que dieron durante la &quot;Agile specifications, BDD and Testing eXchange&quot; celebrada en el año 2009. Y es que BDD nació como respuesta a los problemas que surgían al empezar con TDD (Desarrollo Dirigido por Pruebas). Ya que la mayoría de programadores y programadoras se encontraban con las mismas preguntas: ¿Dónde comienza el proceso de tests? ¿Qué probar y qué no probar? ¿Cuánto abarca una prueba? ¿Cómo llamar a las pruebas? ¿Cómo entender por qué falla una prueba? Conceptos de BDD Inicialmente, la idea de nuestros amigos Dan y Liz era que los tests más complejos se definieran de forma similar a las historias de usuario. Por lo que cualquier persona sin conocimientos técnicos podría plantear las pruebas. Es por ello, que partiendo de la típica definición de historia en el desarrollo ágil: Se pasó a una definición de comportamientos y escenarios. Así que ya no definiremos una prueba como tal, sino que pensaremos en el comportamiento que debería tener dicha aplicación. Es por ello, que al desarrollar con BDD, debemos pensar: &quot;¿cuál es la función más importante que la aplicación no hace?&quot;. Con esa idea en mente, podremos pasar de pensar &quot;no sé que probar&quot; a tener un comportamiento con &quot;la aplicación debería hacer X&quot;. Una vez que pensamos en comportamientos, en BDD se plantea el siguiente esquema: Esta definición comprende las siguientes partes: Comportamiento a probar, o funcionalidad que se espera que cumpla el sistema. Por ejemplo, si estamos en una tienda online, el funcionamiento del carrito de la compra. Un comportamiento se compone de distintos escenarios. Los escenarios son los casos que ayudan a verificar el comportamiento. Siguiendo con el ejemplo anterior, pueden ser escenarios: añadir un artículo, eliminar un artículo, cambiar la cantidad, etc. Un escenario se compone de lo que se llama pasos, éstos se encuentran agrupados en: Requisitos , es aquel estado inicial que deja el escenario listo para probar. Las operaciones son los pasos a seguir para probar el escenario. El resultado , tal y como su nombre indica, es lo que se desea verificar tras seguir los pasos. El conjunto de pasos de cada escenario, se pueden relacionar con el sistema de tests en cuatro fases de la forma siguiente: Se puede observar como la fase &quot;Tear down&quot;, no existe de base en BDD, lo que no quita que frameworks como Cucumber permitan tener esta fase en BDD. Ventajas de BDD Tras haber visto un poco la introducción a BDD, lo siguiente que podéis pensar es ¿qué ventajas puede acarear el definir así las pruebas? Define un estándar para que negocio y desarrollo puedan entenderse : Para ello, se utiliza un lenguaje natural, o muy aproximado al lenguaje natural, de forma que cualquiera puede aprenderlo sin tener conocimientos técnicos. Ayuda a comprender mejor qué se espera del desarrollo de la historia : Gracias a la naturalización de los conceptos y las definiciones (sin tener abreviaturas y huyendo de los términos técnicos de cada tecnología), se puede tener un objetivo claro en mente que ayude a comprender que se debe llevar a cabo. Cualquier persona relacionada con la aplicación puede definir los casos de uso : Tal y como comentamos antes, al usarse un lenguaje sencillo, no importa que la persona que quiera definir los comportamientos no tenga conocimientos técnicos. Eso sí, será importante que sí tenga conocimiento de negocio para evitar casos innecesarios o poco definidos. Ya lo decía Martin Fowler en su charla Not Just Code Monkeys : &quot;No es tan importante saber determinados lenguajes, estos van y vienen, y en realidad no son tan diferentes entre sí. Aprender el dominio en el que estás trabajando. Esa sí que es una habilidad muy útil.&quot; Martin Fowler En independiente del framework de pruebas utilizado : BDD nos da una serie de pautas para definir los comportamientos, es por ello que, al igual que los patrones de diseño se pueden aplicar a prácticamente cualquier lenguaje, todos los frameworks que usemos para BDD serán muy similares. Es muy fácil convertir la definición de una historia en casos BDD y viceversa : Ya hemos visto que los pasos que definen un escenario partían de la definición estándar de historias en el desarrollo ágil. Es por ello, que la transcripción de una historia a BDD es algo casi automático, si hemos definido la historia de forma correcta. BDD + TDD Recapitulando, hemos visto hasta ahora que, con BDD tenemos una forma estándar de poder definir casos de prueba, así como de llevarlos a cabo. Pero ¿cómo encaja esto en un flujo de desarrollo habitual? Pues bien, BDD, se basa en los mismos principios que TDD, es decir, se escribe un caso que falle, se desarrolla y/o se refactoriza hasta hacer que funcione. Como podéis ver en la imagen anterior: Escribimos un escenario que falle. Comenzamos con TDD hasta que todos los tests pasen. Una vez que pasen todos los test de lo que podríamos decir, que es la parte TDD, volvemos al escenario para ver si el escenario se prueba correctamente. Si no es así, seguiremos refactorizando. BDD en la pirámide de tests No hemos mandado a BDD de viaje por Egipto como si fuera una historia de Astérix, sino que vamos a ver como se integraría BDD en la famosa pirámide introducida por Mike Cohn en su libro Succeeding with Agile . Para aquellas personas que no conozcáis la pirámide de test, básicamente nos indica que peso en la aplicación debe tener cada tipo de test. De forma que, de forma resumida, debe haber más tests unitarios y menos tests manuales. La pirámide de la imagen tiene algunos cambios respecto a la original, basado en mi experiencia, así que la podríamos llamar la pirámide V2. Paso a comentaros que es cada escalón: Tests unitarios : permiten probar pequeños componentes o funcionalidades sencillas para verificar que funcionan como se espera de forma aislada. Tests de componentes : siguen siendo tests unitarios pero que agrupan varias funcionalidades en una. Por ejemplo, un test unitario puede aplicarse a un elemento de un menú, y un test de componente lo podríamos ejecutar sobre todo un menú compuesto de distintos elementos. En el caso de un servicio REST, un test unitario podría ser la creación de un usuario, y un test de componente, toda la API para gestión de usuarios. Tests de integración : hasta ahora, los dos tipos de tests anteriores si requerían de alguna entidad externa, se creaban mocks para simularla. Sin embargo, con este tipo de tests lo que hacemos es verificar que el comportamiento de nuestro sistema es el esperado cuando interacciona con elementos externos. Por ejemplo, tenemos un servicio REST que llama a otro servicio. Este tipo de tests pueden requerir bastante configuración, es por ello que aunque importantes, no tienen tanto peso como los dos escalones anteriores. Tests de sistema o de aceptación : se aplicaría o a la interfaz de usuario, pero también implica pruebas en sistemas sin interfaz gráfica. En este escalón lo que queremos es probar que todo el conjunto de nuestro sistema opera correctamente. Son los tests automáticos que tardan más en ejecutarse, es por ello que normalmente habrá menos tests de sistema. Test manuales : toda prueba que realiza una persona. Este tipo de tests dependen mucho de quién los realice, es por ello que puede darse el caso que no sean todo lo fiable que nos gustaría. Esta pirámide no es algo obligatorio a seguir, incluso dependiendo del tipo de aplicación, puede que se llegue a dar incluso una pirámide invertida, donde los tests de sistema tengan más peso que los unitarios, una en formato trofeo, donde los de integración sean los importantes, etc. Como todo en el mundo de la programación, no viene prefijado y se puede ajustar según necesidad. Tras el inciso para hablar de la pirámide, podéis ver que BDD se integraría en los tests de componentes, integración y sistema. No tendrían sentido a nivel de tests unitarios, puesto que tendríamos que definir con BDD hasta el más mínimo comportamiento del método más pequeño, esto sería algo muy engorroso. Por otro lado, respecto a los tests manuales, a una persona se le puede dejar los comportamientos de BDD para que los pruebe, pero es mejor evitar guiar a quien testea, puesto que siempre tenderá a ceñirse a los escenarios definidos en BDD. Sobre como plantear los test manuales podemos profundizar más en otro artículo, sí así gustáis. Gherkin. Un lenguaje para dominarlos a todos Una vez que sabemos como proceder, nos falta conocer el estándar. A nivel conceptual con BDD, no es obligatorio casarse con ningún lenguaje, pero prácticamente el que ha prevalecido sobre los demás, es Gherkin. Éste permite definir las pruebas de una forma natural y expresiva. Pero como todo lenguaje tiene ciertas palabras clave. Y estas son: Ya habéis podido comprobar como esa estructura se parece mucho a lo que vimos al principio, y que como la definición de una historia de usuario puede fácilmente adaptarse a ese esquema. De ahora en adelante, los ejemplos tendrán las definiciones en inglés, simplemente para que podáis ver algo más real, aunque hay librerías como Cucumber que permiten usar otros idiomas, como por ejemplo, el español. De todas formas, en la mayoría de los casos seguro que os encontráis con definiciones en inglés. Comencemos con un ejemplo de un caso de prueba en la especificación de un supuesto reproductor de vídeo podría ser: Esta claro que la especificación anterior podría ser escrita por cualquier persona sin conocimientos técnicos. Y es por ello que Gherkin es tan potente. Pero claro, seguro que echas en falta poder indicar valores a las pruebas, pues bien, en Gherkin se pueden indicar valores para que sean tenidos en cuenta en las pruebas. Sigamos con nuestro reproductor de vídeo y pensemos en un botón que salte un segundo hacia delante. Un escenario podría ser: Ese valor entrecomillado es un atributo que nuestras pruebas podrán leer, aunque por ejemplo, con los valores numéricos no es necesario. Eso sí, podemos ir más allá, y trabajar incluso con tablas. Lo siguiente ejecutará una prueba por cada fila de la tabla: En este caso, se puede apreciar como es posible recoger los valores de cada columna encerrando el nombre de ésta entre los símbolos &lt; y &gt; . Pero esto no termina aquí. Gherkin tiene muchos más operadores y palabras clave: And : permite añadir una condición a cualquiera de los pasos But : condición negativa para cualquier paso Background : define una condición que se cumple antes de todos los escenarios. Scenario Outline : permite repetir un escenario varias veces con un conjunto de datos. | : se usa para delimitar tablas. @ : define etiquetas para filtrar escenarios. # : al inicio de una línea indica comentario. &quot;&quot;&quot; : permite definir un texto de varias líneas. Y con todo lo anterior podemos tener casos todo lo complejos que queramos, como por ejemplo, el siguiente, en el que vamos a simular un almacenamiento en la nube: Qué evitar hacer en Gherkin Para mejorar nuestras definiciones de comportamientos hay dos cosillas que deberíamos evitar siempre: Usa lenguaje de negocio no tecnológico Hay que evitar definir los pasos de los escenarios de forma dependiente a la tecnología, es decir, deberiamos evitar frases como &quot;haz click&quot;, &quot;realiza una llamada POST&quot;, etc. Por un lado, porque podremos reutilizar los escenarios entre distintas partes del proyecto; y por otro, y más importante, porque quién defina la historia, ya dijimos que puede que no tenga conocimientos técnicos, de forma que no tiene por qué saber que por ejemplo una llamada va por API REST, por WS, etc. Con el ejemplo anterior podemos ver como el segundo escenario es posible utilizarlo en una parte back y front. En la primera se tomarán credenciales de un rol que pueda crear usuarios y el test terminará realizando una llamada a un API, y en la segunda se realizarán todos los pasos necesarios para crear el usuario desde interfaz. Evitar pasos que puedan tener doble sentido Es importante evitar utilizar nombres de steps que tengan distintos contextos. Si por ejemplo, tenemos un paso con el contenido &quot;se borra el texto&quot;, seguramente dependerá del escenario en qué se use. Es por ello, que es preferible tenemos pasos con contenidos como &quot;se borra el nombre de usuario&quot;, &quot;se borra el título del artículo&quot;, etc. Por un lado, queda mucho más claro qué hace el paso, y por otro permite evitar confusiones. Antes de terminar Una vez que hemos aprendido algo sobre BDD y Gherkin es manos de ponerse a la obra, así que ¿cómo podemos seguir? Pues, para aplicar esto tenéis frameworks como Cucumber que nos ayuda a implementar BDD. Pero, recordad que BDD es una metodología, por lo que no os obliga a casaros con ningún framework y lo podéis implementar libremente.",
    "imageMini": "/images/bdd-mini.webp"
  },
  {
    "slug": "20221218.html",
    "title": "Plantilla de proyecto TypeScript",
    "description": "A la hora de comenzar un nuevo proyecto, suele costar bastante configurar todo. Es por ello, que por simplificar un poco las cosas, acabo de crear una plantilla, basada en TypeScript, Vite y Jest. Para usarla, podéis crear un fork o descargar el código y ajustarlo a vuestras necesidades libremente. Este código lo podéis encontrar en GitHub. Esta plantilla necesita de node en su versión 16.0.0 como mínimo.",
    "url": "/articles/posts/20221218.html",
    "date": "2022-12-18",
    "categories": [
      "TypeScript",
      "plantilla"
    ],
    "content": "A la hora de comenzar un nuevo proyecto, suele costar bastante configurar todo. Es por ello, que por simplificar un poco las cosas, acabo de crear una plantilla, basada en TypeScript , Vite y Jest . Para usarla, podéis crear un fork o descargar el código y ajustarlo a vuestras necesidades libremente. Este código lo podéis encontrar en GitHub . Esta plantilla necesita de node en su versión 16.0.0 como mínimo. Comandos Una vez que tengáis el proyecto, podréis ejecutar distintos comandos anteponiendo npm run . dev : Modo de desarrollo, lanza un servidor de live-preview, que va actualizándose según hacéis cambios en el código: compilando el código TypeScript y actualizando las referencias. build : Compila y minifica el código, de forma que lo deja listo para usar en el entorno de distribución. El resultado final lo podrás encontrar en el directorio dist . preview : Lanza un servidor para poder ver los cambios del distribuible generado. test : Lanza los tests unitarios. Estructura La estructura del proyecto es muy sencilla. En la carpeta raíz se tiene el fichero index.html , que hace de punto de partida, y todo el código fuente se almacena en el directorio src . Dicho directorio, a su vez, contiene la carpeta __tests__ , donde se incluir los tests unitarios a desarrollar con Jest. Enlace al repositorio typescript-boilerplate .",
    "imageMini": "/images/tsvitejest-mini.webp"
  },
  {
    "slug": "20221211.html",
    "title": "Testing y TDD",
    "description": "A día de hoy, muchas veces el software falla porque lo programan personas, por lo que es factible que tenga errores. Así que como desarrolladores y desarrolladoras, debemos siempre intentar minimizar esos fallos. Para ello disponemos de varias herramientas, y una de las más útiles son los tests. Estos pueden ser automáticos o manuales.",
    "url": "/articles/posts/20221211.html",
    "date": "2022-12-11",
    "categories": [
      "testing",
      "TDD"
    ],
    "content": "Tests A día de hoy, muchas veces el software falla porque lo programan personas, por lo que es factible que tenga errores. Así que como desarrolladores y desarrolladoras, debemos siempre intentar minimizar esos fallos. Para ello disponemos de varias herramientas, y una de las más útiles son los tests. Estos pueden ser automáticos o manuales. Si hablamos de la vertiente automática, se puede definir un test como un bloque de código que permite aseverar el cumplimiento de determinadas afirmaciones. A su vez, cada afirmación viene dada por una sentencia, en la que un método o una función comprueban si un valor cumple con las expectativas. ¿Cómo deberían ser los tests? A la hora de testear podemos seguir algunas directrices: Confianza en el código : Es importante que pruebes todo lo que sea necesario para tener confianza en el código desarrollado. No significa que se deba probar hasta el más mínimo resquicio, sino que pruebes todos los comportamientos que se esperan. Reducir el código malo : Usa los tests para reducir en la medida de lo posible el mal código. Por ejemplo, si surge un error, deberías crear un test que asegure que éste problema no se vaya a repetir en el futuro. Además, estos nuevos tests te ayudarán a documentar el error. Prueba una cosa, afirma varias : Incluye todas las afirmaciones que sean necesarias en un test. Lo importante es asegurarnos de que todas las partes afectadas por el test tengan los datos correctos. Los tests primero : Deberías definir los tests a realizar antes de programar. Esto significa que es buena idea pensar el enunciado de los tests, para tener una visión global de la funcionalidad a desarrollar. Además, ayudará a entender mejor que se debe hacer. Ejecuta los tests : Parece una obviedad, pero es muy importante que una vez que exista un test se ejecute siempre. Por ejemplo, los tests unitarios deberías ejecutarlos al menos, antes de hacer un commit y antes de hacer un deploy a un entorno de test. Lanzar los tests necesarios en los momentos necesarios : Es importante que aprendas a ejecutar un subconjunto de tests unitarios, ya que aunque los tests sean rápidos por si sólos, en cuanto haya unos cientos, el tiempo de ejecución total puede ser bastante alto. Es por ello, que mientras desarrollas debes saber como poder ejecutar sólo los tests que estés modificando, para ahorrar tiempo. Esto no quita que, de vez en cuando, ejecutes toda la suite de tests para asegurarte de que todo sigue en su sitio. Automatiza la ejecución de tests : A día de hoy resulta casi impensable que haya un sistema de CI/CD (Integración continua, despliegue contínuo), que durante el proceso no ejecute los tests, ya sean unitarios, de integración, etc. Tests en las revisiones : Es buena idea comenzar a ver los casos de tests que has creado en las revisiones de código. Por un lado, junto con la definición de la historia, puede ayudar a quienes van a revisar el código a entender si se cumple el comportamiento de la funcionalidad desarrollada. Por otro, seguro que te obliga a revisar mejor los tests antes de enseñarlos a otras personas. Y si no haces revisiones de código, deberías comenzar cuanto antes &#x1f609;. Nomenclatura de los tests Una de las primeras recomendaciones al escribir el nombre de los tests, es comenzar a utilizar la palabra &quot;should&quot; (&quot;debería&quot; en castellano). Puede parecer una tontería, pero su semántica nos puede ayudar a entender el por qué: cuando indicamos, por ejemplo, un nombre del estilo &quot;debería hacer X cuando Y&quot;, éste ya nos está ayudando a pensar si realmente esa funcionalidad es del componente a testear. Incluso si a futuro la funcionalidad ha cambiado, tendrá todo el sentido del mundo ver que el nombre del test nos &quot;pregunte&quot; si debería seguir ocurriendo lo que hacía. Si vemos que no se puede escribir un test bajo esa premisa, quizás sea porque éste debería pertenecer a otro elemento en el código: una clase nueva, otra función, etc. Y es que a la hora de redactar pruebas, se comprueba como un test con un buen nombre brilla en los momentos en los que éste falla. Si el nombre no te aporta nada cuando el test falla, debes darle una vuelta para mejorarlo. Pensemos por ejemplo en la típica funcionalidad que nos envía un correo de confirmación al cambiar nuestra contraseña. Si tengo una clase que gestiona la autenticación de usuario, no tiene sentido tener un test: &quot;debería autenticarme con el usuario X, acceder a su configuración, cambiar la contraseña y recibir un email de confirmación&quot;. Con esto, vemos por ejemplo, como el nombre del test nos da la pista de que esa clase está haciendo demasiadas cosas, lo que incumple la S de los principios SOLID , llevándonos a liberarla de responsabilidades. Flujo de test en cuatro fases A la hora de escribir tus pruebas viene bien seguir el patrón de test en cuatro fases , que nos define qué flujo de ejecución debería seguir cada test: Setup : fase en la que se construye todo lo necesario para que el test tenga listo el entorno de su ejecución. Exercise : pasos para que el test se ejecute. Por ejemplo: instanciar una clase y llamar a varios de sus métodos. Verify : comprobación del resultado esperado tras ejecutar los pasos de Exercise. Teardown : fase opcional en la que se restaura todo lo modificado por el test. Normalmente, esto aplicará más a estructuras compartidas globalmente, mocks estáticos, etc. TDD A finales de los 90 del siglo pasado Kent Beck , como parte de Extreme Programming, desarrolló y especificó la técnica TDD (Test-Driven Development o Desarrollo Guiado por Test). Básicamente, se basa en construir el software a través de la escritura de tests, definiendo tres sencillos pasos a seguir basados en los colores de los semáforos: Beneficios de TDD TDD pone el foco en el comportamiento (recordad esta palabra) del código y no en su implementación, puesto que al desarrollar con TDD se escribe cada test antes de su correspondiente código de producción. Seguir esta orientación en el desarrollo te proporciona varios beneficios: Vas a escribir código como respuesta a que un test pase. Esto significa que el código va a estar bien testeado y el código no hará más de lo que debe. El segundo es que este planteamiento te hará pensar primero en la interfaz del código, antes de que en su implementación. Lo que te ayudará a tener mejor estructurado el código y sólo hacer público lo que sea necesario. Finalmente, como resultado a los dos beneficios anteriores, tenemos un código con menos errores. Y es que en el estudio &quot;Does Test-Driven Development Really Improve Software Design Quality?&quot; de David S. Janzen y Hossein Saiedian, ya se indica como con TDD se reduce sustancialmente el número de errores que aparecen en el software al aplicar la técnica. Flujo de desarrollo en TDD Momento de pensar : por desgracia es la fase más olvidada en los flujos de desarrollo, y es que antes de escribir una sóla línea de código, habría que detenerse a pensar cuál es el objetivo del código que vamos a desarrollar, que posibles restricciones o casos especiales hay, etc. Todo esto nos ayudará a tener un esquema del comportamiento esperado para la funcionalidad a crear, y evitará los cambios de última hora porque no tuvimos en cuenta el alcance de lo que se quería desarrollar. Escribe el primer test : una vez que tenemos claro el objetivo a conseguir. Escribiremos el primer test... Sí, aún no hay nada de código, pero el test usará la interfaz que nos gustaría crear, esto te ayudará a pensar no en la implementación del código, sino en la interfaz que como &quot;agente externo&quot; te gustaría usar. Este primer test, como es lógico, va a fallar. Hora de programar : ahora es el momento de implementar el esqueleto que usaste en el test, hasta hacer que éste pase. Refactoriza : una vez que los tests de la funcionalidad que querías desarrollar se ejecuten correctamente, es el momento de revisar y refactorizar el código para que quede lo mejor posible. Sobra decir, que tras refactorizar, los tests deben seguir terminando de forma satisfactoria. Eso sí, limítate a refactorizar el código actual, no pienses en futuras mejoras (que puede que nunca lleguen), recuerda que refactorizar no significa cambiar el comportamiento del código. Volver a la casilla de salida : cuando tengas una nueva funcionalidad, tan sólo tendrás que repetir los pasos. La clave principal de este flujo de desarrollo, es realizar pequeños cambios de forma incremental. Por lo que en todo momento, se espera que el código escrito esté bien testeado. Legacy code y TDD TDD no sólo sirve para desarrollos nuevos. En el caso de tener que modificar legacy code (código antiguo u obsoleto y que normalmente no tendrá tests), TDD nos permitirá seguir un flujo que ayude a comprobar este código. Primero escribiremos los tests para verificar que se comprueba lo que hace el código antiguo. Una vez que tenemos los tests, ya podemos comenzar a añadir o corregir las funcionalidades. Si es una nueva funcionalidad seguiremos el flujo habitual. En caso de que se vaya a corregir un comportamiento erróneo, se partirá por retocar el test que se hizo pasar con el comportamiento erróneo, para adaptarlo a la corrección. A partir de ahí, el test fallará y ya podremos comenzar con nuestro ciclo TDD habitual. Conclusiones TDD plantea muchas ventajas a la hora de desarrollar: Permite pensar primero antes de escribir una sola línea de código. Ayuda a definir una interfaz útil basada en lo que es necesario. Permite reducir sustancialmente el número de errores. Mejora la mantenibilidad del software. Por contra, su mayor inconveniente es el coste de acostumbrarse a aplicarlo. Por lo que inicialmente desarrollarás más lento. Pero a la larga, aparte de mejorar en velocidad, podrás comprobar como el tiempo de desarrollo global se reduce, puesto que estarás introduciendo menos errores en el código, de forma que no se perderá tanto tiempo en mantenerlo. Una vez que conocemos los conceptos de TDD, el siguiente paso será ir a por BDD...",
    "imageMini": "/images/tdd-mini.webp"
  },
  {
    "slug": "20221029.html",
    "title": "Cosas que quizás no sabías de CSS",
    "description": "Con la reciente encuesta del estado de CSS, vamos a comentar algunas características que pueden ser menos conocidas de CSS. Espero que os sirva de ayuda &#x1f603;.",
    "url": "/articles/posts/20221029.html",
    "date": "2022-10-29",
    "categories": [
      "Programación",
      "CSS"
    ],
    "content": "Con la reciente encuesta del estado de CSS , vamos a comentar algunas características que pueden ser menos conocidas de CSS. Espero que os sirva de ayuda &#x1f603;. 1. Visualizar texto en vertical ¿Alguna vez has querido poner un texto en vertical y has estado jugando con los filtros de CSS? Pues, una forma muy sencilla de situar un texto en vertical es con la propiedad writing-mode . 2. Espacio entre elementos ¿Recuerdas los tiempos en los que para diseños con varias filas y columnas usabas las propiedades margin y padding para dejar espacio entre ellas? Pues eso es cosa del pasado gracias a la propiedad gap . Quizás, ya conocías esto, pero lo que menos gente sabe es que, por un lado, gap, es unalias de grid-gap (puedes usar ambas de forma indistinta); y por otro que ambos son un shorthand o propiedad abreviada de grid-row-gap , y column-row-gap . Por lo que podemos especificar un espaciado distinto para filas y columnas, algo que podéis comprobar en el ejemplo siguiente: Esta propiedad la podréis usar con flex, grid y columnas (algo que veremos en el punto siguiente). 3. Texto en columnas de forma sencilla Lo primero que se te vendrá a la cabeza al hablar de texto en columnas, puede que sea un periódico. Y es que si necesitamos aplicar ese estilo, ya no nos tenemos que romper la cabeza, pues la propiedad column-count viene al rescate. Con ella, básicamente podemos indicar en cuantas columnas se dividirá el texto. 4. Filtros Ya llevan varios años entre nosotros, pero por si no lo sabías puedes aplicar una gran cantidad de efectos gráficos mediante el uso de CSS con la propiedad filter . Esta propiedad permite un sinfín de posibilidades, tantas que darían para un artículo (o varios). Ya que podemos combinar distintos efectos en un único filtro. En el código de ejemplo, os pongo una imagen (aunque se puede aplicar a cualquier elemento sea o no una imagen), a la que se aplican distintos filtros con CSS. 5. Ajustar el alto (y el ancho) al contenido Una de los valores predefinidos menos conocidos de CSS es fit-content . Aplicado al alto o al ancho de un componente, lo que hace es ajustar el tamaño del bloque HTML (ya sea ancho, alto o ambos) a su contenido. Un ejemplo lo podéis ver a continuación, donde al usar en éste flex, el alto de cada elemento se &quot;estira&quot; para igualarse al que tenga un alto mayor. Con la función fit-content , lo que haremos es que el componente que menos altura tiene se quede con ésta, en lugar de estirarse. Esta función se puede usar sin parámetros o de una forma más compleja, especificando el mínimo y el máximo. 6. Cambiar el color de fondo de algunos controles Seguro que más de una vez has visto que se oculta un checkbox con CSS para poner una especie de capa por encima que deje el checkbox con otro estilo u otros colores. Desde hace un tiempo, al menos si lo hacía por cambiar los colores, ya no es necesario. En este caso, con la propiedad accent-color , podrás modificar el color de fondo de checkbox, radio buttons, rangos y barras de progreso. 7. Aplicar estilos según el tema de color del sistema operativo CSS ha avanzado mucho en los últimos tiempos, y prueba de ello es que ahora podemos aplicar distintos estilos según el tema de color del sistema operativo. Para ello, disponemos de la media-query prefers-color-scheme . Con ella podemos comprobar si el usuario ha seleccionado un tema claro u oscuro (valores light y dark ), y según esto aplicar distintos estilos. Para probar el ejemplo siguiente, cambia el tema de color de tu sistema operativo. Si el navegador con el que estás viendo esta página lo soporta, deberías ver como cambian los colores del fondo y el texto.",
    "imageMini": "/images/css-mini.webp"
  },
  {
    "slug": "20220914.html",
    "title": "Web Workers en JavaScript",
    "description": "Estarás acostumbrado o acostumbrada a escuchar que JavaScript corre sobre un único hilo de ejecución. Esto puede en ocasiones acarrear problemas si una tarea es demasiada pesada, pues dejará bloqueado el hilo.",
    "url": "/articles/posts/20220914.html",
    "date": "2022-09-14",
    "categories": [
      "JavaScript"
    ],
    "content": "Estarás acostumbrado o acostumbrada a escuchar que JavaScript corre sobre un único hilo de ejecución. Esto puede en ocasiones acarrear problemas si una tarea es demasiada pesada, pues dejará bloqueado el hilo. Para solventar ese problema, se dispone de los Web Workers , que permiten ejecutar código JavaScript en hilos que se lanzan en segundo plano. Cabe destacar que estos workers utilizan un contexto global distinto al de la ventana (o worker) que lo lanza. Como consejo puedes usar globalThis para reducir dependencias de usar window , self , etc. El método de comunicación del worker con su creador es a través de mensajes gestionados como eventos. De forma muy parecida al sistema de comunicación entre iframes. Pero como siempre, será mejor que veamos el funcionamiento de los workers con varios ejemplos. Hola mundo de los workers En el código superior se puede ver lo sencillo que es crear un Web Worker. La ejecución del código terminará mostrando en la consola: &quot;Message received from worker: Hello from the worker&quot; . A la hora de definir un worker, se especifica la ruta en la que se encuentra el script que se ejecutará en segundo plano. Posteriormente, se pasa a escuchar los mensajes que envíe el worker asignando un callback al atributo onmessage . El callback asignado, recibirá como un objeto como parámetro que contendrá el atributo data con el contenido del mensaje enviado por el worker. Este contenido puede ser de cualquier tipo de dato. Mensajería entre Worker y creador En el caso de enviar un objeto en los mensajes, no hay problema de recursos compartidos, ya que se hace automáticamente un deep clone de dicho objeto. Este clonado se lleva a cabo gracias a la función structuredClone , que por si la desconoces, permite clonar objetos. Todo esto lo veremos con un ejemplo que incluye algo de sobreingeniería, pero nos servirá para verificar que no hay paso de objetos por referencia. Al ejecutar el código anterior, se podrá comprobar como en result se recibe un objeto con atributo value igual a 123; por otro lado el objeto data sigue teniendo el atributo value con valor 3. Esto es por lo que hemos comentado al principio de este apartado, los valores de los mensajes se pasan por valor y no por referencia. Control de errores Aparte de la mensajería estándar, es posible capturar aquellos errores que generen los Web Workers. Para ello asignaremos al atributo onerror del worker un callback que recibirá el evento con el error. La ejecución superior mostrará en consola: Como se puede apreciar, se recibe aparte del error generado, el fichero, así como la línea y columna en la que éste ha ocurrido. Finalizar un worker En el caso que queramos dar por finalizado un worker desde el creador, llamaremos al método terminate() , de forma que en este caso se termine la ejecución del worker, sin darle tiempo a realizar un &quot;cierre ordenado&quot;. Por otro lado, un worker puede indicar que ha terminado llamando a globalThis.close() (o self.close() ). En ambos casos, aunque se intenten enviar mensajes entre creado y worker, ya se habrá cerrado ese canal de comunicación. Conclusión Los Web Worker permiten llevar a cabo tareas pesadas fuera del hilo principal de JavaScript, y como habréis podido comprobar, es posible definirlos de forma muy sencilla. Tan sólo hay que especificar el fichero a utilizar como worker, y comunicar el creador y el worker con mensajes. Finalmente, tan sólo remarcar, que no todos los objetos globales están disponibles en los Web Workers, puedes encontrar el listado completo en MDN .",
    "imageMini": "/images/web-worker-mini.webp"
  },
  {
    "slug": "20220912.html",
    "title": "Faker: usa datos realistas en tus pruebas y demos",
    "description": "¿Te has cansado de usar siempre John Doe o Juanita Banana como nombre en tus pruebas? ¿Sientes que los tests no tienen datos realistas? ¿Quieres hacer una demo con datos que parezcan completamente auténticos?",
    "url": "/articles/posts/20220912.html",
    "date": "2022-09-12",
    "categories": [
      "librerías",
      "JavaScript",
      "TypeScript",
      "programación",
      "testing"
    ],
    "content": "¿Te has cansado de usar siempre John Doe o Juanita Banana como nombre en tus pruebas? ¿Sientes que los tests no tienen datos realistas? ¿Quieres hacer una demo con datos que parezcan completamente auténticos? En ese caso, Faker es exactamente lo que necesitas. Esta librería para JavaScript y TypeScript te permite generar datos aleatorios pero increíblemente verosímiles: nombres, direcciones, correos electrónicos, colores, contraseñas, títulos de trabajo, elementos químicos, palabras, imágenes y muchísimo más. En este artículo ampliado veremos cómo usarla y añadiremos un ejemplo completo de generación de datos falsos para una aplicación realista. Instalación del proyecto Para que puedas hacer una prueba rápida, lo primero será inicializar un proyecto con TypeScript e instalar la librería: Ahora debemos indicar que podamos importar módulos. Para ello añade al package.json lo siguiente: Listo. Ya podemos comenzar a generar datos realistas. Uso básico Ejemplo realista: generar usuarios para una API o demo Imagina que quieres poblar una base de datos local o simular un backend para una demo de frontend. Necesitas 20 usuarios coherentes , con su nombre, email, imagen de avatar, dirección completa y un rol laboral. Con Faker es tan sencillo como esto: Esto produce algo del estilo: Como puedes ver, esta librería es perfecta en casos como los siguientes: Necesitas rellenar una base de datos ficticia. Debes mostrar un listado de ejemplo con usuarios, productos, etc. en tu interfaz. Quieres simular peticiones a una API con datos realistas. Vas a preparar demos sin datos personales reales. Conclusión Hemos podido ver como Faker es una herramienta imprescindible para demos, prototipos y testing. Te ahorra tiempo, te evita tener que inventar datos y te permite trabajar con ejemplos mucho más naturales. Además, de añadir un punto de aletoriedad que puede venir bien a la hora de testear el código. Aún hay muchas más funciones a utilizar. Pero lo mejor es dar una vuelta a la documentación para descubrirlas todas. Espero que de ahora en adelante, puedas enriquecer los datos simulados gracias a esta librería.",
    "imageMini": "/images/faker-mini.webp"
  },
  {
    "slug": "20220807.html",
    "title": "Decorator para gente novata",
    "description": "Si hay un patrón de diseño que suele provocar algunas dudas, es el patrón Decorator. Pero básicamente, este patrón nos permite añadir responsabilidades a objetos de forma dinámica, es decir, que podemos ajustar el comportamiento de los objetos durante la ejecución de la aplicación. Con ello podemos ir añadiendo o quitando los cambios en el comportamiento en tiempo real. Esto por ejemplo, no sería posible con herencia, ya que se realiza de forma estática y no podemos cambiarla en tiempo de ejecución. La herencia tampoco nos permitiría tener varias clases madre (en la mayoría de lenguajes), por lo que no podemos \"unir\" varios de esos cambios de comportamiento.",
    "url": "/articles/posts/20220807.html",
    "date": "2022-08-07",
    "categories": [
      "programación",
      "diseño y arquitectura"
    ],
    "content": "Introducción Si hay un patrón de diseño que suele provocar algunas dudas, es el patrón Decorator. Pero básicamente, este patrón nos permite añadir responsabilidades a objetos de forma dinámica, es decir, que podemos ajustar el comportamiento de los objetos durante la ejecución de la aplicación. Con ello podemos ir añadiendo o quitando los cambios en el comportamiento en tiempo real. Esto por ejemplo, no sería posible con herencia, ya que se realiza de forma estática y no podemos cambiarla en tiempo de ejecución. La herencia tampoco nos permitiría tener varias clases madre (en la mayoría de lenguajes), por lo que no podemos &quot;unir&quot; varios de esos cambios de comportamiento. Ejemplo Para entenderlo un poco mejor, partamos de un ejemplo sencillo del mundo &quot;videojueguil&quot;. Pensemos en un juego como el reboot de Tomb Raider, en el que las armas tienen modificaciones. Estas modificaciones incrementan el daño de las armas, la precisión, etc. Lo anterior podríamos resolverlo de muchas formas, pero una de ellas es con decoradores, podemos tener el arco base, al que si le añadimos &quot;Palas Reforzadas&quot;, se incrementa el daño, si aparte le añadimos &quot;Cuerda Trenzada&quot; incrementamos más el daño, etc. Pues bien, cada tipo de &quot;añadido&quot; sería un decorador que modificaría las propiedades del arco, y lo mejor de todo, es que podremos tener varios decoradores de forma simultánea. De forma que un arco, siguiendo el ejemplo anterior podrá tener las &quot;Palas Reforzadas&quot; y la &quot;Cuerda Trenzada&quot; de forma simultánea. Diagrama En el diagrama UML, vemos que básicamente hay una interfaz que implementa las operaciones públicas de la clase que queremos &quot;envolver&quot; con decoradores, y que dicha clase, pasará a implementar la interfaz. Por otro lado, tenemos la parte de decoradores, en la que tenemos un decorador base y los decoradores hijos, todos ellos implementando la interfaz inicial. Paso a paso Con todo lo anterior, tendríamos los pasos siguientes para implementar el patrón Decorator: Extraer a una interfaz los métodos de la clase o las clases que queremos decorar. Crear un decorador base que implemente la interfaz y que reciba además dicha interfaz como parámetro en su constructor. Crear clases hijas del decorador, que se encargarán de actuar sobre la clase base. Ejemplo de código Ahora que tenemos las nociones, hemos visto el UML, y tenemos &quot;la chuleta&quot; para aplicarlo, vamos a ver un ejemplo muy sencillo a aplicar en un juego de naves. Nuestra nave parte de un arma base que puede modificarse, y también puede tener mini-naves a los lados que le ayuden. Si seguimos el primer paso del apartado anterior, lo primero que haremos será sacar a una interfaz los métodos públicos de nuestra clase. El segundo paso es crear un decorador base: Y finalmente, definimos los decoradores que necesitamos, En nuestro caso, tenemos la posibilidad de añadir misiles y lásers, además de mini-naves. Como podéis ver en este ejemplo, los decoradores no tienen por qué modificar siempre todos los métodos públicos: Ahora que tenemos los tres decoradores, pasemos a jugar con ellos para ver los resultados. Y listo, ya tenemos nuestro primer ejemplo de patrón Decorator listo para entregar. Desventajas Hay que tener mucho cuidado con el uso del objeto original, ya que si en algún momento lo hemos decorado, pero en otros sitios del código estamos usando el objeto sin decoración, puede provocar problemas y ser complejo de encontrar si no lo recordamos. Puede que se necesiten generar demasiados decoradores para unas clases, lo que nos generará muchísimas clases pequeñas, que si no están bien organizadas, serán difíciles de seguir. Si se necesitan llamadas a métodos públicos que no van a ser usados por decoradores, tocará implementar igualmente la llamada del decorador base. Por ejemplo, si en tu clase sólo necesitas decorar, 1 o 2 métodos, y tienes otros 10 métodos públicos para los que no es necesario, quizás debas de darle una vuelta al código. En algunos casos los decoradores deben tener un orden específico para usarse, si no provocarán otro tipo de resultados. Es por ello, que estos casos hay que documentarlos muy bien y dejar el mínimo margen de error. Es complejo poder quitar un decorador de la pila aplicada al objeto base. Por lo que o cada vez que haya que cambiar decoradores los aplicas de nuevo uno a uno, o debes implementar un sistema para poder quitar decoradores intermedios. Conclusiones El patrón Decorator, como todos los patrones, ofrece mucha potencia para ciertos casos, pero hay que tener cuidado con saber distinguirlos bien, puesto que como hemos visto en las desventajas, su uso libre en todas las ocasiones que lo sugieran puede complicar las cosas en lugar de hacerlas más sencillas. Es por ello, que te recomiendo que experimentes y analices bien cada situación que lo requiera. Eso sí, como habéis podido comprobar, es muy sencillo de llevar a cabo.",
    "imageMini": "/images/decorator-mini.webp"
  },
  {
    "slug": "20220715.html",
    "title": "AbortController: cancela operaciones en JavaScript",
    "description": "Hasta ahora, en JavaScript, cuando se lanzaba una llamada a una API con fetch, no resultaba sencillo detenerla. También se podía dar el caso de que quisiéramos detener varias operaciones que se ejecutaban de simultáneamente de forma centralizada, por lo que teníamos que implementar sistemas como el patrón observador.",
    "url": "/articles/posts/20220715.html",
    "date": "2022-07-15",
    "categories": [
      "programación",
      "JavaScript"
    ],
    "content": "Hasta ahora, en JavaScript, cuando se lanzaba una llamada a una API con fetch, no resultaba sencillo detenerla. También se podía dar el caso de que quisiéramos detener varias operaciones que se ejecutaban de simultáneamente de forma centralizada, por lo que teníamos que implementar sistemas como el patrón observador. Pero en la actualidad, estos flujos ahora son más fáciles gracias a la clase AbortController que viene a proporcionarnos una forma de enviar una señal de parada a todo elemento que lo utilice. Básicamente, tendremos una señal ( AbortSignal ) que se emitirá cuando queramos cancelar una operación. Veamos el uso más básico, y que está en miles de ejemplos: En el código anterior podemos ver como el uso de AbortController se reduce a obtener su señal, con signal , y a llamar al método abort() para lanzar la señal. Aunque es una herramienta muy potente, no hay mucho más que explicar... bueno sí, el 99,9% de los ejemplos que podéis encontrar, son como el que he puesto en las líneas anteriores, pero, ¿y si queréis usar la clase AbortController en algo que no sea un fetch? ¿Cómo se puede escuchar el cambio en la señal? Pues a continuación he preparado un código muy sencillito. En él podéis ver como hay tres contadores avanzando, lo que haremos es detenerlos mediante una señal: Lo que hemos hecho es definir una clase Timer a la que pasamos la señal de abortar la operación: En el constructor escuchamos el evento abort para dicha señal asociándolo con un event listener e indicando al código a ejecutar cuando llegue dicha señal. En nuestro caso el método #onAbort() : Podemos, además enviar una cadena para indicar la razón por la que hemos enviado la señal. Esta razón se recogerá en el atributo reason del evento. Como punto final, imaginad que tenéis varias llamadas simultáneas a un API porque es necesario solicitar datos en paralelo en vuestra aplicación. Ahora pongámonos en una situación en la que el usuario quiere cancelar la carga de datos en paralelo, por ejemplo, abrió una modal que hace varias llamadas y la cierra inmediatamente. Podemos detener de forma centralizada todas estas llamadas (al igual que hicimos con el ejemplo de los temporizadores): Como habéis podido comprobar, AbortController es una herramienta muy sencilla a la par que potente, y que nos puede dar muchos más usos de los que he comentado aquí. Como siempre, espero que este breve artículo os haya servido de ayuda.",
    "imageMini": "/images/abort-controller-mini.webp"
  },
  {
    "slug": "20220601.html",
    "title": "Aprendiendo a usar JavaScript Proxy",
    "description": "Los Proxies en JavaScript son, sin lugar a dudas, una característica poco utilizada en JavaScript. Al menos eso se desprende de la encuesta anual The State of JS.",
    "url": "/articles/posts/20220601.html",
    "date": "2022-06-01",
    "categories": [
      "programación",
      "JavaScript",
      "patrón proxy"
    ],
    "content": "Introducción Los Proxies en JavaScript son, sin lugar a dudas, una característica poco utilizada en JavaScript. Al menos eso se desprende de la encuesta anual The State of JS . La verdad es que es una herramienta muy potente, que en ocasiones nos puede ayudar a tener unas clases más sencillas, abstrayendo funcionalidad extra mediante lo que se conoce como manejador o interceptor. Su uso principal puede venir condicionado en el caso de que por cuestiones de diseño, queramos evitar el tener que definir clases para realizar operaciones muy específicas, es más, aunque no es exactamente lo mismo, nos puede servir como aproximación para aplicar una especie de decoradores, mientras éstos llegan realmente a JavaScript . ¿Y qué es lo que nos permite hacer un interceptor? Pues bien, con él podemos capturar el instante en que se va a guardar o leer un atributo, interceptar cuando se añade o elimina un atributo, etc. A los métodos que definiremos en nuestro interceptor y que estarán encargados de hacer esas capturas se les llama trap , ya que &quot;atrapan&quot; la llamada al objeto destino e interactúan con él. Primer ejemplo: interceptar una operación get Para no aburriros con tanta teoría, veamos un ejemplo práctico muy sencillo. Imaginad que cada persona conectada a nuestra aplicación puede consultar su contraseña en todo momento. Pero temporalmente, durante una actualización, queremos evitar que quien no tenga permisos administrativos pueda verla. Normalmente, este caso implicaría hacer cambios en nuestro código que podrían afectar a otras partes. Y además, luego tendríamos que quitar dichos cambios al terminar. Pues con este sencillo código podremos utilizar: Analicemos poco a poco el código anterior: El interceptor es un objeto que según los métodos que defina atrapará un momento de ejecución del código sobre el objeto sobre el que realizar el proxy. Cabe destacar, que se pueden usar clases, siendo este código de interceptor equivalente al que habéis visto en el ejemplo: El uso de Reflect, es por aportar robustez, ya que podríamos haber escrito return target[prop] , teniendo el mismo resultado. En otro artículo si queréis podemos comentar las ventajas de usar Reflect vs Object.- Para utilizar un Proxy, se crea una instancia de este a la que se le pasa el objeto para el que queremos atrapar sus operaciones, junto con el objeto del interceptor. La instancia que devuelve es la que deberemos utilizar.- A nivel de llamadas al interceptor podéis comprobar como entra en juego la condición que especificamos.- Finalmente, se pone como ejemplo, que en el momento de llamar al objeto original, no se tendrán en cuenta las reglas de interceptor. Esto es muy importante, puesto que si terminamos utilizando el objeto erróneo, perderemos ese control intermedio. Segundo ejemplo: interceptar una operación set Ahora veamos un ejemplo, de lo que podría ser el inicio de un mini-framework tipo React. En este caso queremos que cuando se cambie un atributo de la clase, ésta se vuelva a renderizar: Como hemos visto en el ejemplo anterior, interceptamos el momento en el que se intenta establecer el valor de un atributo. Y cuando el valor de este, es el mismo, se evita llamar a render de nuevo. Tercer ejemplo: definir propiedades &quot;virtuales&quot; En esta ocasión hemos aprovechado para añadir lógica extra como si existiera una propiedad llamada &quot;information&quot; en el objeto Car. De esta forma podemos llamar a dicha propiedad como si realmente estuviera definida. Algunos métodos trap útiles apply(obj, method, parameters) Este trap es un tanto especial pues sirve para interceptar llamadas a funciones. get(obj, prop) Se ejecuta en el momento en que se quiere leer un atributo de la clase. Como parámetros recibe el objeto interceptado, y el nombre del atributo. set(obj, prop, value) Intercepta el cambio de valores en los atributos de un objeto. Recibe como primer parámetro el objeto interceptado, como segundo parámetro el nombre del atributo y como tercer parámetro el valor a guardar. deleteProperty(obj, prop) Captura el instante en que se ejecuta el borrado de una propiedad del objeto, por ejemplo, delete myObject.myProperty . Recibe el objeto y el nombre de la propiedad. ownKeys(obj) Se ejecutará cuando se use Object.keys() , o por ejemplo lancemos un for...in . Recibe el objeto. has(obj, prop) En este caso, el método se ejecutará cuando llamemos a una sentencia in (menos el bucle for..in ). Por ejemplo &quot;property&quot; in myObject . defineProperty(obj, prop, descriptor) Llamado en el momento en que se declara una nueva propiedad para el objeto. Hay que tener en cuenta, que si hay un trap para set, no se llegará a llamar a este método. Cuando definamos la propiedad directamente, en ese caso sí se llamará cuando usamos el método defineProperties de Object. Si al código anterior le quitamos el trap de set, veríamos lo siguiente: construct(constructorType, parameters) Este trap permite captura el momento de instanciación de una clase, es ideal para simular decoradores sobre la misma.",
    "imageMini": "/images/javascript-proxy-mini.webp"
  },
  {
    "slug": "20220507.html",
    "title": "Opinión: modas en programación. El caso Hooks de React",
    "description": "En el artículo de hoy me salgo un poco de la costumbre, para reflejar una reflexión sobre un tema que he visto a lo largo de los años y que en mi modesta opinión no siempre mejora nuestro trabajo. Y son las \"malditas\" modas en el mundo de la programación. Cuántos proyectos han apostado por una moda temporal, y posteriormente han quedado varados en el olvido, intentando mantener la tecnología que describía esa moda como la panacea con esfuerzo, sudor y lágrimas.",
    "url": "/articles/posts/20220507.html",
    "date": "2022-05-07",
    "categories": [
      "Opinión"
    ],
    "content": "En el artículo de hoy me salgo un poco de la costumbre, para reflejar una reflexión sobre un tema que he visto a lo largo de los años y que en mi modesta opinión no siempre mejora nuestro trabajo. Y son las &quot;malditas&quot; modas en el mundo de la programación. Cuántos proyectos han apostado por una moda temporal, y posteriormente han quedado varados en el olvido, intentando mantener la tecnología que describía esa moda como la panacea con esfuerzo, sudor y lágrimas. Si atendemos a la evolución del desarrollo de software en estos últimos 40 años podemos comprobar como en un inicio se tenían programas que tras pasar de saltos incondicinales, comenzaron a definir funciones y procedimientos. Pasados los años se comprobó como los desarrollos al crecer en complejidad era difíciles de mantener y de mejorar. Es por ello que surgió la programación orientada a objetos. Esto trajo algo de estabilidad, pero mucha gente en lugar de formarse y ver como utilizar esta nueva herramienta, prefirió seguir programando &quot;a lo loco&quot;, llegando a los mismos problemas que se habían observado en la generación anterior. Recientemente, con la moda de los hooks en React, he visto que todo el mundo prácticamente te llamaban loco por usar los componentes de clase. Así que raudo y veloz, me he puesto a buscar información de por qué no se deben usar los componentes de clase. Ya que quería comprender qué estaba haciendo mal para poder mejorarlo. Y tras mucho navegar, (ahora es el momento de poner voz de Dross) estas son las siete razones por las que no hay que usar componentes de clase: La programación con clases es confusa para los humanos. La lógica de los métodos del ciclo de vida es difícil de entender. Complejidad con los tests. No hay que preocuparse con el bindeo de métodos y el uso de this. Es fácil compartir la lógica entre componentes. Una muy graciosa: no hay que perder el tiempo pasando de componentes funcionales a componentes de clase. El uso de super en el constructor es confuso. Vamos a ver pasito a pasito, cada punto. POO es confusa para los humanos Seamos sinceros, quien dice eso, es porque no se ha tomado la molestia de querer estudiar un mínimo como funciona la programación orientada a objetos. Es más compleja de interpretar para las máquinas, eso no lo niego, pero acerca mucho más el lenguaje de programación al lenguaje humano. Al final como todo en esta vida, no es que la POO sea la panacea, tiene sus inconvenientes. Pero veo muy vaga la escusa de que resulta confusa para los humanos. Es más, muchos de los ejemplos encontrados eran las famosas listas de tareas y que terminaban añadiendo complejidad innecesaria a los componentes de clase, sólo para terminar indicando que las clases quedan muy feas. Realmente, todos los hooks de proyectos reales ¿van a tener 1 o 2 líneas siempre? La lógica de los métodos del ciclo de vida es difícil de entender Pues mas o menos tenemos el mismo caso que el anterior. Es más, estos métodos de ciclo de vida ya tienen un nombre muy descriptivo que te indican en qué momento del ciclo de vida se van a ejecutar: componentDidMount , componentWillUnmount , etc. Es decir, sólo hay que usar el o los métodos que necesitamos e introducir el código dentro: En el ejemplo anterior, el método te dice en qué momento se va a ejecutar, y ni siquiera hay que aprendérselos de memoria, que para eso estamos en 2022 y tenemos IDEs modernos. En el segundo caso, debes recordar que el código antes del return actúa al montarse y repintarse el componente, y que luego debes devolver otra función que se ejecutará al desmontarse. Que sí, que es obvio que cuando lo hagas dos veces te acordarás, pero sinceramente ¿qué resulta más legible para un humano? Otros ejemplos que he visto ponían código duplicado en varios métodos del ciclo de vida, y luego ponían la versión comparada con el hook, y claro, me hacían pensar ¿por qué quien ha hecho el ejemplo no ha sacado ese código repetido a una función? El que usemos componentes de clase, no implica que todo lo que usemos sean métodos. Hay que utilizar todas las herramientas que nos proporcione el lenguaje, y el usar clases, no implica que las funciones estén prohibidas. Complejidad con los tests Entiendo que con esto se refieren a que un test de una función es más sencillo porque debería siempre devolver el mismo resultado. Pero si hacemos test de una clase (excepto en caso especiales), para un mismo orden de llamadas y unos mismos parámetros también terminará teniendo siempre un mismo resultado. Veamos el ejemplo más tonto del mundo: En el caso anterior, para los mismos paso, la clase también nos va a devolver los mismo resultados. Y sí, es obvio que en una clase muy grande, con muchos estados, se nos pueden ir de madre los tests. Pero en esos casos seguramente, hemos hecho mal y entre otras cosas nos hemos saltado los principios SOLID permitiendo que la clase crezca y tenga demasiado acoplamiento con otros componentes. No hay que preocuparse con el bindeo de métodos y el uso de this La &quot;problemática&quot; con el uso de this en JavaScript es algo que tiene el lenguaje desde sus inicios. Es más, todo desarrollador que se considere senior en JavaScript debería saber como funciona su ámbito de forma obligatoria. Pues bien, hace unos años no quedaba otra que hacer bind de métodos en JavaScript para no perder el contexto del this , de forma que teníamos código del estilo: Pero... ¿quién programa así en la actualidad? Ya que ahora tenemos las arrow functions, por lo que ya no es necesario tener atributos con el método &quot;bindeado&quot;: Hala, ya no tenemos problema con el bind. Es más fácil compartir la lógica entre componentes Bueno, si seguimos la guía de React, dice que no se use herencia entre componentes. Pero, ya os confirmo que he usado durante años la herencia entre componentes React y funciona perfectamente. Por lo que, cuando hay componentes que requieren usar lógica en común, en mi caso he optado por hacer que hereden de uno base con toda esa lógica común. Con este caso se solventaría el tener una lógica que sepamos que no se comparte entre componentes que no tienen nada que ver. En el caso de tener operaciones comunes más globales, podemos usar funciones que serán llamadas en nuestros componentes. Como podéis ver en este artículo no demonizo el uso de funciones, sino el que casi nos &quot;fuercen&quot; a usar hooks. Ya que en muchas ocasiones las funciones son más prácticas que las clases. Pero lo dicho, podemos tener funciones en un componente de clase, nadie nos lo impide, y es más, quizás esa función la estemos usando tanto en código React como en código no React. Con JavaScript la mezcla de paradigmas no debería ser un problema. No hay que perder el tiempo pasando de componentes funcionales a componentes de clase Aunque sean unas líneas más, todos los componentes que desarrollo siempre son clases. Por ende, si necesito métodos de ciclo de vida no tengo que cambiar el componente. Que sí, que el código es más grande, pero no estamos usando módems de los 90 y no vamos a programar un Horizon Zero Dawn con React. El que ocupe 10KB más un minificado, no va a ser el fin del mundo con las tecnologías actuales, y para eso en todo caso nos deberíamos centrar en las imágenes no escaladas aunque sean miniaturas, vídeos que no permiten cambiar el bitrate, etc. El uso de super en el constructor es confuso Llamar a la clase padre desde la hija es de primero de POO. Es decir, es algo lógico para quien programa con POO, y que se aprende enseguida. No entiendo por qué se define que usar algo estándar de POO es un problema, es como decir que declarar las funciones usando la palabra function , es confuso. Conclusión Tras mucho leer, no he visto razones de peso reales para tener que dejar atrás el uso de componentes de clase en React. Y es que ahora está de moda hacer todo de forma funcional, demonizando la programación orientada a objetos. Pero claro, lo primero es que la programación funcional que se suele indicar, no es funcional pura (no debería haber bucles, variables, etc). Pero por otro lado, la llamémosla programación funcional &quot;híbrida&quot;, y la programación orientada a objetos, pueden convivir y usarse según la situación. Ya que el verdadero potencial de un programador o una programadora es saber cuándo usar todas las herramientas de que dispone. Es por ello que cuando alguien indica que hay que utilizar una tecnología por encima de otra, nos debe dar razones de peso, y no escusas vagas. En este trabajo, no se aprende de la mañana a la noche, hay que explorar muchas vías, y estudiar mucho durante toda la vida. Es más, el objetivo de este trabajo es tener un código breve, pero que a su vez entendible por tus compañeros y compañeras, y que además sea fácil de mejorar y corregir si es así, escojas el camino que escojas, vas en el buen camino. Pero por otro lado tengo la sensación de que hay modas que se nos imponen, y con el paso de los años no dejarán de ser más que eso, modas.",
    "imageMini": "/images/react-hook-mini.webp"
  },
  {
    "slug": "20220414.html",
    "title": "Patrón observer",
    "description": "Para hablar del patrón Observer, antes deberíamos \"empezar por el principio\" (me encanta cuando la gente utiliza esa expresión redudante). En la teoría del software, los patrones de diseño nos ayudan a resolver los problemas más comunes a los que nos enfrentamos con una serie de soluciones a éstos. Podríamos hacer un poco de historia, pero no es el objetivo de este artículo contaros batallitas &#x1f61b;. De forma resumida, hace muchos años ya se conocían bastantes patrones pero dicho conocimiento estaba disperso, de forma que la conocida como \"Banda de los Cuatro\" (Erich Gamma, Richard Helm, Ralph Johnson y John Vlissides) decidieron escribir un libro que recogiera la definición de cada uno de los 23 patrones que se conocían en su momento. Dicho libro se llama Patrones de Diseño, por lo que es un buen punto de partida para quienes queráis ahondar más en este tema.",
    "url": "/articles/posts/20220414.html",
    "date": "2022-04-14",
    "categories": [
      "patrón observer",
      "diseño y arquitectura",
      "patrones de diseño",
      "programación"
    ],
    "content": "Para hablar del patrón Observer, antes deberíamos &quot;empezar por el principio&quot; (me encanta cuando la gente utiliza esa expresión redudante). En la teoría del software, los patrones de diseño nos ayudan a resolver los problemas más comunes a los que nos enfrentamos con una serie de soluciones a éstos. Podríamos hacer un poco de historia, pero no es el objetivo de este artículo contaros batallitas &#x1f61b;. De forma resumida, hace muchos años ya se conocían bastantes patrones pero dicho conocimiento estaba disperso, de forma que la conocida como &quot;Banda de los Cuatro&quot; (Erich Gamma, Richard Helm, Ralph Johnson y John Vlissides) decidieron escribir un libro que recogiera la definición de cada uno de los 23 patrones que se conocían en su momento. Dicho libro se llama Patrones de Diseño , por lo que es un buen punto de partida para quienes queráis ahondar más en este tema. Estos patrones se clasificaron en tres categorías: Patrones creacionales: como su nombre indica, permiten ayudar en la instanciación de clases. Patrones estructurales: estos patrones, permiten definir las relaciones entre clases y su composición. Patrones de comportamiento: definen como pueden interaccionar y comportarse las clases. En el artículo de hoy, aprenderemos en qué consiste el Patrón Observer, atendiendo primero a su definición estricta, y luego viendo un ejemplo del mundo real. Como siempre, cualquier duda, comentario o corrección que queráis hacer la podéis dejar en comentarios. Teoría del patrón Observer Si atendemos a la definición estricta. Este patrón: Define una dependencia uno a muchos entre objetos. De forma que cuando un objeto (subject) cambie de estado, este cambio se notificará a aquellos otros objetos (observers) que estén &quot;suscritos&quot; a él. En el diagrama superior podemos distinguir las siguientes clases: Subject : esta clase gestiona la suscripción de los observadores. Guardará la lista de objetos suscritos para poder notificarles cuando hay cambios. Observer : tendrá un método público al que los sujetos podrán llamar cuando le quieran notificar. ConcreteSubject : almacena un estado concreto para una serie de observadores. ConcreteObserver : se suscribe a un sujeto concreto y se encarga de actualizar su estado interno a partir del estado del sujeto, cuando éste último le notifique. La secuencia que seguiría el flujo original del patrón sería la siguiente: Tras tanto diagrama os explico un poco. Prácticamente lo que hacemos es que el observador se suscriba al sujeto. En el momento en que el sujeto cambia su estado (en la definición del patrón, este cambio lo hace el propio observador), éste notifica a todos los observadores para que puedan consultar el nuevo estado del sujeto. Un ejemplo práctico Voy a simplificar mucho el código en TypeScript para que veáis un ejemplo muy tontorrón quitando algunas clases, pero que creo que os puede ayudar a entenderlo mejor: Pues bien, una vez que hemos definido las dos clases simplonas, veamos que pasaría si ejecutamos algo de código para probarlo: Se puede ver como en cuanto realizamos un cambio de estado en el sujeto, este notifica a todos los observadores que se hayan suscrito. Así que, aunque hemos visto el patrón de forma muy simplificada, creo que os puede dar una pista de como es su funcionamiento. Un ejemplo del mundo real Si eres una persona nueva en el mundo de la programación, más exactamente si acabas de empezar con JavaScript, quizás no sepas que has estado usando el patrón observer de forma continua. Y lo has usado cuando has llamado al método addEventListener() . Para gente que lo desconozca, hacemos un breve inciso. En JavaScript podemos escuchar eventos que se lancen sobre un componente HTML, por ejemplo, podemos escuchar el evento &quot;click&quot; sobre un botón, de forma que cada vez que se haga clic en dicho botón, seamos notificados. Esto lo conseguimos con este tipo de llamadas: elementoHTML.addEventListener(&quot;tipoDeEvento&quot;, funcionALaQueNotificar); Y seguimos tras esta breve aclaración &#x1f609;. El sistema que se utiliza en JavaScript para ser notificados cuando ocurre un evento, podríamos decir que es una patrón Observer &quot;mutado&quot;, ya que tiene cuatro diferencias principalmente: Por un lado, la suscripción se realiza sobre un &quot;cambio&quot; concreto del sujeto, en lugar de realizar una suscripción general. En este caso te suscribes al evento para el que quieres ser notificado. Muchos de los patrones de diseño se pueden aplicar a funciones, por lo que no estamos limitados a utilizar siempre clases para utilizarlos. Precisamente este es un ejemplo del funcionamiento del patrón Observer con funciones, ya que al suscribirse se indicará la función que será llamada. La notificación también cambia, ya que en lugar de sólo avisar que hay un cambio por parte del sujeto, éste lo que hará es enviar directamente los datos involucrados en el cambio, con lo que la función que hemos usado como observadora, recibirá, en este caso, los datos del evento lanzado. Finalmente, el sujeto no notifica cambios en su estado. Es decir, que en el evento que recibimos, se incluyen los datos básicos del sujeto. Pero los datos del evento en sí, no son parte del estado del sujeto, sino una acción llevada a cabo sobre este. Un diagrama muy básico de como funciona sería el siguiente: Cosillas a tener en cuenta Hemos visto la definición estándar del patrón, así como una implementación del mundo real con algunos cambios. Precisamente, una de las cosas a tener en cuenta es que los patrones de diseño no son algo cerrado que debas seguir al 100%, ya que dependiendo del caso, puede que te interese hacer algunos ajustes. En el caso del patrón observer, hemos visto como se puede expandir con: suscripciones a datos en particular, notificaciones con datos en la llamada, suscripción de funciones en lugar de clases y que los observadores (las funciones en este caso), no están lanzando el cambio que provoca las notificaciones. Como conclusión podemos decir que los patrones son los planos con los que trabajar, pero no impide que podamos hacer correcciones a éstos para ajustarlos a nuestras necesidades. Otro de los puntos importantes en este patrón, es que los observadores no saben el coste de actualizar el sujeto, ya que no conocer al resto de observadores. Me explico: si cada observador trata la notificación de forma síncrona, cualquier observador que bloquee el hilo principal con algún proceso que lleve demasiado tiempo, dejará al resto en espera. De ahí que es ideal evitar el tener observadores bloqueantes sin vamos a trabajar en modo síncrono. Y bien, hasta aquí los datos básicos del patrón Observer, espero que os pueda ayudar cuando surja la necesidad de utilizarlo en vuestro proyectos. Y sin más, me despido hasta el próximo artículo.",
    "imageMini": "/images/patron-observer-mini.webp"
  },
  {
    "slug": "20220323.html",
    "title": "Optimiza tus transacciones con ACID",
    "description": "En el desarrollo de software definimos una transacción como un conjunto de pasos que deben ejecutarse de forma ordenada. El ejemplo más común en el que solemos pensar es en las transacciones de las bases de datos, pero se utilizan en muchos más ambitos, como por ejemplo: una transacción distribuida en micro-servicios, blockchains o incluso puede que debamos desarrollar un sistema de transacciones que hayamos creado de cero para nuestro proyecto.",
    "url": "/articles/posts/20220323.html",
    "date": "2022-03-23",
    "categories": [
      "programación",
      "diseño y arquitectura",
      "bases de datos",
      "transacciones",
      "ACID"
    ],
    "content": "En el desarrollo de software definimos una transacción como un conjunto de pasos que deben ejecutarse de forma ordenada. El ejemplo más común en el que solemos pensar es en las transacciones de las bases de datos, pero se utilizan en muchos más ambitos, como por ejemplo: una transacción distribuida en micro-servicios, blockchains o incluso puede que debamos desarrollar un sistema de transacciones que hayamos creado de cero para nuestro proyecto. Es por ello que si deseamos disponer de transacciones que operen de la forma más estable posible, lo ideal es que cumplan las características :strong[A]{.text-green-500}:strong[C]{.text-red-500}:strong[I]{.text-sky-700}:strong[D]{.text-yellow-500}. :strong[A]{.text-green-500}:span[tomicity] (atomicidad) La definición original sería la siguiente: Por cada paso en una secuencia de acciones realizada dentro de los límites de una transacción, ésta debe, o completarse correctamente, o en caso contrario todo el trabajo debería ser revertido. Martin Fowler ~ Patterns of Enterprise Application Architecture Esta característica, viene a indicar que sólo podemos dar una transacción como completada, cuando todos los pasos que la componen finalicen correctamente. Si hay un problema en cualquiera de los pasos, habrá que desechar todos los pasos realizados hasta ahora. :strong[C]{.text-red-500}:span[onsistency] (consistencia) Los recursos de un sistema deben permanecer en un estado consistente y no corrupto, tanto al principio como al final. Martin Fowler ~ Patterns of Enterprise Application Architecture Este principio, lo que nos viene a decir, es que no deberíamos tener datos que incongruentes o incorrectos en cualquier paso de la transacción. Cada paso, debe dejar el estado totalmente consistente. :strong[I]{.text-sky-700}:span[solation] (aislamiento) El resultado de una transacción no debe ser visible a otras transacciones abiertas hasta que no termine correctamente. Martin Fowler ~ Patterns of Enterprise Application Architecture Al aislar las transacciones hasta que finalicen, conseguiremos aumentar la consistencia de nuestro sistema. Ya que si no cumplimos esta norma, imaginad que hay un error en un paso de una transacción y otra accede en ese momento a los datos. La transacción que haya fallado, revertiría los cambios, con lo que la segunda transacción tendrá datos incorrectos. Es por ello que hasta que no termine la primera, la segunda no podrá acceder al resultado ni la información generada. :strong[D]{.text-yellow-500}:span[urability] (durabilidad) Cualquier resultado de una transacción que haya terminado correctamente debe ser permanente. Martin Fowler ~ Patterns of Enterprise Application Architecture Finalmente, con el último de los principios, lo que se viene a decir es que una vez que una transacción ha terminado, los datos deben quedan realizados de forma permanente, es decir, que para modificarlos, debe lanzarse otra transacción que opere con ellos, pero éstos no deben ser revertidos parcialmente si la transacción finalizó correctamente. Conclusión Si tienes que trabajar con transacciones, ya conoces los principios ACID, que se deberían cumplir para mantener un sistema lo más consistente y robusto posible. Todo esto ha sido extraído de un libro que es prácticamente de lectura obligada si queréis profundizar en la arquitectura del software. El autor es el gran maestro Martin Fowler , y el libro en cuestión es Patterns of Enterprise Application Architecture .",
    "imageMini": "/images/acid-mini.webp"
  },
  {
    "slug": "20220319.html",
    "title": "Curiosidades del objeto global console",
    "description": "Seguro que estás harto o harta de usar console.log, console.warn, etc, para ver mensajes por consola mientras desarrollas en JavaScript. Sin embargo, hay algunos métodos del objeto global `console` que quizás no conoces y pueden llegar a ser muy útiles. En este artículo vamos a ver algunos de los métodos más útiles.",
    "url": "/articles/posts/20220319.html",
    "date": "2022-03-19",
    "categories": [
      "programación",
      "JavaScript"
    ],
    "content": "Seguro que estás harto o harta de usar console.log, console.warn, etc, para ver mensajes por consola mientras desarrollas en JavaScript. Sin embargo, hay algunos métodos del objeto global console que quizás no conoces y pueden llegar a ser muy útiles. En este artículo vamos a ver algunos de los métodos más útiles. console.assert Uno de sus usos puede ser para controlados casos que sea muy raros que ocurran. Por ejemplo, tenemos una zona de código en la que pensemos que es imposible que llegue un array vacío. Y quizás el código falla en un punto difícil de depurar, pues si esperamos que siempre llegue un array con contenido, no nos cuesta dejar un assert en el código: console.clear El nombre ya lo dice todo. Al igual que el comando clear en Linux, o cls en Windows, borra el contenido de la consola. console.count Cada vez que se ejecuta incrementa un contador que muestra en la consola. Se puede indicar un nombre para el contador. Se puede reiniciar la cuenta con console.countReset() , indicando el nombre del contador en el caso de que se quiera resetear uno nombreado. console.dirxml Seguro que ya has mostrado el contenido de objetos por consola, ya sea con console.dir() o usando el objeto como argumento en los métodos log , info , etc. Pero ¿recuerdas que ocurre cuando lo haces por ejemplo con un elemento HTML? Sí, normalmente veremos el objeto que representa el nodo XML en sí, en lugar de la estructura. Así que con este fin existe dirxml : console.time Cuando quieras medir tiempos en tu aplicación, puedes jugar haciendo diferencias con objetos de tipo Date , pero hay una forma mucho más sencilla para hacerlo en JavaScript. Con time y timeEnd podremos ver el tiempo transcurrido entre las dos llamadas. Podemos llamarlo sin parámetros, o pasando un parámetro para darle un nombre el contador. console.group Puede que alguna vez hayas querido indentar los mensajes que muestras por consola. Para ello, en el objeto console tienes los métodos group y groupEnd . Con el primero incrementas un nivel la indentación y con el segundo lo quitas.",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20220311.html",
    "title": "Convertir una imagen en caracteres con JavaScript",
    "description": "Peleándome un poco con los canvas de JavaScript, estuve viendo que era posible extraer la información de color de cada pixel. Por lo que pensé ¿y si convierto esa información de color en un carácter? Pues dicho y hecho, en este artículo vamos a ver el código de un proyecto de ejemplo (del que podéis ver todo su código en Github), y que es capaz de transformar una fotografía en un conjunto de caracteres.",
    "url": "/articles/posts/20220311.html",
    "date": "2022-03-11",
    "categories": [
      "TypeScript",
      "programación"
    ],
    "content": "Peleándome un poco con los canvas de JavaScript, estuve viendo que era posible extraer la información de color de cada pixel. Por lo que pensé ¿y si convierto esa información de color en un carácter? Pues dicho y hecho, en este artículo vamos a ver el código de un proyecto de ejemplo (del que podéis ver todo su código en Github ), y que es capaz de transformar una fotografía en un conjunto de caracteres. Por ejemplo, gracias a él he podido convertir una foto con muchos años en la que salimos mi hermana y yo, en lo siguiente: Además, es posible escoger un conjunto personalizado de caracteres, así como el número de caracteres utilizado como ancho y como alto de la imagen convertida. Pero, dejo de enrollarme y pasamos a ver cómo funciona todo esto. Dentro del código El código está escrito en TypeScript, pero vamos, cualquier persona que sólo conozca JavaScript no creo que tenga problemas para entenderlo. Comenzaremos por la parte de más bajo nivel. Lo primero que necesitamos es una de las varias fórmulas que hay para convertir los colores RGB a un tono de gris, para ello tenemos la función siguiente: Esta función la utilizaremos en otra en la que obtendremos el tono de gris de un pixel en concreto dentro de un canvas: Seguimos subiendo otro nivel, y ahora lo que vamos a ver es la función que hace el trabajo de convertir todos los píxeles de un canvas a letras. Para ello incluyo comentarios en el código que os puedan ayudar a la comprensión: La función anterior es la que realiza todo el trabajo, y espero haber incluido comentarios descriptivos que os hayan podido ayudar a comprenderla. De todas formas, para cualquier duda podéis escribir en los comentarios. Para terminar tenemos otras tres funciones que se encargan de obtener el canvas que usaremos para pintar la imagen temporalmente antes de convertirla: Resumiendo, lo que hemos hecho primero es volcar una imagen cualquiera a un elemento canvas. Y dicho elemento lo hemos aprovechado para leer cada pixel y así convertirlo primero a un tono de gris, y de ahí, luego lo hemos convertido a un carácter. Como conjunto de caracteres base, la función usa los siguientes si no se define ninguno: Estos vendrán ordenados del que represente tonos más oscuros, a tonos más claros. De regalo... Como extra, parte del código anterior podría servirnos para hacer una copia en blanco y negro de una imagen. Para ello, podemos crear un canvas con las mismas dimensiones y por cada pixel podríamos hacer lo siguiente: En conclusión Espero que este código os haya servido como curiosidad, y estáis invitados a sugerir cualquier mejora, avisar de cualquier error, trastear con el código, probar vuestros propios ajustes de caracteres, etc. Y cualquier comentario siempre será bienvenido. ¡Hasta la próxima! &#x1f596;",
    "imageMini": "/images/ascii-mini.webp"
  },
  {
    "slug": "20220223.html",
    "title": "async y await: la magia del código asíncrono en JavaScript",
    "description": "Para terminar de hablar de promesas en JavaScript (al menos por una temporada), veremos la forma de olvidarnos de los callbacks y comenzar a programar usando `async` y `await`.",
    "url": "/articles/posts/20220223.html",
    "date": "2022-02-23",
    "categories": [
      "JavaScript",
      "asincronía",
      "programación"
    ],
    "content": "Para terminar de hablar de promesas en JavaScript (al menos por una temporada), veremos la forma de olvidarnos de los callbacks y comenzar a programar usando async y await . Durante la escritura de este artículo ningún callback ha sufrido daño alguno. Introducción Seguramente, habrás oído hablar del infierno de los callbacks. No, ahí no es donde van los callbacks que se portan mal, sino que con esa expresión hacemos referencia a las ejecuciones de código asíncronas en JavaScript, que se van enlazando mediante callbacks. Por desgracia es común encontrar aún código con este aspecto: En el fragmento anterior no he añadido mucho código; pero imaginad lo que se complicaría, si además de todos esos callbacks tuviéramos más código de por medio. Ese es uno de los motivos por los que podemos usar async...await . Otro motivo, por ejemplo, puede ser por claridad. En el caso de que no nos guste tener callbacks, ya sea definidos inline o como llamadas a funciones. Pero realmente, async...await es una herramienta que viene a ayudarnos en ciertos casos, y puede depender mucho de las preferencias de quién esté programando, el usarlos o no. Primer ejemplo Para comenzar veamos el código anterior traducido a async...await: Vale, &quot;nos has puesto dos ejemplos de código, y el segundo parece que queda más bonito, pero ¿qué hace?&quot;. Tranquilos y tranquilas que ya voy a la explicación &#x1f600;. ¿Qué hacen async y await? Cuando tenemos una promesa, en lugar de que tener que usar callbacks como hasta ahora, podemos utilizar la palabra clave await delante de la promesa. Esto hará que el código quede esperando a que termine la promesa, siempre se suele decir que permite tener código asíncrono, definido como código síncrono. Si la promesa se resuelve y además, lo hace con un valor, podremos asignarlo (como en las líneas 7, 8 y 9 del código anterior). Si la promesa es rechazada, se lanzará como excepción. De forma que tendremos que envolver la o las sentencias que usen await , con un bloque try...catch si queremos controlar las excepciones rechazadas. Puede que nos interese que estas excepciones se controlen en un bloque superior, por lo que no es obligatorio poner el try...catch junto al await . Pero eso sí, recuerda que si la promesa puede ser rechazada, en alguna parte del código deberías capturarla. Recapitulando, tenemos await que se espera a que termine una promesa, y los bloques try...catch para capturar las promesas rechazadas. Entonces, ¿para que sirve async ? Pues bien, await sólo se puede utilizar en funciones que haya declarado como asíncronas (obsérverse la primera línea del código anterior). Es decir, no se puede utilizar await fuera de una función que no sea asíncrona. Con todo lo anterior, ahora puedes volver a subir al código que usa async...await y revisarlo. Si me he explicado bien en los párrafos anteriores, ahora entenderás un poquito más el funcionamiento de éstas palabras. Detalle extra sobre las funciones asíncronas Así que prácticamente, eso sería todo, o al menos, eso es lo que suelen explicarse casi siempre. Pero aparte las funciones asíncronas tienen una peculiaridad más que mucha gente omite, y es que devuelven automáticamente una promesa. Con esto en mente, podemos esperar a que termine una función que ya es asíncrona sin tener que hacer código extra: Ahora sí, con esto terminamos nuestro repaso a las promesas en JavaScript. Como siempre, espero que os haya podido servir de ayuda, y cualquier pregunta que tengáis podéis dejarla en comentarios. Para ampliar algo de información sobre las promesas podéis recurrir a los siguientes libros: Understanding JavaScript Promises – Nicholas C. Zakas JavaScript with Promises: Managing Asynchronous Code – Daniel Parker Mastering JavaScript Promises – Muzzamil Hussain",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20220219.html",
    "title": "Repromise: Nueva librería para promesas JavaScript",
    "description": "¿Echas de menos los Deferred de jQuery cuando trabajas con promesas en JavaScript? Pues bien, acabo de publicar una utilidad con un código muy pequeño (32 líneas), con la que puedes trabajar con las promesas de JavaScript, tal y como lo hacías con los Deferred. La mini-librería se llama Repromise.",
    "url": "/articles/posts/20220219.html",
    "date": "2022-02-19",
    "categories": [
      "JavaScript",
      "promesas",
      "asincronía"
    ],
    "content": "¿Echas de menos los Deferred de jQuery cuando trabajas con promesas en JavaScript? Pues bien, acabo de publicar una utilidad con un código muy pequeño (32 líneas), con la que puedes trabajar con las promesas de JavaScript, tal y como lo hacías con los Deferred. La mini-librería se llama Repromise . Me explico. Su funcionamiento es muy básico. Si hasta ahora al construir las promesas de JavaScript, tenías que definir un callback, con el que recibir los métodos a los que llamar al resolver y rechazar la promesa. Pongamos un ejemplo de como sería un código más o menos realista con promesas: Como podéis ver, la indentación se va incrementando haciendo poco legible el código. Con Repromise, creas una instancia de la clase, y cuando quieras resolver la promesa o rechazarla llamas al método correspondiente. Basándonos en el ejemplo anterior: Como podéis ver, simplifica un poco el código, evitando que tengamos un método en medio, y además, podemos pasar nuestro objeto Repromise a otros métodos para que sean éstos los que hagan las llamadas, así podemos simplificar aún más el método original: Con el modo antiguo, no quedaba otra que pasar los dos parámetros, o crear un nuevo objeto uniendo ambos para pasarlos a otras funciones. Para utilizar la librería tan sólo hay que importarla en vuestro proyecto con npm :",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20220209.html",
    "title": "Métodos del objeto Promise en JavaScript",
    "description": "Como hasta ahora no hemos hablado de promesas en este blog, vamos a comenzar haciendo una pequeña introducción a la breve pero apasionante historia de las promesas en JavaScript, para a continuación ver los distintos métodos para trabajar con promesas.",
    "url": "/articles/posts/20220209.html",
    "date": "2022-02-09",
    "categories": [
      "JavaScript",
      "asincronía",
      "programación"
    ],
    "content": "“Había permanecido en la sombra, esperando, sin prisa, a que alguna fuerza lo trajese de nuevo al mundo de los vivos. Y nada tiene tanta fuerza como una promesa…” Carlos Ruiz Zafón - El Príncipe de la Niebla Como hasta ahora no hemos hablado de promesas en este blog, vamos a comenzar haciendo una pequeña introducción a la breve pero apasionante historia de las promesas en JavaScript, para a continuación ver los distintos métodos para trabajar con promesas. En caso de que os interese el tema, principalmente el caso de async...await que puede llegar a ser confuso en algunos ámbitos, podéis escribir en comentarios las dudas, y puedo preparar un artículo para ampliarlas. Introducción En un principio, al trabajar con JavaScript, cuando nos encontrábamos con un código que se debía ejecutar de forma asíncrona se utilizaban callbacks para controlar cuando había terminado la ejecución del código asíncrono. Pondremos en los siguientes ejemplos, el mismo código evolucionando: Con el paso del tiempo, la librería jQuery comenzó a usar lo que llamaban deferreds , un sistema con el que la gestión de las llamadas asíncronas pasa a ser un poco más descriptiva. Para ello se tenía un objeto al que se podían ir enlazando callbacks por cada resultado de la operación asíncrona. Con este esquema se paso a tener una estructura muy similar cuando llegaron las promesas al propio JavaScript: Cabe destacar que también existe la estructura then() con dos parámetros, en la que el primero funcionaría como callback cuando la promesa termina correctamente, y el segundo, cuando termina de forma errónea. La siguiente evolución en JavaScript fue la llegada de async...await . Esta estructura ayuda a &quot;leer&quot; el código asíncrono como si fuera síncrono: Métodos del objeto Promise resolve() y reject() Estos dos métodos son los más sencillos de utilizar y permiten generar una promesa resuelta (con resolve) o una promesa rechazada con (reject). any() Este método puede recibir varias promesas, y terminará en cuanto la primera de ellas se cumpla. El resto de promesas serán &quot;omitidas&quot;. race() En esta ocasión, el método terminará en cuanto una promesa se cumpla o finalice erróneamente. Como resumen de los métodos any() y race() . Tenemos que, con any esperamos a que al menos una promesa termine bien, y si ninguna termina correctamente el flujo finalizará con la última promesa. Con race , sin embargo, el código se espera a que la promesa más rápida termine, ya sea correcta o erróneamente. all() Se resuelve cuando terminan todas las promesas correctamente. En caso de que una de ellas falle, la promesa generada por all() será rechazada. allSettled() El último de los métodos de Promise, lo que hará es terminar cuando hayan acabado todas las promesas que recibe, ya sea correcta, o erróneamente. Para ello, el resultado será un array con las promesas. Resumen Método Explicación resolve Genera una promesa resuelta automáticamente. reject Genera una promesa rechazada automáticamente. any Genera una promesa que se finaliza en cuanto termina correctamente una de las que recibe. race Genera una promesa que finaliza en cuanto termina una de las promesas que recibe, ya sea correcta o erróneamente. all Espera a que terminen todas las promesas. Si falla una de ellas, la promesa será rechaza. allSettled Espera a que terminen todas las promesas, independientemente de si terminan correctamente o fallan. Para ampliar algo de información sobre las promesas podéis recurrir a los siguientes libros: Understanding JavaScript Promises – Nicholas C. Zakas JavaScript with Promises: Managing Asynchronous Code – Daniel Parker Mastering JavaScript Promises – Muzzamil Hussain",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20220205.html",
    "title": "Clases vs Clases abstractas vs Interfaces",
    "description": "En el artículo de hoy vamos a intentar resolver una duda bastante habitual: ¿cuándo usar clases base, cuándo clases abstractas y cuándo interfaces? Repasaremos qué es cada una y en qué situaciones resulta más recomendable utilizarlas.",
    "url": "/articles/posts/20220205.html",
    "date": "2022-02-05",
    "categories": [
      "diseño y arquitectura",
      "programación orientada a objetos",
      "POO",
      "programación"
    ],
    "content": "En el artículo de hoy vamos a intentar resolver una duda bastante habitual: ¿cuándo usar clases base, cuándo clases abstractas y cuándo interfaces? Repasaremos qué es cada una y en qué situaciones resulta más recomendable utilizarlas. Clase Heredaremos de una clase base, cuando tengamos otras clases que resulten en una especialización de la primera y no haya ninguna obligación de implementar métodos de la clase madre. Suele ser el caso más habitual de herencia. Por ejemplo, si tenemos una clase base con una serie de comportamientos ya predefinidos para todas las clases derivadas, cada clase hija puede sobrescribir únicamente las partes que necesite. En el ejemplo superior, tenemos una clase de la que heredan otras dos. La primera no necesita sobrescribir ningún método, mientras que la segunda redefine el comportamiento de saltar() . Es decir, una clase base no obliga a implementar o, mejor dicho en este caso, sobrescribir ninguno de sus métodos. Clase abstracta Una clase abstracta es aquella en la que alguno de sus métodos es abstracto. A primera vista puede parecer una obviedad, pero conviene matizar el concepto. Un método abstracto dentro de una clase es aquel que no tiene &quot;contenido&quot; o cuerpo. Esto obliga a que todas las clases que hereden de una clase abstracta implementen esos métodos, salvo que también se declaren como abstractas. Veamos un ejemplo con nuestro amigo Super Mario de nuevo. Imaginad que tenemos esta clase abstracta: Como se puede comprobar, tenemos un método mover() , que ya tendría una serie de lógica por defecto. Las clases hijas no tendrían por qué sobrescribir dicho método. Sin embargo, el método atacar() es abstracto, no tiene cuerpo; es por ello que se obliga a toda clase hija (que no sea abstracta) a tener que implementarlo: Por lo que podríamos decir que usaremos las clases abstractas cuando tengamos la necesidad de proporcionar una lógica común a las clases hijas, pero existan operaciones que queramos que cada clase hija deba implementar por su cuenta. Interfaz En el caso de las interfaces, podríamos pensar que son clases abstractas puras, es decir, clases con todos los métodos abstractos (y además con visibilidad pública). Es más, en el caso de lenguajes como C++, al no haber interfaces, éstas pasarían a definirse con clases abstractas puras. Las interfaces a nivel semántico no requieren tener obligatoriamente relación alguna con las clases, simplemente permiten definir comportamientos comunes sin imponer una jerarquía de herencia. Eso sí, las clases que implementan las interfaces están obligadas a implementar todos sus métodos. Veamos un ejemplo: 🗒️ NOTA En TypeScript, las interfaces pueden definir la forma de los datos , no solo comportamiento. Resumen Una vez vistos los conceptos, la siguiente tabla resume las principales diferencias entre clases, clases abstractas e interfaces: Característica Clase Clase abstracta Interfaz ¿Puede tener implementación? Sí Sí No ¿Puede tener métodos abstractos? No Sí Sí (todos) ¿Obliga a implementar métodos? No Sí (los abstractos) Sí (todos) ¿Herencia múltiple? No No Sí Uso principal recomendado Reutilizar comportamiento Mezclar comportamiento común y obligación Definir contratos o capacidades 🗒️ NOTA También puedes ver un resumen en Instagram . Bibliografía Aquí tenéis algunos libros sobre programación orientada a objetos con los que aprender más: Introducción a Programación Orientada a Objetos - Yolanda Blanco Fernández Object Oriented Programming in C++ - Richard Baker Practical Object-Oriented Design - Metz Sandi",
    "imageMini": "/images/uml-mini.png"
  },
  {
    "slug": "20220203.html",
    "title": "5 cosas que haces mal en JavaScript",
    "description": "JavaScript en ocasiones añade el \";\" de forma explicita cuando hay un salto de línea. Si no tenemos cuidado con esto, puede haber comportamientos no esperados en nuestra aplicación. Es por ello que se aconseja evitar, tanto partir líneas en algunos casos, como abrir las llaves en la línea siguiente. En el siguiente ejemplo podéis ver lo que ocurre:",
    "url": "/articles/posts/20220203.html",
    "date": "2022-02-03",
    "categories": [
      "JavaScript",
      "programación"
    ],
    "content": "1. Añadir saltos de línea donde no corresponde JavaScript en ocasiones añade el &quot;;&quot; de forma explicita cuando hay un salto de línea. Si no tenemos cuidado con esto, puede haber comportamientos no esperados en nuestra aplicación. Es por ello que se aconseja evitar, tanto partir líneas en algunos casos, como abrir las llaves en la línea siguiente. En el siguiente ejemplo podéis ver lo que ocurre: Como se puede ver en el ejemplo tenemos dos funciones que, en primera instancia, parece que debieran devolver una cadena anteponiendo el texto &quot;Hola &quot;. En realidad en la primera función obtendremos undefined . Esto es, porque JavaScript aplica una regla llamada Automatic Semicolon Insertion (ASI), que en ciertos contextos inserta un ; implícitamente. 2. Usar siempre los bucles for tradicionales con arrays Siempre que puedas, comienza a utilizar los bucles for...of (con aquellos elementos que sean iterables) o el método forEach en los arrays, ya que ofrecen una mejora en la legibilidad. En el siguiente código puedes ver un ejemplo sencillo de los tres bucles. Con for , debemos declarar el índice e indicar su incremento. Esto implica que para acceder a cada elemento necesitamos usar la nomenclatura nombreArray[indice] . Con for..of obtenemos el elemento de cada posición sin usar un contador. Además podemos usar break y continue para controlar el flujo del recorrido. En el caso de necesitar un índice, si que tendremos que llevar un control manual. Con forEach el recorrido del bucle será completo. Por lo que si tienes que interrumpir el recorrido es mejor la otra opción. El segundo parámetro del callback es la posición, así que podremos usarla sin llevar un control manual como en for..of . 3. Usar == y !=, en lugar de === y !== Seguramente, esta te sonará. Y es que, a no ser que partas de un lenguaje tipado como TypeScript, el operadores de igualdad/desigualdad y no de identidad puede dar algún quebradero de cabeza. El uso de los operadores == y != compara el valor de cada variable y realiza un casting a otro tipo de dato si fuera necesario. Por el contrario, los operadores de identidad ( === y !== ) aparte del valor, verifican que el tipo de dato sea el mismo. 4. Seguir usando funciones para definir las clases A no ser que tengas que hacer desarrollos para un navegador como IE (por tu bienestar mental, espero que no sea así). Deberías comenzar a usar la definición nativa de clases en JavaScript. La nueva sintaxis de JavaScript para definición de clases te proporciona un estilo mucho más próximo a lo que puedes ver en otros lenguajes de programación, así que olvídate de manipular directamente prototype , salvo que tengas un motivo muy concreto. Las clases no cambian el modelo de herencia, solo lo hacen más legible. Puedes aprender más sobre esta sintaxis de JavaScript en la serie de artículos Orientación a objetos con JavaScript . 5. Usar var en lugar de let y const ¿Aún defines tus variables con var aunque nunca vayan a cambiar su valor? Pues bien, puedes usar let y const para evitar los problemas de hoisting ; que se modifique lo que pensabas que era una constante; o, que pienses que una variable se encontraba en un ámbito acotado y es global. Al usar let o const , evitarás que las variables y constantes puedan usarse antes de su declaración. Puedes ver más información sobre las diferencias entre let y var en este artículo .",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20220131.html",
    "title": "Principios SOLID. Capítulo D: Dependency Inversion Principle",
    "description": "Terminamos los principios SOLID con el Principio de Inversión de Dependencias, que viene a decir:",
    "url": "/articles/posts/20220131.html",
    "date": "2022-01-31",
    "categories": [
      "programación",
      "diseño y arquitectura",
      "SOLID"
    ],
    "content": "Terminamos los principios SOLID con el Principio de Inversión de Dependencias, que viene a decir: Los módulos de alto nivel no deberían depender de los módulos de bajo nivel. Ambos deberían depender de abstracciones. Las abstracciones no deberían depender de los detalles. Los detalles deben depender de abstracciones. Robert C. Martin ~ The Dependency Inversion Principle Aunque parezca un trabalenguas, lo que viene a decir el tío Bob en esta ocasión es que las clases que utilizan otras no deberían depender de como funcionen. Estas a su vez, tendrán interfaces genéricas que no hagan depender a la clase de alto nivel de cada una. Pero como siempre veamos todo con un ejemplo. Imaginad una clase para compartir datos que en su inicio sólo sirva para compartir por Bluetooth: ¿Qué pasa si queremos el día de mañana compartir por email, por ftp, etc? ¿Tener un atributo de cada tipo? ¿Consultar de forma externa añadiendo una dependencia no necesaria? Pues justo, con esto nos va a ayudar la inversión de dependencias. Lo primero que haríamos es crear una interfaz a la que poder llamar de una forma genérica: El siguiente paso será pasar a nuestra clase la interfaz como parámetro, de forma que nuestra clase o (en la cita del principio, módulo de alto nivel) deja de depender de la clase que utiliza (módulo de bajo nivel). Así que recibirá la implementación específica de la interfaz que necesite en cada momento, sin tener que cambiar su contenido: Pero... seguramente cada tipo de conexión no requiera exactamente los mismos datos, pues bien aquí entra en juego un segundo componente en juego, que serían los adaptadores (patrón adapter). Estos harían de interfaz entre cada tipo de conexión y la interfaz que tenemos, haciendo que &quot;la abstracción no dependa de los detalles&quot;. Y es que imaginad para este caso que con cada tipo de conexión (bluetooth, email, etc), usamos librerías. Cada librería tendrá una API distinta, y diferentes formas de poder enviar datos. Pues bien, crearemos un adaptador por cada una para que se pueden comunicar con nuestro sistema con la misma interfaz. Por ejemplo, en el caso de la conexión Bluetooth: Esto quedaría con un esquema del tipo: ¿Y al final en qué se traduce todo esto? Pues que en nuestro ejemplo, hemos hecho que la clase ShareAction, al recibir sus dependencias del exterior deje de depender de la implementación de dichas clases. Permitiéndonos poder cambiar de un tipo de conexión a otra sin que ShareAction se vea modificada. Si el día de mañana se añade otro tipo de conexión, sólo hay que pasar en el constructor la referencia al nuevo adaptador y listo. Por otro lado, no necesitamos las clases &quot;reales&quot; para testear, podemos usar mocks que pasaremos a la clase ShareAction, de forma que si hay un fallo en un test sabremos que es de la clase ShareAction y no de la dependencia que le hemos pasamdo. Finalmente, cabe aclarar que la inyección de dependencias no es lo mismo que la inversión de dependencias. La primera es una herramienta con la que conseguir la segunda. Podéis ver un resumen de todo lo que hemos visto en este artículo en este post de Instagram . Conclusiones Con este artículo hemos terminado de ver los principios SOLID. Quiero aclarar una cosilla para terminar, aunque los principios ofrecen ideas muy buenas, no siempre tienen que aplicarse desde el comienzo, sobre todo si no se sabe como evolucionará el proyecto; sino que se pueden aplicar cuando llegue el momento. Si tenemos una buena cobertura de test, refactorizar el código para adaptar algún principio no debería ser problema. Y es que en mi experiencia hay algunos casos que nunca cambian en la vida de un proyecto, por lo que aplicar desde el inicio estos principios puede resultar en una sobre-ingeniería que puede complicar de más el proyecto innecesariamente. Al final son herramientas que hay que saber cuando es el momento oportuno de usarlas, y eso se consigue con práctica y experiencia. Espero que os haya gustado esta serie de artículos y ¡nos vemos en el próximo! Más artículos de esta serie :strong[Capítulo S]{.text-red-500}: Single Responsibility Principle o Principio de responsabilidad única :strong[Capítulo O]{.text-orange-500}: Open-Closed Principle o Principio abierto/cerrado :strong[Capítulo L]{.text-green-500}: Liskov Substitution Principle o Principio de sustitución de Liskov :strong[Capítulo I]{.text-pink-500}: Interface Segregation Principle o Principio de segregación de interfaces Si quieres leer algo más de Robert C. Martin, aparte de su web , tiene varios libros interesantes: La Artesanía del Código Limpio Código Limpio Clean Architecture",
    "imageMini": "/images/solid-logo-mini.webp"
  },
  {
    "slug": "20220124.html",
    "title": "Principios SOLID. Capítulo I: Interface-Segregation Principle",
    "description": "Si en el capítulo anterior vimos como una mala herencia puede provocar que haya clases con métodos que no deberían implementar, para este cuarto principio tenemos un ejemplo muy parecido, pero con el caso de las interfaces.",
    "url": "/articles/posts/20220124.html",
    "date": "2022-01-24",
    "categories": [
      "programación",
      "diseño y arquitectura",
      "SOLID"
    ],
    "content": "Si en el capítulo anterior vimos como una mala herencia puede provocar que haya clases con métodos que no deberían implementar, para este cuarto principio tenemos un ejemplo muy parecido, pero con el caso de las interfaces. Su nacimiento se remonta a los tiempos en los que Robert C. Martin trabajaba en la empresa Xerox. Dicha empresa había creado un software que llevaba a cabo la mayor parte de tareas que puede llevar a cabo un sistema de impresión. El problema es que había una sola clase que hacía todo el trabajo, algo que ya también incumplía varios de los principios que hemos visto (como el Principio de Responsabilidad Única). Pues bien, tras ver como cada cambio implicaba cada un mayor tiempo de desarrollo, se optó por crear varias interfaces que acotaran las tareas: grapado, envío de fax, impresión, etc. Y de ahí salió la definición del Principio de Segregación de Interfaces: Los clientes no deberían estar forzados a depender de interfaces que no van a usar. Robert C. Martin ~ The Interface Segregation Principle Y como siempre, vamos a intentar definir de una forma más &quot;mundana&quot; este principio. En este caso, lo que viene a decir, es que las clases no deberían implementar métodos de interfaces que no van a usar; algo muy parecido al problema que provocaba el que tuviéramos que usar el Principio de Sustitución de Liskov, pero aplicado a relaciones con interfaces, en lugar de con herencia de clases. En nuestro ejemplo, partiremos de un ejemplo videojueguil que casi todo el mundo conoceréis. En Super Mario tenemos entre otros estos enemigos: Enemigo Descripción Goombas Son los champiñones que sólo avanzan. Koopa Troopa Las tortugas que al saltar sobre ellas se esconden. Koopa Paratroopa Tortugas con alas que van dando saltos, también al saltar sobre ellas se esconden. Hermanos Martillo Con forma de tortuga. Lanzan martillos y dan saltos Vale, pues imaginad que tenemos esta interfaz para los enemigos: Si usamos esa interfaz con todos los personajes tendríamos un problema, ya que el código quedaría tal que así: Como se puede apreciar, hay una interfaz que obliga a las clases (los clientes según el término de este principio) a implementar métodos que no tiene sentido que usen. Esto a la larga dará muchos quebraderos de cabeza, tal y como se vio con el principio anterior. ¿Cómo se podría solventar este problema? Pues creando interfaces más específicas que obliguen a desglosar las tareas (o en este caso acciones) a realizar por las clases: Como anotación importante, en nuestro ejemplo quedan tres interfaces, cada una con un método, esto no significa que en todos los casos se tengan mini interfaces &quot;uni-metodales&quot;, sino que dependerá del caso. Tras la aclaración anterior, ahora nuestros enemigos quedarían con esta definición: Ahora las clases sólo implementan lo que necesitan, evitando en este caso añadir métodos vacíos, que devuelvan valores &quot;sin sentido&quot;, o que lancen excepciones. Aparte se han dejado mejor agrupadas las acciones u operaciones a las que representa cada interfaz, dando algo más de semántica al código. Como extra seguramente se podría añadir una clase base que implemente la interfaz IEnemigo, ya que todas las clases tienen un avanzar que en el ejemplo de este artículo, hace prácticamente lo mismo, pero tampoco era el objetivo salir de la explicación del principio en sí, y así os lo podía comentar mejor. Pues básicamente este es el Principio de Segregación de Interfaces. En el próximo artículo terminaremos la serie de principios SOLID. Ya sabéis que podéis encontrar un resumen de este principio en Instagram . Más artículos de esta serie :strong[Capítulo S]{.text-red-500}: Single Responsibility Principle o Principio de responsabilidad única :strong[Capítulo O]{.text-orange-500}: Open-Closed Principle o Principio abierto/cerrado :strong[Capítulo L]{.text-green-500}: Liskov Substitution Principle o Principio de sustitución de Liskov :strong[Capítulo D]{.text-violet-500}: Dependency Inversion Principle o Principio de inversión de dependencias Si quieres leer algo más de Robert C. Martin, aparte de su web , tiene varios libros interesantes: La Artesanía del Código Limpio Código Limpio Clean Architecture",
    "imageMini": "/images/solid-logo-mini.webp"
  },
  {
    "slug": "20220121.html",
    "title": "Principios SOLID. Capítulo L: Liskov Substitution Principle",
    "description": "En el capítulo :strong[L]{.text-green-500}, hablaremos del Principio de Sustitución de Liskov, una idea formulada por Barbara Liskov y Jeannette M. Wing, en su artículo A Behavioral Notion of Subtyping de 1994. Si quieres entender cómo formalizar los conceptos abstractos que manejamos, te recomiendo que lo leas.",
    "url": "/articles/posts/20220121.html",
    "date": "2022-01-21",
    "categories": [
      "diseño y arquitectura",
      "programación",
      "SOLID"
    ],
    "content": "En el capítulo :strong[L]{.text-green-500}, hablaremos del Principio de Sustitución de Liskov, una idea formulada por Barbara Liskov y Jeannette M. Wing , en su artículo A Behavioral Notion of Subtyping de 1994. Si quieres entender cómo formalizar los conceptos abstractos que manejamos, te recomiendo que lo leas. Este principio está escrito con varias fórmulas que no entraremos a detallar, pero que de forma resumida dirían lo siguiente: Dado un conjunto de clases que heredan de otra. Todas las clases hijas pueden ser sustituidas por la clase madre, y viceversa, sin requerir de cambios en el código que las usa. En otras palabras, cualquier clase o sus subclases en una relación de herencia deberían ser intercambiables sin afectar la funcionalidad de la aplicación. La violación del principio de sustitución de Liskov se puede detectar cuando las clases hijas contienen métodos vacíos, devuelven valores sin sentido o lanzan excepciones que indican que no están implementados. Para entender mejor este principio, consideremos el ejemplo de una clase Vehículo que tiene las operaciones acelerar() y volar() . Si queremos usar estas operaciones en una función despegar() , deberíamos ser capaces de hacerlo con cualquier objeto de tipo Vehículo o sus subtipos, sin importar la clase específica del objeto. En el código anterior, podemos observar que si se recibe un objeto de tipo Coche en la función despegar() , se producirá una excepción y se romperá el flujo de ejecución. Esto significa que tendríamos que cambiar el código de despegar() para adaptarlo al comportamiento particular de la clase hija. Sin embargo, este enfoque viola el principio de sustitución de Liskov, que es fundamental para mantener la flexibilidad y la extensibilidad del código. Es más, no solo estamos incumpliendo dicho principio, sino que también estamos violando el principio Abierto/Cerrado , que establece que un módulo debe estar abierto para su extensión pero cerrado para su modificación. Para resolver este problema, debemos buscar un comportamiento común para todas las clases que se utilizan en la función despegar() . En el ejemplo dado, podemos crear una nueva clase hija llamada VehículoVolador que extienda de la clase Vehículo y que implemente el método volar() . De esta manera, podemos mantener la funcionalidad común en la clase Vehículo y agregar el comportamiento específico en las clases hijas. Ahora al añadir clases como: Dron, Aeroplano, Helicóptero, etc. Si hacemos que todas ellas hereden de VehículoVolador , ya no será necesario modificar el código de la función despegar() . Con esto terminamos el tercero de los principios SOLID, en el capítulo siguiente pasaremos a ver el Principio de Segregación de Interfaces. Y si queréis un resumen de todo esto, podéis verlo en Instagram . Más artículos de esta serie :strong[Capítulo S]{.text-red-500}: Single Responsibility Principle o Principio de responsabilidad única :strong[Capítulo O]{.text-orange-500}: Open-Closed Principle o Principio abierto/cerrado :strong[Capítulo I]{.text-pink-500}: Interface Segregation Principle o Principio de segregación de interfaces :strong[Capítulo D]{.text-violet-500}: Dependency Inversion Principle o Principio de inversión de dependencias Si quieres leer algo más de Barbara Liskov, tiene un libro muy completo para aquellas personas que programan en Java: Program Development in Java: Abstraction, Specification, and Object-Oriented Design .",
    "imageMini": "/images/solid-logo-mini.webp"
  },
  {
    "slug": "20220115.html",
    "title": "Principios SOLID. Capítulo O: Open/Closed Principle",
    "description": "En esta segunda parte de los principio SOLID, vamos a ver el llamado principio abierto/cerrado (open/closed).",
    "url": "/articles/posts/20220115.html",
    "date": "2022-01-15",
    "categories": [
      "programación",
      "diseño y arquitectura",
      "SOLID"
    ],
    "content": "En esta segunda parte de los principio SOLID, vamos a ver el llamado principio abierto/cerrado (open/closed). Introducción Este principio fue formulado por uno de los grandes Bertrand Meyer , en su libro Object-Oriented Software Construction . Si nos vamos a la definición que hay dada sería: Las entidades de software (clases, módulos, funciones, etc.) deben estar abiertas para su extensión, pero cerradas para su modificación. Bertrand Meyer Cuando un cambio en una aplicación provoca cambios en cascada en múltiples módulos interdependientes que no deberían ser modificados, esto indica un problema de diseño en el programa. Este acoplamiento excesivo hace que cada cambio sea una tarea difícil y compleja, especialmente en proyectos grandes. El principio &quot;Open/Closed&quot; nos insta a desarrollar elementos de software que realicen su función sin la necesidad de modificaciones en el futuro. Al seguir este principio, podemos evitar modificar código que funciona correctamente y evitar la introducción de errores innecesarios. La implementación de este principio requiere una planificación cuidadosa y una arquitectura adecuada para asegurar que los elementos de software estén diseñados para ser extensibles sin necesidad de ser modificados. De esta manera, podemos reducir la complejidad del código y mejorar la capacidad de mantenimiento y extensibilidad del software. Ejemplo Comencemos con el siguiente código en TypeScript. Aunque los conceptos son genéricos, aquellos familiarizados con lenguajes como Java, C++, o C# encontrarán la sintaxis similar. En este ejemplo, tenemos un controlador de dispositivos inteligentes capaz de ejecutar los comandos de encendido y apagado de dispositivos. En un mundo ideal, hasta el momento, ha funcionado correctamente con todos los dispositivos probados: Pero llega un aciago día en el que nos toca controlar un nuevo tipo de dispositivo inteligente, por ejemplo una estufa. Y en este caso, para apagarla, primero es necesario ponerla en modo suspensión. Debido a esta nueva funcionalidad, es necesario realizar un cambio en nuestro código anterior: En este caso, hemos tenido que modificar el código debido a un único caso adicional, lo cual va en contra del principio de diseño que estamos tratando de seguir. De acuerdo con éste, debemos evitar realizar modificaciones en el código existente. En su lugar, debemos asegurarnos de que nuestras clases estén abiertas para su extensión. Es por ello, que para resolver este problema podemos hacer uso de la herencia. En lugar de modificar la clase existente, crearemos una clase que herede de Device y extienda su funcionalidad para manejar la estufa: De esta manera, cumplimos con el principio abierto/cerrado. La clase original permanece intacta y cerrada para su modificación, mientras que hemos creado una nueva clase que extiende su funcionalidad y está abierta para su extensión. Esto nos ha permitido modificar código que ya funcionaba correctamente y había sido probado exhaustivamente. Imaginemos lo que habría sucedido en el caso de haber modificado la clase original para incluir la funcionalidad adicional requerida: si hubiésemos cometido un error en ese proceso, no solo la estufa no se apagaría correctamente, sino que también todos los dispositivos que antes se apagaban correctamente quizás ahora hubieran dejado de hacerlo. Es importante tener en cuenta que, aunque este principio no impide que en el futuro tengamos que hacer cambios en la clase, estos cambios deberían estar orientados principalmente a solucionar errores que puedan surgir, en lugar de añadir funcionalidades que la clase original no debería manejar. Conclusión El principio abierto/cerrado es esencial para el desarrollo de software de calidad. Al seguir este principio, podemos diseñar elementos de software que sean flexibles y extensibles sin comprometer su estabilidad o eficacia, lo que resulta en un código más limpio y fácil de mantener. Y aquí terminamos la explicación del segundo principio SOLID. Como siempre, cualquier duda, sugerencia o corrección, será bienvenida. Nos vemos en el capítulo :strong[L]{.text-green-500} (seguro que a quien sea fan de Death Note le ha hecho ilusión el nombre). Puedes ver un resumen en esta entrada de Instagram . Más artículos de esta serie :strong[Capítulo S]{.text-red-500}: Single Responsibility Principle o Principio de responsabilidad única :strong[Capítulo L]{.text-green-500}: Liskov Substitution Principle o Principio de sustitución de Liskov :strong[Capítulo I]{.text-pink-500}: Interface Segregation Principle o Principio de segregación de interfaces :strong[Capítulo D]{.text-violet-500}: Dependency Inversion Principle o Principio de inversión de dependencias",
    "imageMini": "/images/solid-logo-mini.webp"
  },
  {
    "slug": "20220107.html",
    "title": "Principios SOLID. Capítulo S: Single Responsibility Principle",
    "description": "En el principio Dahl y Nygaard crearon la programación orientada a objetos. Y esta se encontraba desordenada y vacía, y las tinieblas estaban sobre la faz de la programación. Pero entonces Robert C. Martin, habló a los congregados y les dijo:",
    "url": "/articles/posts/20220107.html",
    "date": "2022-01-07",
    "categories": [
      "programación",
      "diseño y arquitectura",
      "SOLID"
    ],
    "content": "Introducción En el principio Dahl y Nygaard crearon la programación orientada a objetos. Y esta se encontraba desordenada y vacía, y las tinieblas estaban sobre la faz de la programación. Pero entonces Robert C. Martin , habló a los congregados y les dijo: &quot;Aquí tenéis los 5 mandamientos de la programación orientada a objetos. No son verdades absolutas y no siempre podrán vivir conjuntamente. Usadlos con mi beneplácito&quot;. Ejem.... perdón, que quería realizar una idealización de nuestro pasado en la programación. Así que dejemos las introducciones grandilocuentes para comenzar a hablar de SOLID . ¿Qué es? ¿Con que fin nace?. SOLID es un conjunto de prácticas propuestas por Robert C. Martin con el fin de resolver los problemas existentes en las aplicaciones desarrolladas mediante programación orientada a objetos (POO), y así hacerlas más sencillas de leer, mantener y testear. El acrónimo se compone de las iniciales de cada uno de los cinco principios o prácticas que lo conforman: :strong[S]{.text-red-500}: Single Responsibility Principle o Principio de responsabilidad única :strong[O]{.text-orange-500}: Open-Closed Principle o Principio abierto/cerrado :strong[L]{.text-green-500}: Liskov Substitution Principle o Principio de sustitución de Liskov :strong[I]{.text-pink-500}: Interface Segregation Principle o Principio de segregación de interfaces :strong[D]{.text-violet-500}: Dependency Inversion Principle o Principio de inversión de dependencias En muchas ocasiones, al buscar información sobre estos principios en la red, se encuentran datos poco claros o artículos demasiado extensos que generan más dudas que respuestas. Por esta razón, hemos creado una serie de cinco artículos en los que explicaremos cada uno de los principios de forma clara y práctica, para que puedas saber cuándo, cómo y por qué aplicarlos en tus proyectos. Cabe destacar que estos principios, no quedan relegados a las clases, se puede aplicar a otros ámbitos. (:strong[ S ]{.text-red-500}) Principio de responsabilidad única &quot;Una clase debería tener una, y sólo una, razón para cambiar&quot; Robert C. Martin Una clase sólo debería hacer una única cosa, es decir, tener sólo una responsabilidad. Si hacemos que una clase se encargue de todo, cualquier cambio en la funcionalidad requerirá de modificaciones en dicha clase, e incluso en partes en las que no debería cambiar. Para detectar si estamos cumpliendo este principio, podemos hacernos varias preguntas: ¿La clase es muy grande? Normalmente, esto puede indicar que está haciendo demasiadas cosas. ¿Cualquier cambio en otras capas del código requieren cambios en la clase? Esto implica que la clase está llevando a cabo funciones de capas de la arquitectura que no debería ni saber que existen. Por ejemplo, que una clase con información de usuario tenga métodos de guardado de en base de datos. ¿Por qué debería cambiar la clase Usuario si cambia la base de datos o las consultas? ¿Por qué tengo &quot;grupos&quot; de atributos en la clase que no parecen estar relacionados entre sí? Volviendo al ejemplo del punto anterior, ¿qué hace un atributo dbConnector en mi clase Usuario? ¿Por qué tengo que configurar medio entorno para testear sólo esta clase? A excepción de que quisieras hacer una prueba de la clase que carga toda tu aplicación, en la clase Usuario no debería ser necesario configurar o mockear una gran cantidad de elementos para crear pruebas unitarias. Para ilustrar este punto, podemos tomar como ejemplo una clase mal diseñada llamada TextDocument, que contiene las propiedades de un documento y también se encarga de compartirlos: La clase presenta un problema al tener dos responsabilidades. Por un lado, gestiona el documento y, por otro, se encarga de compartirlo. ¿Realmente es algo que el documento debe saber? Y es que el compartir no es algo relativo a las propiedades de un documento, sino es una acción para realizar otro fin, por lo que esta responsabilidad no debería ser del documento. Es más, esta parte estaría muy acoplada a la forma de compartir, no es lo mismo enviar por correo electrónico que compartir por Bluetooth. Por lo que volvemos a preguntarnos, ¿un documento debe saber que hay correo electrónico y Bluetooth en nuestro proyecto? La respuesta es bien sencilla, no debe saber nada del exterior o de lo que puedan hacer con él. Debe vivir en su mundo aislado cual hikikomori. Para solucionar este problema, dejamos que TextDocument tenga sólo la responsabilidad de operar con un documento, y además creamos una clase que se encargue exclusivamente de compartir documentos. Yendo más allá, En lugar de tener una sola clase, podemos separar las responsabilidades en diferentes clases, como EmailSharer y BluetoothSharer. De esta forma, tenemos una estructura que se puede probar fácilmente y que además está desacoplada por funcionalidades. En resumen, el Principio de Responsabilidad Única nos ayuda a crear clases más cohesivas y modulares, lo que facilita la comprensión, mantenimiento y prueba de nuestro código. En el siguiente artículo pasaremos a la letra :strong[O]{.text-orange-500}: Open/Closed Principle. Si eres de esas personas que prefieren un resumen, puedes verlo en este post de Instagram . Más artículos de esta serie :strong[Capítulo O]{.text-orange-500}: Open-Closed Principle o Principio abierto/cerrado :strong[Capítulo L]{.text-green-500}: Liskov Substitution Principle o Principio de sustitución de Liskov :strong[Capítulo I]{.text-pink-500}: Interface Segregation Principle o Principio de segregación de interfaces :strong[Capítulo D]{.text-violet-500}: Dependency Inversion Principle o Principio de inversión de dependencias",
    "imageMini": "/images/solid-logo-mini.webp"
  },
  {
    "slug": "20220104.html",
    "title": "3 formas extra de definir constantes con TypeScript",
    "description": "Seguramente ya te has habituado al uso de `const` en TypeScript (y espero que en JavaScript también, no me declares constantes con `let` o `var` &#x1f609;). Y sabemos que con elementos de tipo primitivo funciona de lujo:",
    "url": "/articles/posts/20220104.html",
    "date": "2022-01-04",
    "categories": [
      "programación",
      "TypeScript"
    ],
    "content": "Seguramente ya te has habituado al uso de const en TypeScript (y espero que en JavaScript también, no me declares constantes con let o var &#x1f609;). Y sabemos que con elementos de tipo primitivo funciona de lujo: Pero quizás te has visto alguna vez con el caso siguiente: Y es que el declarar como constante un objeto, lo que no permite es reasignar la referencia al objeto, pero sí podremos modificar el valor de sus atributos. Es decir, con el ejemplo superior, lo único que no podremos hacer es tener lo siguiente: person = { nuevo contenido } o person = anotherPerson . Hoy veremos varias formas de poder declarar objetos como constantes, de forma que no podamos tampoco cambiar sus atributos. Eso sí, sólo desde TypeScript, en JavaScript no existen estas restricciones, por desgracia. Método 1. Declarando un objeto como const En este caso, lo que usaremos es const como tipo del objeto. De esta forma ya no será posible modificar sus atributos. Método 2. Usando readonly Si usamos el modificador readonly en un atributo de una clase, un tipo, o una interfaz. Éste pasará a ser de sólo lectura. Eso sí, mucho cuidado en las clases, porque hay un caso que no falla. Y es la asignación dentro del constructor. Esto es debido a que en el constructor se permite inicializar todas las variables independientemente de que ya lo estuvieran: En este caso te recomiendo que llegues a un consenso para o inicializar los atributos readonly de las clases nada más declararlos, o en el constructor, simplemente por claridad. Método 3. Arrays constantes Este es otro de los casos mágicos que nos permite TypeScript, y es tener arrays con elementos constantes. Es decir, que una vez creado el array, ya no podrá ser modificado. Para ello, los métodos push , pop , splice , etc, dejan de estar disponibles (es sólo a nivel de compilación de TypeScript, si accedes a ese array desde JavaScript será como cualquier otro). Si quieres ver un resumen puedes revisar este cheat sheet de atributos constantes en Instagram .",
    "imageMini": "/images/typescript-mini.png"
  },
  {
    "slug": "20211231.html",
    "title": "11 cosas que quizás no sabías de JavaScript",
    "description": "Todo lenguaje de programación tiene sus pequeños secretos que no todo el mundo conoce. Hoy vamos a ver once características, cualidades, o mejoras de JavaScript que son poco conocidas. No me enrollo más, y pasemos ¡al turrón! (buenas fechas para decirlo).",
    "url": "/articles/posts/20211231.html",
    "date": "2021-12-31",
    "categories": [
      "programación",
      "JavaScript"
    ],
    "content": "Todo lenguaje de programación tiene sus pequeños secretos que no todo el mundo conoce. Hoy vamos a ver once características, cualidades, o mejoras de JavaScript que son poco conocidas. No me enrollo más, y pasemos ¡al turrón! (buenas fechas para decirlo). 1. Cargar módulos sin librerías De un tiempo a esta parte, es posible importar módulos en JavaScript sin necesidad de librerías externas gracias a la sentencia import ( Ver compatibilidad en Can I Use? ). Veamos como funciona con un ejemplo sencillo: Si te gusta usar await estás de suerte, pues puedes hacer importaciones desde una función tal que así: 2. Esperar a que terminen todas las promesas El método Promise.all() ( Ver compatibilidad en Can I Use? ) termina en cuanto una promesa de las que recibe falla. Sin embargo en ocasiones puede que nos interese esperar a que todas las promesas vayan bien o mal. Para ello podemos usar Promise.allSettled() . Como siempre veamos un ejemplo aprovechando los import que vimos antes (que devuelven una promesa): Podemos ver como con allSettled() , recibimos un array de resultados de promesa como argumento de la función utilizada en then . Así podremos saber que llamadas han funcionado y las que han fallado. Una buen caso de uso para este ejemplo, se da en el caso de que necesitemos hacer varias llamadas REST de forma simultánea. Así aunque una falle, podremos saber el resultado de las demás. Un último apunte a destacar de allSettled() , y es que aunque fallen todas las promesas, siempre pasará por el camino then . En nuestro ejemplo lo pusimos a modo ilustrativo para ver que por ahí no pasa. 3. Dejar de esperar varias promesas en cuanto termine una En esta ocasión, si lo que queremos es que se termine la espera en cuanto se resuelva una promesa de varias, lo que usaremos es any() ( Ver compatibilidad en Can I Use? ). Con ella, para que el código pase por el catch , deberán fallar todas las promesas. 4. Hay un this global, pero de verdad de la buena Toda la gente que nos hemos peleado con JavaScript, hemos visto que dependiendo del entorno en que ejecutemos nuestros scripts, si llamamos a this a secas fuera de todo ámbito, el objeto global cambia. En los navegadores es window , en Node.js es global y en los WebWorker es self . Pues a partir de ahora, si queréis hacer algo más unificado, tan sólo tendréis que llamar a globalThis ( Ver compatibilidad en Can I Use? ). Esta palabra clave tendrá la instancia del objeto global que corresponda sin depender del entorno. 5. Acceder a atributos que pueden ser nulos o indefinidos A esta técnica se le llama Optional chaining. Y para ello usamos el operador ?. ( Ver compatibilidad en Can I Use? ). Con esto ya no tendremos errores si un atributo no existe: El operador provoca un “cortocircuito” cuando la propiedad a su izquierda no existe, o tiene valor null . Devolviendo automáticamente el valor undefined , en lugar de un error como ocurre si quitamos este nuevo operador. 6. &quot;Aplanar&quot; arrays Otra cosita genial, es que ahora podemos pasar un array de varias dimensiones a sólo una, gracias el método flat() ( Ver compatibilidad en Can I Use? ). En el código siguiente, pongo varios saltos de línea para que os quede más claro cada array de ejemplo: Si no pasamos parámetros, por defecto, sólo &quot;aplana&quot; la segunda dimensión (equivaldría a poner 1 como parámetro), pero le podemos pasar el número de dimensiones extra a comprobar. 7. El mágico operador ?? Este nuevo amiguito con nombre y apellidos, se llama nullish coalescing operator y viene representado por ?? ( Ver compatibilidad en Can I Use? ). En primera instancia puede parecer que su uso es como el operador || , que nos devuelve el primer valor que no sea falsy , pero es mejor, ya que sólo funciona con null y undefined , devolviendo el resto de valores falsy . Mejor que lo veáis con un ejemplo: 8. Operadores de asignación lógicos El anterior operador más los ya conocidos &amp;&amp; , || ya se pueden utilizar en la asignación de valores, en este caso, se les llama operadores de asignación lógicos ( Ver compatibilidad en Can I Use? : Hay que destacar que, en el momento de escribir este artículo, con las cadenas este tipo de operadores no funcionan como se espera (al menos con navegadores con motores Chromium y Gecko), ya que si probamos tenemos lo siguiente: 9. Separador numérico Puede que manejemos cifras que son grandes en nuestra aplicación, y queda a veces enrevesado poder distinguir que cifra hay escrita si no se pone cierta atención en su lectura. Pues el nuevo separador de miles de JavaScript acude en nuestra ayuda cual Chapulín Colorado. Es tan sencillo como poner el símbolo _ ( Ver compatibilidad en Can I Use? ) para separar los miles: 10. Reemplazos en cadenas sin expresiones regulares ¿Cuántas veces hemos usado una expresión regular para reemplazar todas las veces que aparecía un texto en una cadena? Pues ¡el &quot;expresionar&quot; se va a acabar! (Aquellas personas de cierta edad entenderán el “chiste”). Ahora las cadenas tienen un método nuevo llamado replaceAll() ( Ver compatibilidad en Can I Use? ) que hace todo el trabajo... sucio. Sólo hay que pasar el texto a reemplazar y el que queremos poner en su lugar, y hará toda la magia. 11. En los arrays no todo son corchetes Seguro que muchas veces para acceder al último elemento de un array, has jugado con ir a la posición dada por la longitud del array - 1 . Ahora tenemos el método at() ( Ver compatibilidad en Can I Use? ) que con posiciones positivas funciona como los corchetes, pero al que si le pasamos posiciones negativas, comienza desde la parte de atrás del array. Veamos a nuestro amiguito en acción:",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20211228.html",
    "title": "Iteradores en JavaScript. Parte 2. Funciones generadoras",
    "description": "Una función generadora es aquella que devuelve un generador. Si no has leído el artículo anterior estarás pensando: “Pues me he quedado igual” &#x1f602;, así que te recomiendo que le des una vuelta para ir poniéndote en situación.",
    "url": "/articles/posts/20211228.html",
    "date": "2021-12-28",
    "categories": [
      "programación",
      "JavaScript"
    ],
    "content": "Una función generadora es aquella que devuelve un generador. Si no has leído el artículo anterior estarás pensando: “Pues me he quedado igual” &#x1f602;, así que te recomiendo que le des una vuelta para ir poniéndote en situación. Si pasamos a hacer una definición más formal: Una función generadora es aquella que actúa como un iterador con distintos puntos de salida. Esto es, al instanciarla, podemos ir llamando al método next() del iterador, que nos devolverá un valor y el estado para poder saber si hay más valores en ese iterador. Esto lo vamos a entender mejor con un ejemplo: En el ejemplo anterior, lo primero que habréis apreciado es que tras function aparece el carácter * . Esto indica que la función es de tipo generadora. Si no usáramos el asterisco, ya no actuaría como tal y tampoco podríamos utilizar la palabra clave yield dentro de ella. Pero, ¿qué hace yield ? Pues al usarla actúa como un return un tanto especial, ya que deja un marcador a la última posición en la que se llamó. De forma que al llamar al iterador con .next() , se continuará por la línea siguiente al último ejecutado. Tendríamos un flujo como el siguiente: En el ejemplo hemos visto un caso muy sencillo y poco práctico. Pero doblemos la apuesta y pasemos a algo más complicadillo: En esta ocasión tenemos un generador de números de Fibonnaci. Lo más interesante de este ejemplo, es que se puede comprobar como las variables internas a la función guardan sus valores en cada paso del iterador. Para terminar, si en lugar de hacer un bucle con los 10 primeros números, llegáramos a dejarlo en un bucle for...of , éste terminaría cuando el valor actual sea Infinity .",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20211226.html",
    "title": "Iteradores en JavaScript. Parte 1. Symbol.iterator",
    "description": "En ocasiones tenemos algún tipo de lista de la que queremos recorrer su elementos de uno en uno. Para este menester vienen a ayudarnos nuestros amigos los iteradores. Y es que en JavaScript podemos hacer que cualquier objeto funcione como un iterador, de forma que podemos ir moviéndonos uno a uno por los elementos que lo componen.",
    "url": "/articles/posts/20211226.html",
    "date": "2021-12-26",
    "categories": [
      "programación",
      "JavaScript"
    ],
    "content": "En ocasiones tenemos algún tipo de lista de la que queremos recorrer su elementos de uno en uno. Para este menester vienen a ayudarnos nuestros amigos los iteradores. Y es que en JavaScript podemos hacer que cualquier objeto funcione como un iterador, de forma que podemos ir moviéndonos uno a uno por los elementos que lo componen. Lo primero de todo es definir como es la estructura de un iterador en JavaScript, y es que es tan simple, como un objeto que tiene definido un método next() y devuelve un objeto con dos atributos: value : valor actual en la secuencia. done : valor booleano que será true cuando hemos terminado de recorrer la secuencia y false mientras podamos seguir recorriéndola. Como ejemplo para entender este concepto, se va a partir de una lista enlazada, en la que se podrá ir recorriendo sus elementos uno a uno. En el código he ido incluyendo comentarios con la explicación. Pero básicamente para que los objetos de nuestra clase se puedan iterar, necesitamos escribir un método cuyo nombre sea [Symbol.iterator]() . Con esto se indica a JavaScript que el objeto es iterable. Ahora que tenemos construida la definición vamos a ver lo que ocurriría al incluir el objeto en un bucle for...of : Como se puede ver, en cada vuelta del bucle for...of , obtenemos el atributo value que devolvimos con el método next() . Tras esto, si volvemos a escribir un bucle con nuestro objeto, se comenzará de nuevo el recorrido desde el primer elemento de la lista. Finalmente, se podría dar el caso de que necesitásemos convertir el iterador en un array. Pues bien, para eso podemos utilizar el método Array.from() . En la segunda parte de esta mini-guía aprenderemos a iterar mediante el uso de funciones generadoras.",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20211214.html",
    "title": "Receta: Validar valores numéricos en JavaScript",
    "description": "En muchas ocasiones nos interesa verificar que una variable contiene un valor numérico. Un atajo podría ser usar:",
    "url": "/articles/posts/20211214.html",
    "date": "2021-12-14",
    "categories": [
      "programación",
      "JavaScript"
    ],
    "content": "En muchas ocasiones nos interesa verificar que una variable contiene un valor numérico. Un atajo podría ser usar: El problema, es que con esa condición dejamos fuera al valor 0. Así que lo siguiente que se suele hacer, es tener fórmulas del estilo: Algo que como se puede apreciar es muy poco eficiente, y también bastante feote. Es por ello que vamos a ver como verificar que tenemos un valor real o uno entero de una forma mucho más sencilla. Para ello, nos valdremos de los funciones Number.isFinite() y Number.isInteger() . Como habéis podido comprobar, las dos funciones anteriores, nos ofrecen una forma muy sencilla de validar si un elemento es un número, y aparte verificar que es finito. Ya que por ejemplo, se podría hacer un typeof de la variable, pero los valores Infinity y -Infinity tienen como tipo number , y en caso de querer comprobar que es un entero, deberíamos verificar algunas cosillas extra. En mi opinión lo que hemos visto, queda más elegante, nos proporciona información extra de qué es lo que se desea comprobar y, lo mejor de todo, no requiere de librerías externas.",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20211208.html",
    "title": "Orientación a objetos con JavaScript (ES6). Parte 4. Método valueOf()",
    "description": "En ocasiones puede que tengamos un objeto que represente un valor que podría ser de tipo primitivo, es decir, un boolean, string o number (principalmente). Para acceder a este valor podríamos tener un método que llamemos \"manualmente\" cuando queramos usar el objeto como valor primitivo, pero JavaScript nos proporciona un atajo, y es sobrescribir el método `valueOf()`. Si tenemos dicho método implementado, cuando sea necesario usar el objeto como si fuera un tipo primitivo, el intérprete pasará a llamarlo de forma transparente para nosotros.",
    "url": "/articles/posts/20211208.html",
    "date": "2021-12-08",
    "categories": [
      "Programación",
      "JavaScript",
      "POO",
      "Programación Orientada a Objetos"
    ],
    "content": "En ocasiones puede que tengamos un objeto que represente un valor que podría ser de tipo primitivo, es decir, un boolean, string o number (principalmente). Para acceder a este valor podríamos tener un método que llamemos &quot;manualmente&quot; cuando queramos usar el objeto como valor primitivo, pero JavaScript nos proporciona un atajo, y es sobrescribir el método valueOf() . Si tenemos dicho método implementado, cuando sea necesario usar el objeto como si fuera un tipo primitivo, el intérprete pasará a llamarlo de forma transparente para nosotros. Veamos primero un ejemplo de una posible clase que representara un instante de tiempo con horas, minutos y segundos. Como podemos observar en el ejemplo anterior, si intentamos operar con el objeto y un valor primitivo, en este caso sumarle 10, el resultado es que ambos elementos se convierten a cadena, siendo el resultado la concatenación del toString() de la clase (como no lo hemos sobrescrito, será &quot;[object Object]&quot; ), y &quot;10&quot; . Hagamos una ligera modificación en la clase Time, añadiendo el método famoso: Ahora se puede comprobar, como si se realiza la suma correctamente. Esto es porque el intérprete de JavaScript intenta buscar un método valueOf() en el objeto, de forma que al encontrarse en esta nueva versión, se termina llamando, y puesto que devolvemos un valor primitivo de tipo numérico, se realiza la suma correctamente. En resumen, la implementación del método valueOf() , permite que un objeto actúe como un valor primitivo. Más artículos de esta serie : Parte 1. Clases Parte 2. Herencia Parte 3. Miembros estáticos",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20211206.html",
    "title": "Diferencias entre var y let en JavaScript",
    "description": "Hasta hace unos años lo normal era usar `var` para declarar las variables en JavaScript. Sin embargo desde ES6, se introdujo la palabra clave `let`. Esto introduce tres cambios principales con respecto al uso de `var`.",
    "url": "/articles/posts/20211206.html",
    "date": "2021-12-06",
    "categories": [
      "programación",
      "JavaScript"
    ],
    "content": "Hasta hace unos años lo normal era usar var para declarar las variables en JavaScript. Sin embargo desde ES6, se introdujo la palabra clave let . Esto introduce tres cambios principales con respecto al uso de var . let Hay tres puntos principales a destacar en el uso de let. Así que pasaremos a verlos con ejemplos de código muy sencillitos. No se puede llamar a una variable antes de declararse No se puede volver a declarar una variable con el mismo nombre que otra La variable acota su ámbito al bloque en que se haya definido En este último ejemplo, como el código es más largo, pasemos a ver lo que ocurre con cada variable declarada: globalVar : tiene de ámbito toda la función. globalLet : tiene de ámbito toda la función. indexVar : aunque se declara en el bucle. Ya sabemos se use donde se use, la declaración con var , es equivalente a poner una línea &quot; var indexVar; &quot; al principio de la función. indexLet : se declara dentro del bucle, de forma que en cuanto éste termina, la variable deja de existir. inIfVar : ocurre lo mismo que con indexVar . Aunque esté dentro del bloque condicional, es como si se hubiera declarado al principio de la función. inIfLet : sólo vive dentro del bloque condicional en el que se encuentra. Desde fuera ya no existe. Resumen En este artículo hemos aprendido las diferencias entre let y var . Por lo que ya sabes, de ahora en adelante deberías usar let , ya que está ampliamente soportado por los navegadores modernos , y nos puede ayudar a evitar errores en el código, principalmente: evitando que tengamos una variable que se puede usar sin estar declarada, que una variable se pueda declarar dos veces (perdiendo un poco el contexto de su uso y los posibles problemas derivados), o que sea modificada en un ámbito que no toque. Junto con const , debería ser la forma principal de declarar variables y constantes en tu aplicación.",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20211205.html",
    "title": "Orientación a objetos con JavaScript (ES6). Parte 3. Miembros estáticos",
    "description": "Ya hemos visto una pequeña introducción a las clases y la herencia en JavaScript. En esta tercera parte nos toca revisar los métodos y atributos estáticos. Primero pasemos a definir que es un miembro estático de manera más o menos oficial:",
    "url": "/articles/posts/20211205.html",
    "date": "2021-12-05",
    "categories": [
      "Programación",
      "JavaScript",
      "POO",
      "Programación Orientada a Objetos"
    ],
    "content": "Ya hemos visto una pequeña introducción a las clases y la herencia en JavaScript. En esta tercera parte nos toca revisar los métodos y atributos estáticos. Primero pasemos a definir que es un miembro estático de manera más o menos oficial: Un miembro estático es aquel que reside en una clase sin requerir una instancia de esta para ser ejecutado. De forma que hay sólo una copia de éste, y se puede llamar sin tener objetos de la clase. Para declarar un miembro estático, no os podéis imaginar la palabra reservada que se va a usar... así es, se utiliza &quot; static &quot;. Bueno, pongámonos serios y pasemos a ver un ejemplo de código: Partiendo del código anterior, podemos ver como con static , hacemos que un método pase a ser estático, y que tanto para llamarlo desde dentro de la clase como desde fuera, se indicará el nombre de la clase y el nombre del atributo o método al que acceder. En este caso, sólo hay definido un método add() , es decir, al contrario que ocurre con un método normal (también lo podemos aplicar a los atributos), no habrá un objeto con su propia &quot;copia&quot; del método, sino que habrá uno global para todos los objetos. ¿Esto cómo aplica a la herencia? Pues veamos otro ejemplo: ¡Hey espera! ¿Por qué el cálculo del precio de la lijadora devuelve 110, en lugar de 121?. Esto es porque en el método de la clase padre tenemos Article.taxPercent . En este caso al ser un elemento estático, no sobre-escribimos dicho valor, como si podría dar pie con miembros no estáticos. Es por ello que en el cálculo estamos llamando a taxPercent del padre. Si fuera necesario llamar al nuevo taxPercent , tendríamos que sobreescribir el método de DeluxeArticle de forma que quedara tal que así: Ahora si estamos llamando al atributo estático de nuestra clase. En resumen, en el código de ejemplo estamos teniendo dos atributos estáticos con el mismo nombre, uno accesible con Article.taxPercent , y el otro con DeluxeArticle.taxPercent . Es más podemos acceder a uno u otro indistintamente según nos haga falta, siempre anteponiendo el nombre de la clase que lo contiene. Con todo lo visto, es muy sencillo pasar a implementar el conocido patrón singleton en JavaScript: La pena es que no se puedan tener constructores privados en JavaScript para evitar instancias ajenas que no vayan por el método getInstance() . Más artículos de esta serie : Parte 1. Clases Parte 2. Herencia Parte 4. Método valueOf()",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20211203.html",
    "title": "Orientación a objetos con JavaScript (ES6). Parte 2. Herencia",
    "description": "En el artículo anterior aprendimos los conceptos básicos sobre clases en JavaScript. En esta ocasión vamos a ver como aplicar la herencia sobre distintos objetos. Partiremos de un código que iremos desgranando poco a poco.",
    "url": "/articles/posts/20211203.html",
    "date": "2021-12-03",
    "categories": [
      "Programación",
      "JavaScript",
      "POO",
      "Programación Orientada a Objetos"
    ],
    "content": "En el artículo anterior aprendimos los conceptos básicos sobre clases en JavaScript. En esta ocasión vamos a ver como aplicar la herencia sobre distintos objetos. Partiremos de un código que iremos desgranando poco a poco. En esta jerarquía tenemos tres clases Animal, que tiene como hija Bird, que a su vez tiene como hija Stork. De la clase Animal no comentaremos mucho, pues ya vimos todo lo que contiene en el artículo anterior. En la clase Bird nos detendremos en su definición y en su constructor: En primer lugar vemos como poder establecer la relación de herencia con la clase padre con la palabra clave extends . Esto es similar a otros lenguajes como Java. Cabe destacar que de forma oficial sólo es posible heredar de esta forma de una clase. Se puede realizar herencia múltiple con otros métodos que veremos en otra ocasión... Si nos vamos al constructor, aparece la palabra reservada super() . Esto indica que vamos a llamar al constructor de la clase base, la cual recibía un parámetro el cual le indicamos. De forma, que cuando el código entre al constructor de Bird, primero llamará al constructor de la clase padre, para posteriormente seguir con el resto del código de la clase hija. Lo siguiente será ver otra cosilla relacionada con super , pero en la clase &quot;nieta&quot;: En esta ocasión podemos comprobar como si se indica un método de la clase base con super . nombreMétodo (), es posible llamar a éste. Finalmente, indicar como sería el flujo de llamadas a constructores con lo que hemos implementado en este ejemplo. Habéis visto que hay varios console.log al entrar y salir de los constructores. Pues bien, al crear la instancia de la clase Stork veríamos esto por consola: Enlaces : Especificación en EcmaScript 2025 Parte 1. Clases Parte 3. Miembros estáticos Parte 4. Método valueOf()",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20211128.html",
    "title": "Orientación a objetos con JavaScript (ES6). Parte 1. Clases",
    "description": "La mayoría de lenguajes de programación orientados a objetos disponen de la posibilidad de definir la estructura de una clase, sin embargo, JavaScript hasta ahora, permitía trabajar con objetos, pero no ofrecía una forma práctica de definir las clases, más allá de crearlas como una función.",
    "url": "/articles/posts/20211128.html",
    "date": "2021-11-28",
    "categories": [
      "Programación",
      "JavaScript",
      "POO",
      "Programación Orientada a Objetos"
    ],
    "content": "La mayoría de lenguajes de programación orientados a objetos disponen de la posibilidad de definir la estructura de una clase, sin embargo, JavaScript hasta ahora, permitía trabajar con objetos, pero no ofrecía una forma práctica de definir las clases, más allá de crearlas como una función. Veamos todo esto mejor con un ejemplo: Con el código anterior podemos usar una función como si fuera una clase. Uno de los trucos para tener los atributos como privados, es declararlos sin &quot;this&quot;. De esta forma, no se verán de forma externa. El problema viene cuando se quiere por ejemplo, utilizarlos en métodos añadidos a posteriori usando por ejemplo: Lo que nos llevará a tener que crear getters y setters para que métodos que la propia clase puedan acceder a los atributos, algo que queda un poco confuso. Lo anterior unido a otros problemas, como un sistema raro de herencia, la propia nomenclatura de saber que se define una clase, pero se utiliza la palabra function, etc. Ha hecho que el lenguaje haya evolucionado hasta disponer en la versión 6 de EcmaScript (recordemos que es el nombre que se usa para el estándar definido de JavaScript), de una definición de clases más ajustada a otros lenguajes. Veamos la clase anterior definida con ES6: Pasemos a desgranar un poco las líneas de código: De esta forma se definen ahora las clases en ES6. Es una sintaxis mucho más próxima al resto de lenguajes como Java, C++, C#, Python, etc. Las tres líneas de arriba, definen los atributos de la clase. Podréis observar como tienen prefijado un símbolo &quot; # &quot;. Esto indica que el atributo (o también el método), es privado. Lo que permite que éste no sea visible de forma externa. Por desgracia aún no existe el concepto de &quot;protected&quot; en JavaScript, de forma que no podemos hacer que métodos o atributos no sean visibles al exterior pero sí a clases hijas. Por lo que a día de hoy, o un elemento es visible al exterior o no es visible para nadie. Estas sentencias definen el constructor que tendrá la clase. Al contrario de lo que sucede con otros lenguajes, en JavaScript no podemos tener sobrecarga de constructores, por lo que sólo podemos definir uno. Si tuviéramos varios, se lanzará un error: En el fragmento anterior se puede observar la definición de un método, en este caso público (no lleva el símbolo &quot;#&quot;), llamado addInvoice . Aquí podemos ver también que para acceder a atributos y métodos privados, tenemos que incluir el almohadilla en su nombre. Aquí tenemos también otra nomenclatura nueva. Ésta se utiliza para definir getters y setters con un estilo parecido a las propiedades en C# . Es decir, podemos llamarlas desde el exterior como si fueran atributos y no métodos. Veremos su uso unas pocas líneas más adelante. A nivel de instanciación de la clase, podemos observar como no cambia nada respecto a cuando usamos una función para instanciarla. Si recordáis antes teníamos definido un método getter, pues esta sentencia muestra su uso. Para ello se llama sin los paréntesis, como su fuera un atributo público. Si por ejemplo hubiésemos tenido un setter, este sería su uso: Finalmente, para esta línea vemos que se produce un error. Este es lanzado, ya el intérprete de JavaScript detecta que #name es privado (por su prefijo), y nos advierte que no podemos usarlo de forma externa a la clase. Y hasta aquí esta introducción al nuevo sistema de definición de clases en JavaScript. Seguiremos poco a poco introduciendo los conceptos de herencia, algunos métodos útiles que podemos sobre-escribir de Object, etc. Enlaces : Parte 2. Herencia Parte 3. Miembros estáticos Parte 4. Método valueOf() Cheat sheet en Instragram",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20210524.html",
    "title": "Comunicando pestañas del navegador con localStorage",
    "description": "Hay mucha gente que me ha preguntado en ocasiones si sería posible tener comunicación entre dos pestañas del navegador. Y la respuesta es sí, pero siempre que pertenezcan a un mismo host. Para ello utilizaremos un pequeño \"truco\", y es que jugaremos con el objeto `localStorage`.",
    "url": "/articles/posts/20210524.html",
    "date": "2021-05-24",
    "categories": [
      "programación",
      "JavaScript",
      "web"
    ],
    "content": "Hay mucha gente que me ha preguntado en ocasiones si sería posible tener comunicación entre dos pestañas del navegador. Y la respuesta es sí, pero siempre que pertenezcan a un mismo host. Para ello utilizaremos un pequeño &quot;truco&quot;, y es que jugaremos con el objeto localStorage . Como explicación breve, localStorage es un atributo del objeto window. Y gracias a él, podremos persistir diferentes datos en el navegador. De forma, que dichos datos persistan incluso cuando se cierre el navegador. Para almacenarlos, se utiliza con el sistema clave / valor. Como breve inciso, su hermano sessionStorage , hace lo mismo, pero con cada sesión del navegador, es decir, una vez cerremos la pestaña o cambiemos de página, se borrarán todos los datos. Además, si tenemos dos o más pestañas abiertas de un mismo host de forma simultánea, cada una tendrá su propio sessionStorage . Si os interesa que hable más de este tema, avisadme en los comentarios y preparo un tutorial para explicar el funcionamiento de los Storages en JavaScript. Pues bien, volviendo al tema; si tenemos en cuenta que, por así decirlo, sólo hay un localStorage por host. Podemos jugar con éste, para preparar un sistema de mensajería inter-pestaña. Por un lado tendríamos nuestra función emisora: Por otro, la función receptora: Ahora pasemos a ver un poco lo que hace cada función. Por un lado la emisora, simplemente guarda en localStorage un mensaje con un identificador. Por otro, el receptor, define un manejador de eventos, para recibir aquellos que son de tipo &quot; message &quot;. Este manejador sólo será notificado cuando otra pestaña realice cambios en el localStorage. Es decir, sólo se nos notificará cuando otra pestaña cambie algo en el localStorage de nuestro host. Los cambios en el sessionStorage no son notificados por este evento. Creo que cabe decir, que lo que usemos como messageId en ambos lados, debe ser igual. Pues bien, con tan poquitas líneas y gracias al juego del evento &quot;message&quot;, podemos tener mensajería sencilla entre pestañas. El flujo será: El emisor guarda el mensaje en localStorage con una clave definida. El receptor, recibe la notificación de cambio en el Storage. Pasa a comprobar si el ítem modificado es el esperado. Y si es así, y tiene contenido el mensaje, pasaría a seguir con el comportamiento esperado. Como extra, la emisora podría dejar vacío nuevamente el campo del mensaje, por si en algún otra sección del código de la parte receptora necesitara mirar la clave.",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20181023.html",
    "title": "Benckmark: switch con caracteres",
    "description": "En esta ocasión traemos una prueba sencilla para comprobar si es más rápido tener un switch en el que se comprueben cadenas de un carácter, o por el contrario es más veloz convertir antes dichos caracteres a su valor ASCII. En el segundo caso nos valdremos del uso de `charCodeAt()`.",
    "url": "/articles/posts/20181023.html",
    "date": "2018-10-23",
    "categories": [
      "Programación",
      "JavaScript"
    ],
    "content": "En esta ocasión traemos una prueba sencilla para comprobar si es más rápido tener un switch en el que se comprueben cadenas de un carácter, o por el contrario es más veloz convertir antes dichos caracteres a su valor ASCII. En el segundo caso nos valdremos del uso de charCodeAt() . Función 1. Switch con cadenas Para la primera función, tan sólo tendremos un switch que compruebe las cadenas que queramos &quot;controlar&quot;. Tanto, en esta función, como en la siguiente, se ha dejado el código del case vacío, de forma que se evite obtener datos falseados por operaciones que se realicen en dicho case. Función 2. Switch con ASCII Con la segunda función se convierte el &quot;caracter&quot; recibido en su correspondiente valor ASCII. De forma que, el switch se llevará a cabo sobre dicho valor. Como podréis comprobar el código no contiene comprobaciones extra para evitar que se alteren los resultados. La batería de pruebas El código encargado de medir los tiempos para las dos pruebas será el mismo en ambos casos. Llamando a una u otra función dependiendo de la prueba. Resultados Para mí ha sido una sorpresa ver lo lento que ha funcionado convertir a ASCII, siendo el ganador con diferencia el switch de caracteres: Función Paso 1 Paso 2 Paso 3 Paso 4 Paso 5 Paso 6 Paso 7 Paso 8 Paso 9 Paso 10 Media String 18 8 7 7 8 7 6 6 7 7 8.1 Ascii 245 232 232 232 231 235 239 231 237 239 235.3 Como resultado de las pruebas, se observa una clara vencedora, la función con el switch de cadenas. Esta función es casi 30 veces más rápida que la encargada de convertir el carácter a ASCII.",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20160914.html",
    "title": "Internacionalización en ES6 (y 3): La clase NumberFormat",
    "description": "Para terminar con esta mini-serie de artículos sobre internacionalización, a lo largo de los dos anterior artículos (parte 1 y parte 2), descubrimos el namespace **Intl**, así como las ventajas que ofrece su uso. En este último artículo, descubriremos como mejorar el formateo de números gracias a la clase `NumberFormat`.",
    "url": "/articles/posts/20160914.html",
    "date": "2016-09-14",
    "categories": [
      "Programación",
      "JavaScript"
    ],
    "content": "Para terminar con esta mini-serie de artículos sobre internacionalización, a lo largo de los dos anterior artículos ( parte 1 y parte 2 ), descubrimos el namespace Intl , así como las ventajas que ofrece su uso. En este último artículo, descubriremos como mejorar el formateo de números gracias a la clase NumberFormat . NumberFormat El objeto Intl.NumberFormat nos permite construir objetos que nos ayudarán a convertir valores numéricos en cadenas con el formato de un país determinado. A continuación podéis ver un ejemplo básico: local : parámetro obligatorio que será una cadena o array de cadenas con el idioma en formato BCP 47 . options : parámetro opcional en el que se especifica una serie de opciones para aplicar el formato de número que veremos en el apartado siguiente. El atributo options Al igual que con sus clases &quot;hermanas&quot;, NumberFormat tiene un atributo options , mediante el cuál se puede especificar el formato de la cadena de salida. Pasemos a ver las más comunes. style Indica la representación que se utilizará para mostrar el valor numérico. Sus valores son decimal , currency y percente . El primer caso es el valor por defecto; mientras que con el valor currency permite definir el formato moneda, el cuál requiere de otro parámetros llamado currency que indica el tipo de moneda a representar (los valores que puede tomar los encontrarás en este XML ); finalmente, el valor percent muestra el símbolo de porcentaje al final del valor, además de multiplicar el valor indicado por 100, como se puede ver en el último ejemplo. currencyDisplay Gracias a esta opción, junto con el estilo currency , podremos personalizar el formato que se mostrará para la moneda. Puede tomar los valores symbol (valor por defecto, que muestra el símbolo de la moneda), code (la moneda se muestra con su código ISO) y name (que muestra el nombre completo de la moneda). Al final del ejemplo podéis comprobar que el formato name tiene la ventaja de distinguir entre singular y plural. useGrouping Especifica si se usan los separadores en los grupos de número o no. Sus posibles valores son true (valor por defecto) y false . minimumIntegerDigits Indica el número mínimo de valores enteros a mostrar al formatear el número. Si el valor a convertir tiene menos dígitos enteros se añadirán ceros al principio. Puede tomar valores entre 1 y 21 . minimumFractionDigits De forma parecida al atributo anterior, minimumFractionDigits indica el número mínimo de valores decimales a mostrar al formatear el número. Si el valor a convertir tiene menos dígitos decimales se añadirán ceros al final. Puede tomar valores entre 0 y 20 . Si este parámetro no se especifica, se usa el valor por defecto para el idioma indicado. maximumFractionDigits En esta ocasión, con este parámetro limitaremos el número de decimales a mostrar. En el caso de que el número de decimales sea mayor que el establecido con este parámetro, se realizará un rendondeo. Su valores están comprendidos entre 0 y 20 . minimumSignificantDigits Define el número mínimo de dígitos totales con que contará el valor formateado. Puede tomar valores del rango 1 a 21 . El incremento de cifras se realiza por la parte decimal como se puede ver en los ejemplos siguientes: maximumSignificantDigits Finalmente, este parámetro define el número máximo de cifras a mostrar para el número. Con números enteros realiza un redondeo a la unidad superior. Puede tomar valores del rango 1 a 21 . Compatibilidad Tipo Android Chrome Edge Firefox IE Opera Safari Escritorio N/A 24 Todas 29 11 15 No Móvil No 26 N/A No No No No Enlaces Descripción de la clase en MDN Internacionalización en ES6 1: La clase Collator Internacionalización en ES6 2: La clase DateTimeFormat",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20160714.html",
    "title": "Benckmark: concatenación en JavaScript",
    "description": "La concatenación de cadenas es una de las operaciones que con más frecuencia se repiten en los desarrollos de aplicaciones. Es por ello, realizar dicha operación de forma óptima incrementará el rendimiento y disminuirá el uso de recursos de nuestra aplicación. En este banco de pruebas vamos a observar cuatro funciones distintas para realizar concatenar y descubrir cuál es la más rápida.\r\n\r\n## Función 1. Concatenación por instrucción\r\n\r\nEn esta primera función, se irá concatenando en cada instrucción una cadena. Se presenta el problema que así se genera una cadena nueva en cada concatenación, lo que provoca un mayor consumo de memoria. Pero presenta la ventaja de que no es necesario conocer de antemano cuantas cadenas intervienen en la operación.\r\n\r\n```javascript\r\nfunction concatenate() {\r\n    var text = '',\r\n        values = ['12', '23', '34', '45', '56'];\r\n\r\n    for (j = 0; j join() con cadena vacía. Como se observará en los resultados, esta operación es la más lenta.\r\n\r\n```javascript\r\nfunction concatenate() {\r\n    var text = [],\r\n        values = ['12', '23', '34', '45', '56'];\r\n\r\n    for (j = 0; j \r\n    \r\n        Results\r\n    \r\n\r\n```\r\n\r\nPor otro lado, el código de pruebas también es muy sencillo. Consiste en una función que realiza un bucle de 10 pasos, en el que en cada paso se llama diez millones de veces a la función encargada de concatenar las cinco cadenas. Por otro lado, se dispone de una función con la que se añade cada resultado a la tabla HTML (Se podría haber mostrado por consola simplemente, pero así queda más visual).\r\n\r\n```javascript\r\nfunction addResult(value, row, last) {\r\n    var node = document.createElement(last ? 'th' : 'td'),\r\n        textnode = document.createTextNode(value);\r\n\r\n    node.appendChild(textnode);\r\n    row.appendChild(node);\r\n}\r\n\r\nfunction test() {\r\n    var roundTime = 0,\r\n        row = document.getElementById('data'),\r\n        lap, startTime, i, endTime, currentResult;\r\n\r\n    for (lap = 0; lap < 10; ++lap) {\r\n        startTime = new Date();\r\n        for (i = 0; i < 10000000; ++i) {\r\n            concatenar();\r\n        }\r\n        endTime = new Date();\r\n\r\n        currentResult = endTime.getTime() - startTime.getTime()\r\n        roundTime += currentResult;\r\n        addResult(currentResult, row, false);\r\n    }\r\n\r\n    addResult((roundTime / 10) + 'ms', row, true);\r\n}\r\n```\r\n\r\n## Resultados\r\n\r\nUna vez ejecutadas nuestras tres funciones de pruebas, se obtienen los siguientes resultados:\r\n\r\n| Función | Paso 1 | Paso 2 | Paso 3 | Paso 4 | Paso 5 | Paso 6 | Paso 7 | Paso 8 | Paso 9 | Paso 10 | Media  |\r\n| ------- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------- | ------ |\r\n| 1       | 824    | 816    | 819    | 815    | 810    | 810    | 816    | 816    | 812    | 811     | 814.9  |\r\n| 2       | 2876   | 2767   | 2763   | 2760   | 2771   | 2774   | 2968   | 3102   | 3006   | 2941    | 2872.8 |\r\n| 3       | 152    | 164    | 163    | 163    | 164    | 161    | 164    | 165    | 166    | 162     | 162.4  |\r\n| 4       | 655    | 666    | 656    | 663    | 663    | 657    | 666    | 668    | 661    | 673     | 662.8  |\r\n\r\nTras las pruebas, se observa una clara vencedora, la función 3 de concatenación en una instrucción, ya que es casi 8 veces más rápida que la función 1, y 25 veces más rápida que la función 2. El único inconveniente es que sólo podemos usarla cuando conozcamos de antemano todos los valores a concatenar, si no es así, tendremos que utilizar la función 1. Finalmente, el uso de interpolación que admite ES6, ofrece un mejor rendimiento que la función 1, pero al igual que la 3 sigue teniendo el problema de requerir conocer el número de parámetros.\r\n\r\n---\r\n\r\n**Enlaces**\r\n\r\n- Función 1 en JSFiddle\r\n- Función 2 en JSFiddle\r\n- Función 3 en JSFiddle\r\n- Función 4 en JSFiddle",
    "url": "/articles/posts/20160714.html",
    "date": "2016-07-14",
    "categories": [
      "Programación",
      "JavaScript"
    ],
    "content": "La concatenación de cadenas es una de las operaciones que con más frecuencia se repiten en los desarrollos de aplicaciones. Es por ello, realizar dicha operación de forma óptima incrementará el rendimiento y disminuirá el uso de recursos de nuestra aplicación. En este banco de pruebas vamos a observar cuatro funciones distintas para realizar concatenar y descubrir cuál es la más rápida. Función 1. Concatenación por instrucción En esta primera función, se irá concatenando en cada instrucción una cadena. Se presenta el problema que así se genera una cadena nueva en cada concatenación, lo que provoca un mayor consumo de memoria. Pero presenta la ventaja de que no es necesario conocer de antemano cuantas cadenas intervienen en la operación. Función 2. Concatenación con arrays En varios artículos y libros he llegado a leer que una alternativa al uso de concatenación estándar, es ir añadiendo cadenas a un array y luego realizar una operación join() con cadena vacía. Como se observará en los resultados, esta operación es la más lenta. Función 3. Concatenación en una instrucción En esta ocasión, se realizan todas las operaciones de concatenación en una única instrucción. Claro para esta alternativa es necesario conocer de antemano cuales son las variables y cadenas a concatenar, pero es sin lugar a dudas la más rápida. Función 4. Interpolación de cadenas En el estándar ES6 se ha incluido la interpolación de cadenas, esto es, que se pueden introducir valores de variables dentro de una cadena (lo veremos en profundidad en un futuro artículo). En esta ocasión el rendimiento es más rápido que la función 1, pero recordad que hay que revisar la compatibilidad con todos los navegadores. La batería de pruebas El código para todas las pruebas será el mismo, por un lado tendremos un HTML muy básico que mostrará una tabla de resultados: Por otro lado, el código de pruebas también es muy sencillo. Consiste en una función que realiza un bucle de 10 pasos, en el que en cada paso se llama diez millones de veces a la función encargada de concatenar las cinco cadenas. Por otro lado, se dispone de una función con la que se añade cada resultado a la tabla HTML (Se podría haber mostrado por consola simplemente, pero así queda más visual). Resultados Una vez ejecutadas nuestras tres funciones de pruebas, se obtienen los siguientes resultados: Función Paso 1 Paso 2 Paso 3 Paso 4 Paso 5 Paso 6 Paso 7 Paso 8 Paso 9 Paso 10 Media 1 824 816 819 815 810 810 816 816 812 811 814.9 2 2876 2767 2763 2760 2771 2774 2968 3102 3006 2941 2872.8 3 152 164 163 163 164 161 164 165 166 162 162.4 4 655 666 656 663 663 657 666 668 661 673 662.8 Tras las pruebas, se observa una clara vencedora, la función 3 de concatenación en una instrucción, ya que es casi 8 veces más rápida que la función 1, y 25 veces más rápida que la función 2. El único inconveniente es que sólo podemos usarla cuando conozcamos de antemano todos los valores a concatenar, si no es así, tendremos que utilizar la función 1. Finalmente, el uso de interpolación que admite ES6, ofrece un mejor rendimiento que la función 1, pero al igual que la 3 sigue teniendo el problema de requerir conocer el número de parámetros. Enlaces Función 1 en JSFiddle Función 2 en JSFiddle Función 3 en JSFiddle Función 4 en JSFiddle",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20160707.html",
    "title": "Internacionalización en ES6 2: La clase DateTimeFormat",
    "description": "En nuestro artículo anterior, aprendimos en qué consiste el namespace **Intl** y las ventajas que ofrece el uso de las clases que contiene, centrándonos en la clase `Collator`. En este artículo, aprenderemos a trabajar con fechas internacionalizadas mediante el uso de la clase `DateTimeFormat`.\r\n\r\n## DateTimeFormat\r\n\r\nComo indicamos anteriormente, gracias al objeto `Intl.DateTimeFormat` podremos construir objetos que nos permitirán trabajar con fechas internacionalizadas. Su sintaxis básica es la siguiente:\r\n\r\n```javascript\r\nconst local = 'es-ES';\r\nconst options = {};\r\nconst dateTime = new Intl.DateTimeFormat(local, options);\r\n\r\n// Para el 29 de junio de 2016, la salida será: 29/6/2016\r\nconsole.log(dateTime.format(new Date());\r\n```\r\n\r\n- `local`: parámetro obligatorio que será una cadena o array de cadenas con el idioma en formato BCP 47.\r\n- `options`: parámetro opcional en el que se especifica una serie de opciones para aplicar el formato de fecha que veremos en el apartado siguiente.\r\n\r\nTras observar el ejemplo anterior, os preguntaréis, en qué se diferencia de los métodos `toLocaleDateString` y `toLocaleString` del objeto Date, pues prácticamente ninguna, lo único que con el uso de Intl, ahorraremos pasar idioma y opciones con cada llamada, ya que lo podemos inicializar durante el arranque de la aplicación o cuando sea necesario cambiar la configuración regional. Sin embargo, cada llamada a `toLocaleDateString` requiere el paso de los dos parámetros, además de relanzarse el parseo de la configuración indicada.\r\n\r\nPensad por ejemplo, que tenéis en una aplicación 20 fechas en 20 sitios distintos y que además al formatear se le aplica alguna opción especial. Habría que repetir 20, la llamada exacta, por ejemplo:\r\n\r\n```javascript\r\nconst dateOptions = {\r\n  weekday: \"long\",\r\n  year: \"numeric\",\r\n  month: \"long\"\r\n};\r\nconst language = 'es-ES';\r\n\r\n// ...\r\n\r\n// Con cada instancia de una fecha, al querer \"imprimirla\" tendríamos:\r\nmyDate.toLocaleDateString(language, dateOptions);\r\n```\r\n\r\nCon el ejemplo anterior, siempre tendríamos que tener presentes las opciones así como el idioma, en cuanto uno de los dos se perdieran o se obviaran, una de las fechas no tendría el formato adecuado. Sin embargo, con `DateTimeFormat`, tendríamos centralizada la conversión de fechas:\r\n\r\n```javascript\r\nconst options = {\r\n  weekday: \"long\",\r\n  year: \"numeric\",\r\n  month: \"long\"\r\n};\r\nconst language = 'es-ES',\r\nconst dateConverter = new Intl.DateTimeFormat(language, options);\r\n\r\n...\r\n\r\n// Ahora con cada instancia, tan sólo llamaríamos a:\r\ndateConverter.format(myDate);\r\n```\r\n\r\nAhora hemos pasado de requerir dos objetos, a sólo uno, quedando además mucho más legible el código. Y no sólo eso, sino que creando alguna función para centralizar la conversión, se podría cambiar la configurar de formato y todo seguiría funcionando correctamente con el nuevo formato.\r\n\r\n## El atributo options\r\n\r\nEl atributo options, es un objeto con el que indicamos a la case DateTimeFormat el formato de la cadena de salida. A continuación indicaremos algunas de las opciones más comunes, partiendo de la base siguiente:\r\n\r\n```javascript\r\n// Al instanciar la fecha tenemos que su valor es:\r\n// Thu Jul 07 2016 21:26:48 GMT+0200 (Hora de verano romance)\r\nconst date = new Date();\r\n```\r\n\r\n### weekday\r\n\r\nIndica la representación que se utilizará para mostrar el nombre del día de la semana. Sus valores son: \"narrow\", \"short\" o \"long\".\r\n\r\n```javascript\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {weekday: 'narrow'});\r\ndateFormat.format(date); // Salida: J\r\n\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {weekday: 'short'});\r\ndateFormat.format(date); // Salida: jue.\r\n\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {weekday: 'long'});\r\ndateFormat.format(date); // Salida: jueves\r\n```\r\n\r\n### hour12\r\n\r\nIndica si se utiliza el formato de 12 horas, en lugar del formato de 24 horas. Es un valor booleano, por lo que sus posibles valores son `true` y `false`.\r\n\r\n```javascript\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {hour12: true, hour: 'numeric'});\r\ndateFormat.format(date); // Salida: 9 p. m.\r\n\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {hour12: false, hour: 'numeric'});\r\ndateFormat.format(date); // Salida: 21\r\n```\r\n\r\n### year\r\n\r\nIndica el tipo de representación utilizado para el año, siendo sus posibles valores: \"numeric\" y \"2-digit\".\r\n\r\n```javascript\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {year: 'numeric'});\r\ndateFormat.format(date); // Salida: 2016\r\n\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {year: '2-digit'});\r\ndateFormat.format(date); // Salida: 16\r\n```\r\n\r\n### month\r\n\r\nFormato que se utilizará para representar el mes. Los valores a utilizar serían: \"numeric\", \"2-digit\", \"narrow\", \"short\" y \"long\".\r\n\r\n```javascript\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {month: 'numeric'});\r\ndateFormat.format(date); // Salida: 7\r\n\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {month: '2-digit'});\r\ndateFormat.format(date); // Salida: 07\r\n\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {month: 'narrow'});\r\ndateFormat.format(date); // Salida: J\r\n\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {month: 'short'});\r\ndateFormat.format(date); // Salida: jul.\r\n\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {month: 'long'});\r\ndateFormat.format(date); // Salida: julio\r\n```\r\n\r\n### day\r\n\r\nCon este parámetro se indica como se mostrará el día del mes, siendo sus posibles valores: \"numeric\" y \"2-digit\".\r\n\r\n```javascript\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {day: 'numeric'});\r\ndateFormat.format(date); // Salida: 7\r\n\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {day: '2-digit'});\r\ndateFormat.format(date); // Salida: 07\r\n```\r\n\r\n### hour\r\n\r\nCon este parámetro se especifica que formato tendrá la hora. Los valores que puede tomar son: \"numeric\" y \"2-digit\".\r\n\r\n```javascript\r\n// En este caso suponemos que la hora tiene el valor 9.\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {hour: 'numeric'});\r\ndateFormat.format(date); // Salida: 9\r\n\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {hour: '2-digit'});\r\ndateFormat.format(date); // Salida: 09\r\n```\r\n\r\n### minute\r\n\r\nRepresentación que se utilizará para mostrar los minutos. Sus valores son: \"numeric\" y \"2-digit\".\r\n\r\n```javascript\r\n// Suponemos que los minutos son 7.\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {minute: 'numeric'});\r\ndateFormat.format(date); // Salida: 7\r\n\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {minute: '2-digit'});\r\ndateFormat.format(date); // Salida: 07\r\n```\r\n\r\n### second\r\n\r\nPara terminar, este parámetro especifica el formato de los segundos. Sus valores son: \"numeric\" y \"2-digit\".\r\n\r\n```javascript\r\n// Suponemos que los segundos son 4.\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {second: 'numeric'});\r\ndateFormat.format(date); // Salida: 4\r\n\r\ndateFormat = new Intl.DateTimeFormat('es-ES', {second: '2-digit'});\r\ndateFormat.format(date); // Salida: 04\r\n```\r\n\r\n## Ejemplos\r\n\r\nComo se ha observado en los ejemplos anteriores, si sólo se especifica un parámetros, será el único que devolverá format. Pero se puede realizar cualquier combinación, como se puede observar en los ejemplos siguientes:\r\n\r\n```javascript\r\n// Se parte de la fecha:\r\n// Thu Jul 07 2016 21:26:48 GMT+0200 (Hora de verano romance)\r\nconst date = new Date();\r\n\r\nlet options = {\r\n  weekday: 'long',\r\n  month: 'short',\r\n  day: '2-digit',\r\n  year: '2-digit'\r\n};\r\n\r\nlet dateFormat = new Intl.DateTimeFormat('es-ES', options);\r\ndateFormat.format(date); // Salida: jueves, 07 de jul. de 16\r\n\r\noptions = {\r\n    weekday: 'short',\r\n    month: 'long',\r\n    day: '2-digit',\r\n    year: 'numeric',\r\n    hour: '2-digit',\r\n    minute: 'numeric'\r\n};\r\n\r\ndateFormat = new Intl.DateTimeFormat('es-ES', options);\r\ndateFormat.format(date); // Salida: jue., 07 de julio de 2016 21:26\r\n```\r\n\r\n## Compatibilidad\r\n\r\n| Tipo       | Android | Chrome | Edge  | Firefox | IE | Opera | Safari |\r\n| ---------- | ------- | ------ | ----- | ------- | -- | ----- | ------ |\r\n| Escritorio | N/A     | 24     | Todas | 29      | 11 | 15    | No     |\r\n| Móvil      | No      | 26     | N/A   | No      | No | No    | No     |\r\n\r\n---\r\n\r\nEnlaces de interés\r\n\r\n- Descripción de la clase en MDN\r\n- Internacionalización en ES6 1: La clase Collator",
    "url": "/articles/posts/20160707.html",
    "date": "2016-07-07",
    "categories": [
      "Programación",
      "JavaScript"
    ],
    "content": "En nuestro artículo anterior , aprendimos en qué consiste el namespace Intl y las ventajas que ofrece el uso de las clases que contiene, centrándonos en la clase Collator . En este artículo, aprenderemos a trabajar con fechas internacionalizadas mediante el uso de la clase DateTimeFormat . DateTimeFormat Como indicamos anteriormente, gracias al objeto Intl.DateTimeFormat podremos construir objetos que nos permitirán trabajar con fechas internacionalizadas. Su sintaxis básica es la siguiente: local : parámetro obligatorio que será una cadena o array de cadenas con el idioma en formato BCP 47 . options : parámetro opcional en el que se especifica una serie de opciones para aplicar el formato de fecha que veremos en el apartado siguiente. Tras observar el ejemplo anterior, os preguntaréis, en qué se diferencia de los métodos toLocaleDateString y toLocaleString del objeto Date, pues prácticamente ninguna, lo único que con el uso de Intl, ahorraremos pasar idioma y opciones con cada llamada, ya que lo podemos inicializar durante el arranque de la aplicación o cuando sea necesario cambiar la configuración regional. Sin embargo, cada llamada a toLocaleDateString requiere el paso de los dos parámetros, además de relanzarse el parseo de la configuración indicada. Pensad por ejemplo, que tenéis en una aplicación 20 fechas en 20 sitios distintos y que además al formatear se le aplica alguna opción especial. Habría que repetir 20, la llamada exacta, por ejemplo: Con el ejemplo anterior, siempre tendríamos que tener presentes las opciones así como el idioma, en cuanto uno de los dos se perdieran o se obviaran, una de las fechas no tendría el formato adecuado. Sin embargo, con DateTimeFormat , tendríamos centralizada la conversión de fechas: Ahora hemos pasado de requerir dos objetos, a sólo uno, quedando además mucho más legible el código. Y no sólo eso, sino que creando alguna función para centralizar la conversión, se podría cambiar la configurar de formato y todo seguiría funcionando correctamente con el nuevo formato. El atributo options El atributo options, es un objeto con el que indicamos a la case DateTimeFormat el formato de la cadena de salida. A continuación indicaremos algunas de las opciones más comunes, partiendo de la base siguiente: weekday Indica la representación que se utilizará para mostrar el nombre del día de la semana. Sus valores son: &quot;narrow&quot;, &quot;short&quot; o &quot;long&quot;. hour12 Indica si se utiliza el formato de 12 horas, en lugar del formato de 24 horas. Es un valor booleano, por lo que sus posibles valores son true y false . year Indica el tipo de representación utilizado para el año, siendo sus posibles valores: &quot;numeric&quot; y &quot;2-digit&quot;. month Formato que se utilizará para representar el mes. Los valores a utilizar serían: &quot;numeric&quot;, &quot;2-digit&quot;, &quot;narrow&quot;, &quot;short&quot; y &quot;long&quot;. day Con este parámetro se indica como se mostrará el día del mes, siendo sus posibles valores: &quot;numeric&quot; y &quot;2-digit&quot;. hour Con este parámetro se especifica que formato tendrá la hora. Los valores que puede tomar son: &quot;numeric&quot; y &quot;2-digit&quot;. minute Representación que se utilizará para mostrar los minutos. Sus valores son: &quot;numeric&quot; y &quot;2-digit&quot;. second Para terminar, este parámetro especifica el formato de los segundos. Sus valores son: &quot;numeric&quot; y &quot;2-digit&quot;. Ejemplos Como se ha observado en los ejemplos anteriores, si sólo se especifica un parámetros, será el único que devolverá format. Pero se puede realizar cualquier combinación, como se puede observar en los ejemplos siguientes: Compatibilidad Tipo Android Chrome Edge Firefox IE Opera Safari Escritorio N/A 24 Todas 29 11 15 No Móvil No 26 N/A No No No No Enlaces de interés Descripción de la clase en MDN Internacionalización en ES6 1: La clase Collator",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20160702.html",
    "title": "Benckmark: redondear un número a decenas en JavaScript",
    "description": "En ocasiones puede que necesitemos redondear un número entero a su valor en decenas (también se podría aplicar a centenas, miles, etc). Por ejemplo, en mi caso, fue necesario para generar un calendario y pasar del año actual a su década correspondiente.\r\n\r\nEn este artículo veremos cuatro funciones JavaScript para realizar dicha operación y cuál nos ofrece mejores resultados.\r\n\r\n## Función 1. Multiplicación y división\r\n\r\nEsta primera función se **divide** el número entre 10, posteriormente se **convierte a entero** (por lo que se pierde la unidad que habría quedado en la parte decimal) y finalmente se **multiplica** por 10 para obtener el valor redondeado.\r\n\r\n```javascript\r\nfunction round(value) {\r\n    return parseInt(value / 10) * 10;\r\n}\r\n```\r\n\r\n## Función 2. Resto\r\n\r\nEn este caso, se calculará el **resto** sobre 10 del valor indicado **restándose** al valor original. De esta forma, puesto que obtenemos el valor de unidad lo podremos restar al número original.\r\n\r\n```javascript\r\nfunction round(value) {\r\n    return value - (value % 10);\r\n}\r\n```\r\n\r\n## Función 3. Redondeo con Math\r\n\r\nLa última función es parecida a la primera, pero en lugar de pasar a entero el valor, realiza un **redondeo** usando la librería **Math** para posteriormente **multiplicar** por 10. Curiosamente, pese a utilizar la librería Math y tener una condición en su interior, pudiera parecer que es más lenta que la primera opción, pero os sorprenderá el resultado.\r\n\r\n```javascript\r\nfunction round(value) {\r\n    if (0 > value) {\r\n        return Math.ceil(value / 10) * 10;\r\n    }\r\n    return Math.floor(value / 10) * 10;\r\n}\r\n```\r\n\r\n## Función 4. Uso de cadenas\r\n\r\nAlgunas personas están cómodas con el uso de cadenas, pero supone una gran penalización de rendimiento. En esta función, se **convierte** a cadena el valor, se **suprime** el último carácter y finalmente se **concatena el 0**, realizando un parseo a entero. El resultado es nefasto como podréis observar en la tabla de tiempos.\r\n\r\n```javascript\r\nfunction round(value) {\r\n    return parseInt(('' + value).slice(0, -1) + '0');\r\n}\r\n```\r\n\r\n## La batería de pruebas\r\n\r\nEl código para todas las pruebas será el mismo, por un lado tendremos un HTML muy básico que mostrará una tabla de resultados:\r\n\r\n```html\r\n\r\n    \r\n        Results\r\n    \r\n\r\n```\r\n\r\nPor otro lado, el código de pruebas también es muy sencillo. Consiste en una función que realiza un bucle de 10 pasos, en el que en cada paso se llama un millón de veces a la función encargada de redondear con valores comprendidos entre -500.000 y 500.000. Por otro lado, se dispone de una función con la que se añade cada resultado a la tabla HTML (Se podría haber mostrado por consola simplemente, pero así queda más visual).\r\n\r\n```javascript\r\nfunction addResult(value, row, last) {\r\n    var node = document.createElement(last ? 'th' : 'td'),\r\n        textnode = document.createTextNode(value);\r\n\r\n    node.appendChild(textnode);\r\n    row.appendChild(node);\r\n}\r\n\r\nfunction test() {\r\n    var roundTime = 0,\r\n        row = document.getElementById('data'),\r\n        lap, startTime, i, endTime, currentResult;\r\n\r\n    for (lap = 0; lap < 10; ++lap) {\r\n        startTime = new Date();\r\n        for (i = 0; i < 10000000; ++i) {\r\n            round(-5000000 + i);\r\n        }\r\n        endTime = new Date();\r\n\r\n        currentResult = endTime.getTime() - startTime.getTime()\r\n        roundTime += currentResult;\r\n        addResult(currentResult, row, false);\r\n    }\r\n\r\n    addResult((roundTime / 10) + 'ms', row, true);\r\n}\r\n\r\ntest();\r\n```\r\n\r\n## Resultados\r\n\r\nTras ejecutar el código anterior con cada función de redondeo, los resultados han sido los siguientes (los valores son en milisegundos):\r\n\r\n| Función | Paso 1 | Paso 2 | Paso 3 | Paso 4 | Paso 5 | Paso 6 | Paso 7 | Paso 8 | Paso 9 | Paso 10 | Media  |\r\n| ------- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------- | ------ |\r\n| 1       | 184    | 183    | 175    | 172    | 171    | 175    | 174    | 180    | 171    | 178     | 176.3  |\r\n| 2       | 10     | 10     | 7      | 7      | 7      | 7      | 6      | 7      | 7      | 7       | 7.5    |\r\n| 3       | 102    | 99     | 94     | 92     | 94     | 94     | 95     | 93     | 95     | 93      | 95.1   |\r\n| 4       | 3284   | 3584   | 4267   | 3562   | 3790   | 4114   | 3947   | 3558   | 3461   | 3765    | 3733.2 |\r\n\r\nEn conclusión, como se puede observar, a la hora de redondear tenemos una clara vencedora. El uso de la función 2, con cálculo de resto, es más de 20 veces más rápida que la función 1 y 10 veces más rápida que la función 3. No hace falta decir, que el uso de cadenas para realizar esta operación no es nada aconsejable, teniendo una media de 3.7 segundos por paso.\r\n\r\nSeguro que conocéis algún otro método para realizar esta operación, así que no dudéis en compartirla en los comentarios.\r\n\r\n---\r\n\r\n**Enlaces**\r\n\r\n- Método 1 en JSFiddle\r\n- Método 2 en JSFiddle\r\n- Método 3 en JSFiddle\r\n- Método 4 en JSFiddle",
    "url": "/articles/posts/20160702.html",
    "date": "2016-07-02",
    "categories": [
      "Programación",
      "JavaScript"
    ],
    "content": "En ocasiones puede que necesitemos redondear un número entero a su valor en decenas (también se podría aplicar a centenas, miles, etc). Por ejemplo, en mi caso, fue necesario para generar un calendario y pasar del año actual a su década correspondiente. En este artículo veremos cuatro funciones JavaScript para realizar dicha operación y cuál nos ofrece mejores resultados. Función 1. Multiplicación y división Esta primera función se divide el número entre 10, posteriormente se convierte a entero (por lo que se pierde la unidad que habría quedado en la parte decimal) y finalmente se multiplica por 10 para obtener el valor redondeado. Función 2. Resto En este caso, se calculará el resto sobre 10 del valor indicado restándose al valor original. De esta forma, puesto que obtenemos el valor de unidad lo podremos restar al número original. Función 3. Redondeo con Math La última función es parecida a la primera, pero en lugar de pasar a entero el valor, realiza un redondeo usando la librería Math para posteriormente multiplicar por 10. Curiosamente, pese a utilizar la librería Math y tener una condición en su interior, pudiera parecer que es más lenta que la primera opción, pero os sorprenderá el resultado. Función 4. Uso de cadenas Algunas personas están cómodas con el uso de cadenas, pero supone una gran penalización de rendimiento. En esta función, se convierte a cadena el valor, se suprime el último carácter y finalmente se concatena el 0 , realizando un parseo a entero. El resultado es nefasto como podréis observar en la tabla de tiempos. La batería de pruebas El código para todas las pruebas será el mismo, por un lado tendremos un HTML muy básico que mostrará una tabla de resultados: Por otro lado, el código de pruebas también es muy sencillo. Consiste en una función que realiza un bucle de 10 pasos, en el que en cada paso se llama un millón de veces a la función encargada de redondear con valores comprendidos entre -500.000 y 500.000. Por otro lado, se dispone de una función con la que se añade cada resultado a la tabla HTML (Se podría haber mostrado por consola simplemente, pero así queda más visual). Resultados Tras ejecutar el código anterior con cada función de redondeo, los resultados han sido los siguientes (los valores son en milisegundos): Función Paso 1 Paso 2 Paso 3 Paso 4 Paso 5 Paso 6 Paso 7 Paso 8 Paso 9 Paso 10 Media 1 184 183 175 172 171 175 174 180 171 178 176.3 2 10 10 7 7 7 7 6 7 7 7 7.5 3 102 99 94 92 94 94 95 93 95 93 95.1 4 3284 3584 4267 3562 3790 4114 3947 3558 3461 3765 3733.2 En conclusión, como se puede observar, a la hora de redondear tenemos una clara vencedora. El uso de la función 2, con cálculo de resto, es más de 20 veces más rápida que la función 1 y 10 veces más rápida que la función 3. No hace falta decir, que el uso de cadenas para realizar esta operación no es nada aconsejable, teniendo una media de 3.7 segundos por paso. Seguro que conocéis algún otro método para realizar esta operación, así que no dudéis en compartirla en los comentarios. Enlaces Método 1 en JSFiddle Método 2 en JSFiddle Método 3 en JSFiddle Método 4 en JSFiddle",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20160623.html",
    "title": "Internacionalización en ES6 1: La clase Collator",
    "description": "Durante los próximos artículos iremos descubriendo que nos ofrecerá ES6 (EcmaScript 6, o JavaScript 6 para los amigos), analizando las novedades y cambios que la nueva versión del lenguaje nos ofrecerá, así como su estado actual de integración en los principales navegadores. En este primer artículo aprenderemos sobre el namespace global `Intl` y la clase `Collator`.",
    "url": "/articles/posts/20160623.html",
    "date": "2016-06-23",
    "categories": [
      "Programación",
      "JavaScript"
    ],
    "content": "Durante los próximos artículos iremos descubriendo que nos ofrecerá ES6 (EcmaScript 6, o JavaScript 6 para los amigos), analizando las novedades y cambios que la nueva versión del lenguaje nos ofrecerá, así como su estado actual de integración en los principales navegadores. En este primer artículo aprenderemos sobre el namespace global Intl y la clase Collator . El namespace Intl Cuando se desarrolla una web, hasta ahora si teníamos que internacionalizarla había diversos problemas que se debían resolver creando funciones específicas o mediante el uso de librerías destinadas a tal fin. Sin embargo, la próxima versión de ES, tiende una mano a los desarrolladores y desarrolladoras para hacernos la vida más fácil, todo mediante la inclusión de Intl . Este objeto se utiliza para lo que se conoce como ECMAScript Internationalization API , que proporciona comparación de cadenas dependiendo del idioma, formato para números, así como para fecha y hora, etc. Los constructores para los objetos Collator , NumberFormat , y DateTimeFormat son propiedades del namespace Intl . La clase Collator Hasta ahora al intentar ordenar cadenas, teníamos el problema de que para ese orden no se tenía en cuenta el idioma, por lo que por ejemplo, obteníamos resultados como el siguiente. Como podemos observar, aunque la ñ en nuestro alfabeto se encuentra tras la letra n , el orden por defecto de ES, la sitúa al final. La clase Collator viene a resolver dicho problema, ya que una vez que le indiquemos el idioma a utilizar, realizará el orden correcto, si la pasamos como argumento a la función sort() . Su sintaxis es la siguiente: El primer parámetro del constructor es el idioma a utilizar, el cual se especifica mediante una cadena con formato BCP 47 . El segundo son una serie de opciones a utilizar. Normalmente lo utilizaremos como método de ordenación en los arrays. A continuación podéis ver un ejemplo de uso. En MDN podrás consultar más información sobre ésta útil clase.",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20130725.html",
    "title": "Problemas de secuencias PostgreSQL con Hibernate",
    "description": "Por desgracia, en versiones antiguas de Hibernate no suelen funcionar los valores secuenciales de forma correcta con PostgreSQL. Pero tenemos una solución, y es que podemos obtener el identificador de forma manual. Para ello se creará el método siguiente:",
    "url": "/articles/posts/20130725.html",
    "date": "2013-07-25",
    "categories": [
      "Programación",
      "Java",
      "PostgreSQL",
      "JPA",
      "Hibernate"
    ],
    "content": "Por desgracia, en versiones antiguas de Hibernate no suelen funcionar los valores secuenciales de forma correcta con PostgreSQL. Pero tenemos una solución, y es que podemos obtener el identificador de forma manual. Para ello se creará el método siguiente: El método anterior lo que hace es recibir el nombre de una secuencia, obtener el número siguiente e incrementarla. De esta forma el valor obtenido será el auto numérico que vamos a utilizar. Ahora que tenemos nuestro nuevo número de secuencia, lo podremos utilizar de la forma siguiente: Ya tenemos de una forma muy sencilla solucionado nuestro problema de secuencias.",
    "imageMini": "/images/java-mini.png"
  },
  {
    "slug": "20130711.html",
    "title": "Enlaces simbólicos en Java",
    "description": "En ocasiones al trabajar con ficheros en una aplicación, es necesario saber si son enlaces simbólicos o ficheros \"estándar\" Por ello, hoy vamos a ver un conjunto de métodos que nos facilitarán la vida a la hora de trabajar con enlaces simbólicos en Java.\r\n\r\n## Saber si un fichero es enlace simbólico\r\n\r\nComenzamos con el código de un método encargado de conocer si un fichero es un enlace simbólico.\r\n\r\n```java\r\n/**\r\n * Obtiene un valor booleano que indica si el fichero recibido es un enlace\r\n * simbólico.\r\n * @param  file  Fichero a analizar.\r\n * @return Valor booleano que indica si el fichero recibido es un enlace\r\n *         simbólico.\r\n * @throws IOException  Lanzada cuando no se puede acceder al fichero.\r\n * @throws NullPointerException  Si el valor recibido es nulo.\r\n */\r\npublic static boolean isSymLink(final File file)\r\n                               throws IOException, NullPointerException {\r\n  File canonical;\r\n\r\n  if (file.getParent() == null) {\r\n    canonical = file;\r\n  } else {\r\n    File canonDir = file.getParentFile().getCanonicalFile();\r\n    canonical = new File(canonDir, file.getName());\r\n  }\r\n\r\n  return !canonical.getCanonicalFile().equals(canonical.getAbsoluteFile()); \r\n}\r\n```\r\n\r\nEn el código anterior lo único que hacemos es comprobar si el fichero \"real\" que estamos manejando es el mismo fichero al que apuntamos. Nada más sencillo.\r\n\r\n## Conocer el destino del enlace\r\n\r\nAhora pasemos a ver el segundo método que nos dará el fichero o directorio al que apunta un enlace simbólico:\r\n\r\n```java\r\n/**\r\n * Obtiene una cadena que indica el destino de un enlace simbólico.\r\n * @param  file  Nombre del fichero a analizar.\r\n * @return Cadena con el destino de un enlace simbólico o null si el\r\n *         fichero no es un enlace o hubo un problema en la lectura del\r\n *         fichero.\r\n * @throws IOException  Lanzada cuando no se puede acceder al fichero.\r\n * @throws NullPointerException  Si el valor recibido es nulo.\r\n */\r\npublic static String getSymDestination(final File file)\r\n                                      throws NullPointerException, IOException {\r\n  String destination = null;\r\n\r\n  if (isSymLink(file)) {\r\n    File canonical;\r\n\r\n    if (file.getParent() == null) {\r\n      canonical = file;\r\n    } else {\r\n      final File canonDir = file.getParentFile().getCanonicalFile();\r\n      canonical = new File(canonDir, file.getName());\r\n    }\r\n\r\n    destination = canonical.getCanonicalFile().getCanonicalPath();\r\n  }\r\n\r\n  return destination;\r\n}\r\n```\r\n\r\nAquí, como se ha observado ver lo que se hace es parecido al primer método, pero en este caso se devuelve la ruta canónica, es decir, la ruta real del fichero apuntado.\r\n\r\nComo extra, los dos métodos anteriores, se pueden completar con otros dos homónimos para tener sobrecarga de operadores:\r\n\r\n```java\r\npublic static boolean isSymLink(final String file)\r\n                               throws NullPointerException, IOException {\r\n  return isSymLink(new File(file));\r\n}\r\n\r\npublic static String getSymDestination(final String file)\r\n                                      throws NullPointerException, IOException {\r\n  return getSymDestination(new File(file));\r\n}\r\n```\r\n\r\nTrabajando con los dos métodos vistos en este artículo, por un lado de podrá conocer si un fichero es un enlace simbólico con el método `isSymLink`, en cuyo caso se puede conocer el destino del enlace con `getSymDistination`.",
    "url": "/articles/posts/20130711.html",
    "date": "2013-07-11",
    "categories": [
      "Programación",
      "Java"
    ],
    "content": "En ocasiones al trabajar con ficheros en una aplicación, es necesario saber si son enlaces simbólicos o ficheros &quot;estándar&quot; Por ello, hoy vamos a ver un conjunto de métodos que nos facilitarán la vida a la hora de trabajar con enlaces simbólicos en Java. Saber si un fichero es enlace simbólico Comenzamos con el código de un método encargado de conocer si un fichero es un enlace simbólico. En el código anterior lo único que hacemos es comprobar si el fichero &quot;real&quot; que estamos manejando es el mismo fichero al que apuntamos. Nada más sencillo. Conocer el destino del enlace Ahora pasemos a ver el segundo método que nos dará el fichero o directorio al que apunta un enlace simbólico: Aquí, como se ha observado ver lo que se hace es parecido al primer método, pero en este caso se devuelve la ruta canónica, es decir, la ruta real del fichero apuntado. Como extra, los dos métodos anteriores, se pueden completar con otros dos homónimos para tener sobrecarga de operadores: Trabajando con los dos métodos vistos en este artículo, por un lado de podrá conocer si un fichero es un enlace simbólico con el método isSymLink , en cuyo caso se puede conocer el destino del enlace con getSymDistination .",
    "imageMini": "/images/java-mini.png"
  },
  {
    "slug": "20130607.html",
    "title": "C/C++: Texto de consola con formato",
    "description": "La consola (o terminal) de Linux/Unix admite diferentes formatos de carácter como negrita, subrayado, colores, etc. Para aplicar los formatos hemos desarrollado una función que junto con una enumeración nos permitirá de forma sencilla aplicar formato a nuestros textos por consola. A continuación podéis ver el código común a las dos funciones:\r\n\r\n```cpp\r\n// Carácter de escape para aplicar los estilos.\r\n#define CHAR_ESC    (char) 27\r\n// Tamaño mínimo de la cadena de formato.\r\n#define FORMAT_SIZE 10\r\n\r\n// Enumeración con los formato de texto a aplicar.\r\ntypedef enum {\r\n  FRM_NORMAL = 0,     // Texto con formato normal.\r\n  FRM_BOLD,           // Texto en negrita.\r\n  FRM_DARK,           // Texto oscurecido.\r\n  FRM_UNDERLINE = 4,  // Texto subyarado.\r\n  FRM_REVERSE = 7,    // Texto seleccionado.\r\n  FRM_STRIKED = 9,    // Texto tachado.\r\n  FRM_BLACK = 30,     // Texto de color negro.\r\n  FRM_RED,            // Texto de color rojo.\r\n  FRM_GREEN,          // Texto de color verde.\r\n  FRM_YELLOW,         // Texto de color amarillo.\r\n  FRM_BLUE,           // Texto de color azul.\r\n  FRM_MAGENTA,        // Texto de color magenta.\r\n  FRM_CYAN,           // Texto de color ciano.\r\n  FRM_WHITE,          // Texto de color blanco.\r\n  FRM_BACK_RED = 41,  // Color de fondo rojo.\r\n  FRM_BACK_GREEN,     // Color de fondo verde.\r\n  FRM_BACK_YELLOW,    // Color de fondo amarillo.\r\n  FRM_BACK_BLUE,      // Color de fondo azul.\r\n  FRM_BACK_MAGENTA,   // Color de fondo magenta.\r\n  FRM_BACK_CYAN,      // Color de fondo ciano.\r\n  FRM_BACK_GREY       // Color de fondo gris.\r\n} strformat;\r\n```\r\n\r\nEn el código superior se definen las constantes a utilizar en las funciones. La enumeración strformat contiene los valores de formato que se pueden aplicar. Esta parte no tiene más misterios, pasemos ahora a ver la función de formato para C estándar:\r\n\r\n```cpp\r\n/**\r\n * Establece el formato de texto a partir del valor recibido.\r\n * @param  formato  Formato de texto a aplicar.\r\n * @param  cadena   Cadena en la que escribir el formato.\r\n * @param  tam      Tamaño de la cadena de formato.\r\n * @return Cadena con el formato aplicado.\r\n */\r\nchar * strFormat(const strformat formato, char * cadena, size_t tam) {\r\n  if (cadena && tam >= FORMAT_SIZE) {\r\n    snprintf(cadena, tam, \"%c[%im\", CHAR_ESC, formato);\r\n  }\r\n\r\n  return cadena;\r\n}\r\n```\r\n\r\nLa función de C, devuelve el mismo array que recibe de esta forma podemos utilizarla dentro de funciones como `printf()` sin problemas de estar llenando la memoria de elementos duplicados. Como podéis observar, el código de la función es muy sencillo, tan sólo se limita a imprimir el carácter de escape y a continuación el código de formato. Tan sólo nos queda ver un ejemplo de su uso:\r\n\r\n```cpp\r\n  ...\r\n  char arcFormato[FORMAT_SIZE];\r\n\r\n  printf(\"Este es un %s\", strFormat2(FRM_BLUE, arcFormato, sizeof(arcFormato)));\r\n  printf(\"text%sto \", strFormat2(FRM_UNDERLINE, arcFormato, sizeof(arcFormato)));\r\n  printf(\"%scon \", strFormat2(FRM_BOLD, arcFormato, sizeof(arcFormato)));\r\n  printf(\"%sformato\", strFormat2(FRM_BACK_CYAN, arcFormato, sizeof(arcFormato)));\r\n  printf(\"%s\\n\", strFormat2(FRM_NORMAL, arcFormato, sizeof(arcFormato)));\r\n  ...\r\n```\r\n\r\nNo obstante hay algunos inconvenientes. Por ejemplo, como se usa el mismo array debe hacerse una llamada por printf, ya que si no, no se actualizará el formato. Para solventar este y otros problemas, tenemos una versión para C++:\r\n\r\n```cpp\r\n/**\r\n * Establece el formato de texto a partir del valor recibido.\r\n * @param  formato  Formato de texto a aplicar.\r\n * @return Cadena con el formato aplicado.\r\n */\r\nstring strFormat(const strformat formato) {\r\n  char arcFormato[10];\r\n  snprintf(arcFormato, sizeof(arcFormato), \"%c[%im\", CHAR_ESC, formato);\r\n  return arcFormato;\r\n}\r\n```\r\n\r\nEn este caso, el array se crea y destruye con la función, y lo que obtenemos es una cadena copiada. Podéis observar que prácticamente hacemos lo mismo que en el método C. Ahora veamos el mismo ejemplo con esta función:\r\n\r\n```cpp\r\n  ...\r\n  printf(\"Este es un %tyext%sto%s sin %sformato%s\\n\",\r\n         strFormat(FRM_BLUE).c_str(), strFormat(FRM_UNDERLINE).c_str(),\r\n         strFormat(FRM_BOLD).c_str(), strFormat(FRM_BACK_CYAN).c_str(),\r\n         strFormat(FRM_NORMAL).c_str());\r\n  ...\r\n```\r\n\r\nTanto la primera como la segunda función, producirán la siguiente salida por consola:\r\n\r\n> Este es un texto con formato",
    "url": "/articles/posts/20130607.html",
    "date": "2013-06-07",
    "categories": [
      "Programación",
      "C/C++"
    ],
    "content": "La consola (o terminal) de Linux/Unix admite diferentes formatos de carácter como negrita, subrayado, colores, etc. Para aplicar los formatos hemos desarrollado una función que junto con una enumeración nos permitirá de forma sencilla aplicar formato a nuestros textos por consola. A continuación podéis ver el código común a las dos funciones: En el código superior se definen las constantes a utilizar en las funciones. La enumeración strformat contiene los valores de formato que se pueden aplicar. Esta parte no tiene más misterios, pasemos ahora a ver la función de formato para C estándar: La función de C, devuelve el mismo array que recibe de esta forma podemos utilizarla dentro de funciones como printf() sin problemas de estar llenando la memoria de elementos duplicados. Como podéis observar, el código de la función es muy sencillo, tan sólo se limita a imprimir el carácter de escape y a continuación el código de formato. Tan sólo nos queda ver un ejemplo de su uso: No obstante hay algunos inconvenientes. Por ejemplo, como se usa el mismo array debe hacerse una llamada por printf, ya que si no, no se actualizará el formato. Para solventar este y otros problemas, tenemos una versión para C++: En este caso, el array se crea y destruye con la función, y lo que obtenemos es una cadena copiada. Podéis observar que prácticamente hacemos lo mismo que en el método C. Ahora veamos el mismo ejemplo con esta función: Tanto la primera como la segunda función, producirán la siguiente salida por consola: Este es un tex to con formato",
    "imageMini": "/images/c-mini.png"
  },
  {
    "slug": "20130603.html",
    "title": "C: función indexOf() para cadenas",
    "description": "En Java, el método `indexOf()`) de los objetos String, nos permite conocer la posición de una cadena dentro de otra.\r\n\r\nEn C no disponemos de una función parecida (a nivel de librerías estándar), por lo que para aquellas personas que la necesitéis, podréis ver a continuación el código de una función cuyo resultado es prácticamente igual que el método de Java.\r\n\r\n## El código\r\n\r\n```c\r\n/**\r\n * Obtiene la posición de la cadena recibida como segundo parámetro, dentro de\r\n * la cadena indicada en el primer parámetro.\r\n * @param  theString    Cadena sobre la que buscar la subcadena.\r\n * @param  searched  Cadena a buscar.\r\n * @return Índice base 0 de la subcadena si se encuentra o -1 en caso de no\r\n *         encontrarse.\r\n */\r\nint indexOf(char * theString, char * searched) {\r\n  int position = -1;\r\n  char * result = null;\r\n\r\n  if (theString && searched) {\r\n    result = strstr(theString, searched);\r\n    if (result) {\r\n      position = result - theString;\r\n    }\r\n  }\r\n\r\n  return position;\r\n}\r\n```\r\n\r\nEl funcionamiento del método es muy simple, se basa en la resta de punteros para obtener la posición de la subcadena.\r\n\r\nLo primero que hacemos es obtener el puntero a la subcadena si se encuentra en la cadena principal mediante la llamada a `strstr`. Una vez obtenido el puntero, restamos éste a la cadena original dándonos la \"posición\" del puntero de la subcadena con respecto a la cadena original.\r\n\r\nA continuación, se muestra un ejemplo con sus respectivos resultados:\r\n\r\n```c\r\nint main(int argc, char * argv[]) {\r\n  printf(\"h   Posición: %i\\n\", indexOf(\"hola que tal\", \"h\"));\r\n  printf(\"tal Posición: %i\\n\", indexOf(\"hola que tal\", \"tal\"));\r\n  printf(\"que Posición: %i\\n\", indexOf(\"hola que tal\", \"que\"));\r\n  printf(\"no  Posición: %i\\n\", indexOf(\"hola que tal\", \"no\"));\r\n  printf(\"e1  Posición: %i\\n\", indexOf(\"\", \"no\"));\r\n  printf(\"e2  Posición: %i\\n\", indexOf(\"hola que tal\", \"\"));\r\n  printf(\"e12 Posición: %i\\n\", indexOf(\"\", \"\"));\r\n  printf(\"n1  Posición: %i\\n\", indexOf(NULL, \"no\"));\r\n  printf(\"n2  Posición: %i\\n\", indexOf(\"hola que tal\", NULL));\r\n  printf(\"n12 Posición: %i\\n\", indexOf(NULL, NULL));\r\n}\r\n\r\n// Resultado\r\n// h   Posición: 0\r\n// tal Posición: 9\r\n// que Posición: 5\r\n// no  Posición: -1\r\n// e1  Posición: -1\r\n// e2  Posición: 0\r\n// e12 Posición: 0\r\n// n1  Posición: -1\r\n// n2  Posición: -1\r\n// n12 Posición: -1\r\n```\r\n\r\nComo podéis observar se producen los mismos resultados que con el método de Java, excepto el trabajo con valores nulos (en Java como es obvio el objeto que llama no puede ser nulo, sólo el parámetro) por lo que se ha optado por devolver en este caso -1.",
    "url": "/articles/posts/20130603.html",
    "date": "2013-06-03",
    "categories": [
      "Programación",
      "C/C++"
    ],
    "content": "En Java, el método indexOf() de los objetos String, nos permite conocer la posición de una cadena dentro de otra. En C no disponemos de una función parecida (a nivel de librerías estándar), por lo que para aquellas personas que la necesitéis, podréis ver a continuación el código de una función cuyo resultado es prácticamente igual que el método de Java. El código El funcionamiento del método es muy simple, se basa en la resta de punteros para obtener la posición de la subcadena. Lo primero que hacemos es obtener el puntero a la subcadena si se encuentra en la cadena principal mediante la llamada a strstr . Una vez obtenido el puntero, restamos éste a la cadena original dándonos la &quot;posición&quot; del puntero de la subcadena con respecto a la cadena original. A continuación, se muestra un ejemplo con sus respectivos resultados: Como podéis observar se producen los mismos resultados que con el método de Java, excepto el trabajo con valores nulos (en Java como es obvio el objeto que llama no puede ser nulo, sólo el parámetro) por lo que se ha optado por devolver en este caso -1.",
    "imageMini": "/images/c-mini.png"
  },
  {
    "slug": "20130404.html",
    "title": "Java: toString() genérico para todas las clases",
    "description": "Gracias a la reflexión en Java podemos acceder a los datos internos de nuestras clases. De esta forma podemos conocer los métodos y atributos declarados, entre otras cosas. Pues bien, hoy vamos a tener un método toString() que nos servirá para cualquier clase y que nos mostrará una cadena del tipo:\r\n\r\n```text\r\nNombreClase {atributo1->valor1; atributo2->valor2; ... atributoN->valorN}\r\n```\r\n\r\n## El código\r\n\r\nPara lo anterior, tan sólo tenemos que tener un método toString() con la forma siguiente en nuestras clases:\r\n\r\n```java\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.Modifier;\r\n\r\n// ...\r\n\r\n/**\r\n * Obtiene una cadena con los valores del objeto.\r\n * @return Cadena con los valores del objeto.\r\n */\r\n@Override\r\npublic String toString() {\r\n  final StringBuilder objBuilder = new StringBuilder();\r\n \r\n  // Inicio de cadena.\r\n  objBuilder.append(getClass().getSimpleName());\r\n  objBuilder.append(\" {\");\r\n \r\n  try {\r\n    // Comienza el análisis por la clase actual y recorre los elementos hasta\r\n    // llegar a la clase base Object.\r\n    Class objClase = getClass();\r\n    Field[] arCampos;\r\n    String sTipo;\r\n\r\n    while (null != objClase\r\n           && !Object.class.getSimpleName().equals(objClase.getSimpleName())) {\r\n      arCampos = objClase.getDeclaredFields();\r\n      if (null != arCampos) {\r\n        // Recorre los campos del objeto. Si es una constante omite su lectura.\r\n        for (Field objCampo : arCampos) {\r\n          sTipo = objCampo.getType().toString();\r\n          if (!Modifier.isFinal(objCampo.getModifiers())\r\n              || (sTipo.startsWith(\"class\")\r\n              && !sTipo.endsWith(String.class.getCanonicalName()))) {\r\n            objCampo.setAccessible(true);\r\n            objBuilder.append(objCampo.getName());\r\n            objBuilder.append(\"->\");\r\n            objBuilder.append(objCampo.get(this));\r\n            objBuilder.append(\"; \");\r\n          }\r\n        }\r\n      }\r\n \r\n      // Pasa a la siguiente clase padre.\r\n      objClase = objClase.getSuperclass();\r\n    }\r\n  } catch (final IllegalArgumentException e) {\r\n  } catch (final IllegalAccessException e) {\r\n  }\r\n \r\n  // Fin de cadena. Si hay datos elimina el último \"; \".\r\n  if (objBuilder.length() > getClass().getSimpleName().length() + 2) {\r\n    objBuilder.setLength(objBuilder.length() - 2);\r\n  }\r\n  objBuilder.append('}');\r\n \r\n  return objBuilder.toString();\r\n}\r\n```\r\n\r\n## Explicación\r\n\r\nLo primero de todo es saber de forma muy breve que es la reflexión en Java. De forma totalmente ajena a nosotros, cuando creamos una clase en Java, se crea una instancia de Class para dicha clase. Dicho objeto contiene toda la información de nuestra clase, métodos, atributos, anotaciones, constructores, etc.\r\n\r\nEn nuestro caso, lo que queremos saber es el contenido de las variables del objeto actual. Pues bien, veamos el código deteniéndonos en los pasos que más puedan interesar.\r\n\r\n```java\r\n  objBuilder.append(getClass().getSimpleName());\r\n```\r\n\r\nEs la parte más sencilla, con eso obtenemos el nombre que le hemos dado a la clase. Si usamos, getName() nos mostraría el paquete y el nombre de la clase, por ejemplo es.jafs.ejemplo.MiClase.\r\n\r\n```java\r\nwhile (null != objClase\r\n       && !Object.class.getSimpleName().equals(objClase.getSimpleName())) {\r\n```\r\n\r\nComo sabemos, todas las clases, de forma transparente para nosotros heredan de la clase Object, por lo que es la clase padre de todas. Con este bucle, nos aseguramos de que salgamos al llegar a la clase Object.\r\n\r\n```java\r\narCampos = objClase.getDeclaredFields();\r\nif (null != arCampos) {\r\n  // Recorre los campos del objeto. Si es una constante omite su lectura.\r\n  for (Field objCampo : arCampos) {\r\n    sTipo = objCampo.getType().toString();\r\n    if (!Modifier.isFinal(objCampo.getModifiers())\r\n        || (sTipo.startsWith(\"class\")\r\n        && !sTipo.endsWith(String.class.getCanonicalName()))) {\r\n      objCampo.setAccessible(true);\r\n      objBuilder.append(objCampo.getName());\r\n      objBuilder.append(\"->\");\r\n      objBuilder.append(objCampo.get(this));\r\n      objBuilder.append(\"; \");\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nAquí tenemos la parte principal del método. Lo primero que hacemos con `getDeclaredFields()` es obtener todos los atributos de la clase.\r\nPosteriormente recorremos los atributos recibidos hay primero verificamos que no sean una constante y para ello utilizamos `Modifier.isFinal()`, en el caso de que sean una constante, omitiremos tanto los valores primitivos, como las cadenas. Pero el resto serán mostrados ya que el contenido de dichos objetos constantes puede variar.\r\nCuando el atributo pase nuestro filtro, lo que haremos es obtener su nombre y obtener su valor de toString() por defecto. Para obtener el valor de un campo lo que hacemos es llamar a los métodos `get()`, `getString()`, `getInt()`, etc, pasando la instancia del objeto actual.\r\n\r\n## Resultado\r\n\r\nTenemos dos clases, padre e hija cuyo código os mostramos a continuación. Ambas heredan de una clase ToString que contiene el método anterior.\r\n\r\n```java\r\npublic class Padre extends ToString {\r\n  private int id;\r\n  private String nombre;\r\n  private final Hija objHija = new Hija(12.34);\r\n  ...\r\n}\r\n\r\npublic class Hija extends ToString {\r\n  private double flotante;\r\n  ...\r\n}\r\n```\r\n\r\nAquí podremos ver el resultado de ejecutar las dos sentencias inferiores:\r\n\r\n```java\r\n  Padre objRadio = new Padre(123, \"MiClase\");\r\n  System.out.println(objRadio.toString());\r\n\r\n  // ...\r\n\r\n  Resultado:\r\n  Padre {id->123; nombre->MiClase; objHija->Hija {flotante->12.34}}\r\n```\r\n\r\n## Conclusión\r\n\r\nGracias a la reflexión hemos conseguido que cuando hagamos un toString() obtengamos cadenas con un formato parecido al que nos ofrece PHP. Si no queremos repetir código, lo cual no es deseable, lo mejor será crear una clase de la que hereden aquellas clases que queramos que implementen esta funcionalidad. El único problema es la herencia simple de Java, por lo que las clases que ya hereden de otra no podrán heredar de la que hayamos creado.\r\n\r\nTodas las posibles actualizaciones de código las podréis seguir en GitHub.",
    "url": "/articles/posts/20130404.html",
    "date": "2013-04-04",
    "categories": [
      "Programación",
      "Java"
    ],
    "content": "Gracias a la reflexión en Java podemos acceder a los datos internos de nuestras clases. De esta forma podemos conocer los métodos y atributos declarados, entre otras cosas. Pues bien, hoy vamos a tener un método toString() que nos servirá para cualquier clase y que nos mostrará una cadena del tipo: El código Para lo anterior, tan sólo tenemos que tener un método toString() con la forma siguiente en nuestras clases: Explicación Lo primero de todo es saber de forma muy breve que es la reflexión en Java. De forma totalmente ajena a nosotros, cuando creamos una clase en Java, se crea una instancia de Class para dicha clase. Dicho objeto contiene toda la información de nuestra clase, métodos, atributos, anotaciones, constructores, etc. En nuestro caso, lo que queremos saber es el contenido de las variables del objeto actual. Pues bien, veamos el código deteniéndonos en los pasos que más puedan interesar. Es la parte más sencilla, con eso obtenemos el nombre que le hemos dado a la clase. Si usamos, getName() nos mostraría el paquete y el nombre de la clase, por ejemplo es.jafs.ejemplo.MiClase. Como sabemos, todas las clases, de forma transparente para nosotros heredan de la clase Object, por lo que es la clase padre de todas. Con este bucle, nos aseguramos de que salgamos al llegar a la clase Object. Aquí tenemos la parte principal del método. Lo primero que hacemos con getDeclaredFields() es obtener todos los atributos de la clase. Posteriormente recorremos los atributos recibidos hay primero verificamos que no sean una constante y para ello utilizamos Modifier.isFinal() , en el caso de que sean una constante, omitiremos tanto los valores primitivos, como las cadenas. Pero el resto serán mostrados ya que el contenido de dichos objetos constantes puede variar. Cuando el atributo pase nuestro filtro, lo que haremos es obtener su nombre y obtener su valor de toString() por defecto. Para obtener el valor de un campo lo que hacemos es llamar a los métodos get() , getString() , getInt() , etc, pasando la instancia del objeto actual. Resultado Tenemos dos clases, padre e hija cuyo código os mostramos a continuación. Ambas heredan de una clase ToString que contiene el método anterior. Aquí podremos ver el resultado de ejecutar las dos sentencias inferiores: Conclusión Gracias a la reflexión hemos conseguido que cuando hagamos un toString() obtengamos cadenas con un formato parecido al que nos ofrece PHP. Si no queremos repetir código, lo cual no es deseable, lo mejor será crear una clase de la que hereden aquellas clases que queramos que implementen esta funcionalidad. El único problema es la herencia simple de Java, por lo que las clases que ya hereden de otra no podrán heredar de la que hayamos creado. Todas las posibles actualizaciones de código las podréis seguir en GitHub .",
    "imageMini": "/images/java-mini.png"
  },
  {
    "slug": "20120724.html",
    "title": "VB.NET: crear un log sencillo",
    "description": "La posibilidad de tener logs en las aplicaciones nos pueden ayudar bastante en el día a día, sobretodo cuando no podemos depurar nuestro código. Por ello, hoy os propongo un código sencillo para llevar un registro de los eventos de nuestra aplicación en VB.NET.\r\n\r\n## El código\r\n\r\n```vb\r\nImports System.IO\r\n\r\nPublic Class Logger\r\n  Public Enum TipoMensaje\r\n    DEBUG\r\n    INFO\r\n    WARNING\r\n    LERROR\r\n  End Enum\r\n\r\n  Private Const TAM_FICHERO As Integer = 52428800\r\n  Private Const EXTENSION As String = \".log\"\r\n\r\n  Private Shared eNivel As TipoMensaje = TipoMensaje.DEBUG\r\n\r\n  Public Shared Property Nivel As TipoMensaje\r\n    Get\r\n      Return eNivel\r\n    End Get\r\n    Set(eActual As TipoMensaje)\r\n      eNivel = eActual\r\n    End Set\r\n  End Property\r\n\r\n  Private Shared Sub add(ByVal eTipo As TipoMensaje, _\r\n                         ByVal sMensaje As String, _\r\n                         Optional ByVal objTraza As StackFrame = Nothing)\r\n    If eTipo >= eNivel Then\r\n      Dim sDestino As String = getFileFecha()\r\n\r\n      verificar(sDestino)\r\n\r\n      Dim objFichero As New FileStream(sDestino, FileMode.Append, _\r\n                                       FileAccess.Write)\r\n\r\n      If Not objFichero Is Nothing And objFichero.CanWrite Then\r\n        Dim sDeb As String = String.Empty\r\n        Dim objFecha As Date = Date.Now\r\n\r\n        sDeb = objFecha.ToString() + \" [\" + eTipo.ToString + \"] \"\r\n        sDeb &= getTraza(objTraza) & sMensaje\r\n\r\n        Dim objStream As New StreamWriter(objFichero)\r\n        objStream.WriteLine(sDeb)\r\n        objStream.Close()\r\n        objFichero.Close()\r\n      End If\r\n    End If\r\n  End Sub\r\n\r\n  Private Shared Function getFileFecha() As String\r\n    Dim objFecha As Date = Date.Now\r\n    Dim sCadena As String = String.Empty\r\n\r\n    sCadena &= objFecha.Year\r\n    If objFecha.Month = _\r\n         TAM_FICHERO Then\r\n        My.Computer.FileSystem.MoveFile(sFichero, sFichero & \".old\")\r\n      End If\r\n    Catch ex As IOException\r\n    End Try\r\n  End Sub\r\n\r\n  Public Shared Sub e(sMensaje As String, objExcepcion As Exception, _\r\n                      Optional ByVal objTraza As StackFrame = Nothing)\r\n    add(TipoMensaje.LERROR, sMensaje & vbNewLine & _\r\n        vbTab & objExcepcion.Message & vbNewLine & _\r\n        vbTab & objExcepcion.ToString, objTraza)\r\n  End Sub\r\n\r\n  Public Shared Sub e(sMensaje As String, _\r\n                      Optional ByVal objTraza As StackFrame = Nothing)\r\n    add(TipoMensaje.LERROR, sMensaje, objTraza)\r\n  End Sub\r\n\r\n  Public Shared Sub w(sMensaje As String, _\r\n                      Optional ByVal objTraza As StackFrame = Nothing)\r\n    add(TipoMensaje.WARNING, sMensaje, objTraza)\r\n  End Sub\r\n\r\n  Public Shared Sub i(sMensaje As String, _\r\n                      Optional ByVal objTraza As StackFrame = Nothing)\r\n    add(TipoMensaje.INFO, sMensaje, objTraza)\r\n  End Sub\r\n\r\n  Public Shared Sub d(sMensaje As String, _\r\n                      Optional ByVal objTraza As StackFrame = Nothing)\r\n    add(TipoMensaje.DEBUG, sMensaje, objTraza)\r\n  End Sub\r\n\r\n  Public Shared Function getTraza(objTraza As StackFrame) As String\r\n    Dim sTraza As String = String.Empty\r\n\r\n    If Not objTraza Is Nothing Then\r\n      Dim iPosicion As Integer = objTraza.GetFileName.LastIndexOf(\"\\\")\r\n\r\n      If iPosicion < 0 Then\r\n        sTraza = objTraza.GetFileName()\r\n      Else\r\n        sTraza = objTraza.GetFileName().Substring(iPosicion + 1)\r\n      End If\r\n\r\n      sTraza &= \"::\" & objTraza.GetFileLineNumber & \" - \"\r\n    End If\r\n\r\n    Return sTraza\r\n  End Function\r\nEnd Class\r\n```\r\n\r\n## Explicación\r\n\r\nLo primero que vemos es el enumerado **TipoMensaje** que contiene los posibles tipos de registro que tendremos. A la hora de guardar nuestro registro se mostrará el nivel de cada evento.\r\n\r\nLa función `getFileFecha()` obtiene el nombre del fichero que vamos a utilizar. Por ejemplo, en el día de escritura de este artículo el nombre obtenido sería: **20120724.log**.\r\n\r\nEl método `verificar()` lo que hace es analizar el tamaño del fichero de registro. Si este excede el límite que viene dado por la constante **TAM_FICHERO** se realiza una copia de seguridad y se comienza un nuevo fichero. Esta parte la podéis obviar si no os importa el tamaño de los archivos.\r\n\r\nEl método `add()` es el que contiene la parte principal del código. Recibe el tipo de registro, así como el mensaje a almacenar y de forma opcional la traza y se encarga de almacenarlos en el fichero de registro con la fecha y hora actuales.\r\n\r\nLos métodos `d()`, `i()`, `w()` y `e()` hacen de interfaz para simplificar la escritura en el registro y son los métodos que utilizará el usuario o usuaria. El método `e()` puede recibir un parámetro extra que será un objeto de tipo **Exception**, de esta forma podremos añadir a nuestro log el contenido de la excepción.\r\n\r\n## Resultado\r\n\r\nEl resultado de utilizar nuestra clase Logger sería parecido al siguiente:\r\n\r\n```text\r\n24/07/2012 16:37:34 [LERROR] - Este no tiene traza\r\n24/07/2012 16:37:35 [DEBUG] FrmPrueba.vb::7 - Este si tiene traza\r\n24/07/2012 16:37:36 [INFO] FrmPrueba.vb::9 - Mensaje de información.\r\n24/07/2012 16:38:02 [LERROR] FrmPrueba.vb::19 - Ocurrió un error\r\n  Valor demasiado grande o demasiado pequeÃ±o para un decimal.\r\n  System.OverflowException: Valor demasiado grande o demasiado pequeño para un decimal.\r\n    en System.Decimal..ctor(Double value)\r\n    en Logger.Form1.btnEnviar_Click(Object sender, EventArgs e) en FrmPrueba.vb:lÃ­nea 19\r\n```\r\n\r\nFinalmente, veamos como utilizar nuestro sistema de log. Lo primero es indicar el nivel de registro. Por defecto, es DEBUG, pero podemos ponerle un nivel, por ejemplo, de WARNING, esto se haría de la forma siguiente:\r\n\r\n```vb\r\nLogger.Nivel = Logger.TipoMensaje.WARNING\r\n```\r\n\r\nEn este caso sólo se mostrarán los mensajes de WARNING y de ERROR, siendo omitidos los demás.\r\n\r\n## Ejemplos de uso\r\n\r\n```vb\r\nLogger.e(\"Error con excepción\", ex)\r\nLogger.d(\"Debug con traza\", New StackFrame(True))\r\nLogger.i(\"Info sin traza\", New StackFrame(True))\r\nLogger.e(\"Error con excepción y traza\", ex, New StackFrame(True))\r\n```",
    "url": "/articles/posts/20120724.html",
    "date": "2012-07-24",
    "categories": [
      "Programación",
      "Visual Basic.NET"
    ],
    "content": "La posibilidad de tener logs en las aplicaciones nos pueden ayudar bastante en el día a día, sobretodo cuando no podemos depurar nuestro código. Por ello, hoy os propongo un código sencillo para llevar un registro de los eventos de nuestra aplicación en VB.NET. El código Explicación Lo primero que vemos es el enumerado TipoMensaje que contiene los posibles tipos de registro que tendremos. A la hora de guardar nuestro registro se mostrará el nivel de cada evento. La función getFileFecha() obtiene el nombre del fichero que vamos a utilizar. Por ejemplo, en el día de escritura de este artículo el nombre obtenido sería: 20120724.log . El método verificar() lo que hace es analizar el tamaño del fichero de registro. Si este excede el límite que viene dado por la constante TAM_FICHERO se realiza una copia de seguridad y se comienza un nuevo fichero. Esta parte la podéis obviar si no os importa el tamaño de los archivos. El método add() es el que contiene la parte principal del código. Recibe el tipo de registro, así como el mensaje a almacenar y de forma opcional la traza y se encarga de almacenarlos en el fichero de registro con la fecha y hora actuales. Los métodos d() , i() , w() y e() hacen de interfaz para simplificar la escritura en el registro y son los métodos que utilizará el usuario o usuaria. El método e() puede recibir un parámetro extra que será un objeto de tipo Exception , de esta forma podremos añadir a nuestro log el contenido de la excepción. Resultado El resultado de utilizar nuestra clase Logger sería parecido al siguiente: Finalmente, veamos como utilizar nuestro sistema de log. Lo primero es indicar el nivel de registro. Por defecto, es DEBUG, pero podemos ponerle un nivel, por ejemplo, de WARNING, esto se haría de la forma siguiente: En este caso sólo se mostrarán los mensajes de WARNING y de ERROR, siendo omitidos los demás. Ejemplos de uso",
    "imageMini": "/images/vbnet-mini.png"
  },
  {
    "slug": "20100311.html",
    "title": "VB.NET: Hash MD5 y SHA fácil",
    "description": "En el artículo de hoy aprenderemos a obtener el hash MD5 y SHA para una cadena de una forma muy sencilla mediante Visual Basic.NET. Comenzaremos observando el código que genera los valores:\r\n\r\n```vb\r\nImports System.Text\r\nImports System.Security.Cryptography\r\n\r\nFunction generarMD5(ByVal sCadena As String) As String\r\n  ' Objeto de codificación\r\n  Dim ueCodigo As New UnicodeEncoding()\r\n  ' Objeto para instanciar las codificación\r\n  Dim Md5 As New MD5CryptoServiceProvider()\r\n\r\n  ' Calcula el valor hash de la cadena recibida\r\n  Dim bHash() As Byte = Md5.ComputeHash(ueCodigo.GetBytes(sCadena))\r\n\r\n  ' Convierte el valor anterior en cadena y lo devuelve\r\n  Return Convert.ToBase64String(bHash)\r\nEnd Function\r\n\r\nFunction generarSHA(ByVal sCadena As String) As String\r\n  ' Objeto de codificación\r\n  Dim ueCodigo As New UnicodeEncoding()\r\n  ' Objeto para instanciar las codificación\r\n  Dim SHA As New SHA512Managed\r\n\r\n  ' Calcula el valor hash de la cadena recibida\r\n  Dim bHash() As Byte = SHA.ComputeHash(ueCodigo.GetBytes(sCadena))\r\n\r\n  ' Convierte el valor anterior en cadena y lo devuelve\r\n  Return Convert.ToBase64String(bHash)\r\nEnd Function\r\n```\r\n\r\nComo se puede observar, las dos funciones son prácticamente iguales y no tienen muchos misterios. Para realizar la codificación lo único que se hace, es utilizar un objeto `UnicodeEncoding` que se utilizará para descomponer en un array de bytes la cadena de la que quiere obtener su hash, para a continuación codificar dicho array.\r\n\r\nCabe recordar, que es importante incluir las librerías donde se encuentran tanto UnicodeEncoding como las funciones de hash, para ello nos remitimos a las primeras líneas del código anterior:\r\n\r\n```vb\r\nImports System.Text\r\nImports System.Security.Cryptography\r\n```",
    "url": "/articles/posts/20100311.html",
    "date": "2010-03-11",
    "categories": [
      "Programación",
      "Visual Basic.NET"
    ],
    "content": "En el artículo de hoy aprenderemos a obtener el hash MD5 y SHA para una cadena de una forma muy sencilla mediante Visual Basic.NET. Comenzaremos observando el código que genera los valores: Como se puede observar, las dos funciones son prácticamente iguales y no tienen muchos misterios. Para realizar la codificación lo único que se hace, es utilizar un objeto UnicodeEncoding que se utilizará para descomponer en un array de bytes la cadena de la que quiere obtener su hash, para a continuación codificar dicho array. Cabe recordar, que es importante incluir las librerías donde se encuentran tanto UnicodeEncoding como las funciones de hash, para ello nos remitimos a las primeras líneas del código anterior:",
    "imageMini": "/images/vbnet-mini.png"
  },
  {
    "slug": "20090130.html",
    "title": "VB.NET: información de las unidades de disco",
    "description": "En Visual Basic.NET se puede encontrar el array Drives dentro de My.Computer.FileSystem. Con él se obtiene bastante información sobre las unidades de disco conectadas en el ordenador. Pasemos a ver algunos de los atributos más interesantes:\r\n\r\n- `AvailabreFreeSpace`: entero largo que indica espacio disponible en la unidad en bytes. Para obtener los MB o GB deberemos realizar las operaciones oportunas con este dato.\r\n- `DriveFormat`: cadena que nos indica el sistema de archivos en el que está formateada la unidad.\r\n- `DriveType`: nos indica el tipo de unidad entre los que tenemos:\r\n  - *IO.DriveType.CDRom*: unidad de CD.\r\n  - *IO.DriveType.Fixed*: disco fijo.\r\n  - *IO.DriveType.Network*: unidad de red.\r\n  - *IO.DriveType.NoRootDirectory*: unidad sin directorio raíz.\r\n  - *IO.DriveType.Ram*: disco ram.\r\n  - *IO.DriveType.Removable*: extraíble.\r\n  - *IO.DriveType.Unknown*: unidad de tipo desconocido.\r\n- `IsReady`: valor booleano que indica si la unidad está lista. Ten en cuenta que no podrá acceder a la mayoría de los datos, como el sistema de archivos o el espacio libre si la unidad no está montada.\r\n- `Name`: cadena con el nombre por el que conoce Windows a la unidad. El famoso A:, C:, etc.\r\n- `RootDirectory`: cadena que devuelve el directorio raíz de la unidad.\r\n- `TotalFreeSpace`: prácticamente lo mismo que AvailableFreeSpace.\r\n- `TotalSize`: entero largo que nos devuelve el tamaño total de la unidad en bytes.\r\n- `VolumeLabel`: nos devuelve una cadena con el nombre que le hemos asignado a la unidad, lo que se conoce como etiqueta del volumen.",
    "url": "/articles/posts/20090130.html",
    "date": "2009-01-30",
    "categories": [
      "Programación",
      "Visual Basic.NET"
    ],
    "content": "En Visual Basic.NET se puede encontrar el array Drives dentro de My.Computer.FileSystem. Con él se obtiene bastante información sobre las unidades de disco conectadas en el ordenador. Pasemos a ver algunos de los atributos más interesantes: AvailabreFreeSpace : entero largo que indica espacio disponible en la unidad en bytes. Para obtener los MB o GB deberemos realizar las operaciones oportunas con este dato. DriveFormat : cadena que nos indica el sistema de archivos en el que está formateada la unidad. DriveType : nos indica el tipo de unidad entre los que tenemos: IO.DriveType.CDRom : unidad de CD. IO.DriveType.Fixed : disco fijo. IO.DriveType.Network : unidad de red. IO.DriveType.NoRootDirectory : unidad sin directorio raíz. IO.DriveType.Ram : disco ram. IO.DriveType.Removable : extraíble. IO.DriveType.Unknown : unidad de tipo desconocido. IsReady : valor booleano que indica si la unidad está lista. Ten en cuenta que no podrá acceder a la mayoría de los datos, como el sistema de archivos o el espacio libre si la unidad no está montada. Name : cadena con el nombre por el que conoce Windows a la unidad. El famoso A:, C:, etc. RootDirectory : cadena que devuelve el directorio raíz de la unidad. TotalFreeSpace : prácticamente lo mismo que AvailableFreeSpace. TotalSize : entero largo que nos devuelve el tamaño total de la unidad en bytes. VolumeLabel : nos devuelve una cadena con el nombre que le hemos asignado a la unidad, lo que se conoce como etiqueta del volumen.",
    "imageMini": "/images/vbnet-mini.png"
  }
]