[
  {
    "slug": "20250720.html",
    "title": "Introducci√≥n a las redes neuronales",
    "description": "En el art√≠culo anterior pudimos revisar en qu√© consisten las neuronas artificiales, y adem√°s vimos c√≥mo poder implementar una neurona en JavaScript. Si a√∫n no lo has le√≠do, te recomiendo que empieces por ah√≠ para entender la base de lo que vamos a ver ahora.",
    "url": "/articles/posts/20250720.html",
    "date": "2025-07-20",
    "categories": [
      "Programaci√≥n"
    ],
    "content": "En el art√≠culo anterior pudimos revisar en qu√© consisten las neuronas artificiales, y adem√°s vimos c√≥mo poder implementar una neurona en JavaScript. Si a√∫n no lo has le√≠do, te recomiendo que empieces por ah√≠ para entender la base de lo que vamos a ver ahora. Si a√∫n as√≠ quieres empezar a leer este art√≠culo, a modo de resumen, en el anterior habl√°bamos de neuronas como peque√±as funciones matem√°ticas que ajustaban pesos y sesgos para intentar dar una salida lo m√°s precisa posible a partir de unas entradas. Hasta ah√≠ todo sencillo. Pero, si intentamos resolver un problema tan simple como la operaci√≥n XOR , nos encontraremos con una sorpresa. Lo primero de todo, recordemos su tabla de la verdad: El problema de XOR es que no es linealmente separable . Una neurona, como la que programamos en el art√≠culo anterior, s√≥lo puede establecer un l√≠mite mediante una recta (o un plano si hablamos de m√°s dimensiones) para separar las salidas, o dicho de otra forma, s√≥lo puede crear separaciones lineales entre las entradas y las salidas. En cambio, las capas ocultas permiten que la red combine m√∫ltiples l√≠mites simples para formar decisiones m√°s complejas y precisas. ¬øQu√© es una red neuronal? Una red neuronal artificial es un conjunto de neuronas conectadas entre s√≠ que trabajan juntas para procesar informaci√≥n. Se inspiran en c√≥mo funciona el cerebro humano, aunque de forma muy simplificada. Ya vimos, que cada neurona recibe entradas, las transforma aplicando una funci√≥n matem√°tica (lo que llamamos activaci√≥n) y genera una salida. Pues bien, en una red neuronal, esta salida llega a otras neuronas conectadas. Al unir muchas neuronas, se consigue que la red pueda aprender patrones complejos que una sola neurona no es capaz de distinguir. Las redes al igual que las cebollas, como dir√≠a Shrek, se organizan en capas : Capa de entrada : Recibe los datos iniciales. Por ejemplo, si queremos reconocer im√°genes, la capa de entrada recibe los p√≠xeles. Capas ocultas : Son las encargadas de procesar la informaci√≥n internamente. Cada neurona en estas capas intenta encontrar relaciones, patrones o combinaciones que sean √∫tiles para llegar a una salida correcta. Su nombre viene de que no vemos directamente sus resultados como usuarios. Capa de salida : Es la que tiene como entradas los resultados de las capas ocultas, y seg√∫n estados resultados da la respuesta final. Las redes pueden tener tantas capas ocultas como queramos, pero incluso con una capa podemos resolver problemas como el XOR, como veremos a continuaci√≥n. Ya que esta aproximaci√≥n nos permite comenzar a usar la IA como realmente la conocemos, dejando atr√°s los problemas muy sencillos que pod√≠a resolver una √∫nica neurona, para pasar a resolver problemas m√°s complejos como: Reconocimiento de im√°genes Traducci√≥n autom√°tica Diagn√≥stico m√©dico Coches aut√≥nomos Y un largo etc√©tera de posibilidades. Construyendo nuestra primera red neuronal Para resolver la operaci√≥n XOR, nuestra red neuronal va a ser muy sencilla: La capa oculta tendr√° dos neuronas. Y tendremos una neurona final de salida. Esto es suficiente para resolver XOR. Cada neurona de la capa oculta aprender√° a distinguir una de las condiciones necesarias para que XOR funcione. La neurona de salida simplemente combinar√° esa informaci√≥n. Para entender c√≥mo &quot;mapeamos&quot; de las neuronas ocultas a la de salida, piensa que cada neurona oculta detecta un patr√≥n concreto (por ejemplo, que A sea 1 y B sea 0). La neurona de salida aprender√° a usar esas &quot;pistas&quot; que proporcionan las neuronas de la capa oculta para decidir su salida. C√≥digo y explicaci√≥n paso a paso Clase Neuron En el art√≠culo anterior ya vimos la clase Neuron. Aqu√≠ os pongo que m√©todos p√∫blicos tiene a modo de recordatorio: Definiendo la red neuronal El constructor simplemente inicializa la capa oculta y genera la neurona de salida. Aunque s√≥lo es necesario dos neurona para resolver la operaci√≥n XOR, ya hemos dejado el c√≥digo gen√©rico para recibir cualquier n√∫mero de neuronas. El m√©todo que activa la red neuronal, difiere del de una neurona. En este caso activaremos todas las neuronas de la capa oculta, y una vez obtenidos sus resultados, ser√° lo que pasemos a la neurona de salida para que nos proporcione el resultado final: El m√©todo de entrenamiento p√∫blico, ser√° exactamente el mismo que el de una neurona ya que simplemente iterar√° el conjunto de datos el n√∫mero de pasos (√©pocas) necesarias. En cada √©poca, comenzaremos con el entrenamiento, algo que a nivel de c√≥digo tampoco es demasiado complejo en su m√©todo principal: Y aqu√≠ comienza lo complicado, ya que como habr√©is visto en los comentarios del c√≥digo anterior, es necesario propagar la desviaci√≥n de error, no s√≥lo de una neurona, sino a todas las de la red: Entrenando la red El entrenamiento es muy parecido al que realizamos con una s√≥la neurona, as√≠ que hemos aprovechado para hacer que la API p√∫blica de la red neuronal sea similar a la de una neurona. Bien, el c√≥digo que hemos visto nos permite generar una red neuronal de forma muy sencilla. Hay formas de desarrollarla mucho m√°s avanzadas y correctas como ser√≠a usar un gradiente descendente , pero como siempre digo, eso ser√° tema para otros art√≠culos. Resumiendo... Una neurona aislada es muy limitada, por lo que no sirve para operaciones complejas. Cuando unimos varias neuronas y les permitimos aprender juntas generamos una red neuronal . Incluso sin grandes frameworks, podemos construir peque√±os ejemplos en JavaScript (o cualquier otro lenguage que se te ocurra) para entender las bases. Hemos pasado de una neurona que &quot;resolv√≠a&quot; operaciones muy sencillas, a una peque√±a red que es capaz de resolver problemas imposibles para una sola. Espero que os haya servido para entender un poco m√°s las bases de este apasionante mundillo. El c√≥digo del proyecto ya est√° actualizado en GitHub , con la red neuronal. Pod√©is descargarlo, mejorarlo, experimentar y todo lo que se os ocurra. Muchas gracias si hab√©is llegado hasta aqu√≠. Nos vemos en el pr√≥ximo art√≠culo.",
    "imageMini": "/images/redes-neuronales-mini.webp"
  },
  {
    "slug": "20250622.html",
    "title": "Introducci√≥n a las neuronas artificiales",
    "description": "Para bien o para mal, la Inteligencia Artificial hoy est√° en todas partes. Muchas personas se centran en explicar los distintos modelos, pero en este art√≠culo me gustar√≠a que lleg√°ramos hasta el nivel m√°s bajo de este mundillo, lo que es la m√≠nima unidad de inteligencia artificial: **una neurona**.",
    "url": "/articles/posts/20250622.html",
    "date": "2025-06-22",
    "categories": [
      "Programaci√≥n",
      "IA",
      "neurona artificial"
    ],
    "content": "Para bien o para mal, la Inteligencia Artificial hoy est√° en todas partes. Muchas personas se centran en explicar los distintos modelos, pero en este art√≠culo me gustar√≠a que lleg√°ramos hasta el nivel m√°s bajo de este mundillo, lo que es la m√≠nima unidad de inteligencia artificial: una neurona . A continuaci√≥n aprenderemos desde los conceptos b√°sicos, hasta como hacer que una sola neurona resuelva un problema l√≥gico como una sencilla operaci√≥n booleana AND. Y como quiero innovar un poco, esta √∫ltima parte m√°s pr√°ctica no ser√° con c√≥digo Python (del cual hay miles de ejemplos), sino con JavaScript, ya que la idea es demostrar que con cualquier lenguaje podemos llevar a cabo la mayor parte de ideas en general. ¬øQu√© es una neurona artificial? B√°sicamente, una neurona artificial es un modelo matem√°tico inspirado en nuestras neuronas biol√≥gicas. Su algoritmo m√°s b√°sico consiste en lo siguiente: Empieza su aprendizaje con ejemplos . Le damos una lista de combinaciones de entradas junto con la salida que esperamos. Por ejemplo, para ense√±arle la operaci√≥n l√≥gica AND: Ajusta los ‚Äúpesos‚Äù de cada entrada . Estos pesos determinan cu√°nto influye cada entrada en el resultado. Al principio son aleatorios, pero tras ver muchos ejemplos, los va ajustando para acercarse cada vez m√°s a la salida correcta seg√∫n los errores que vaya obteniendo. -- Cuando ya ha practicado lo suficiente , le damos una nueva entrada y la neurona predice el resultado. Y s√≠, hablamos de una predicci√≥n , no de una f√≥rmula exacta. A veces acierta, otras se aproxima... como cualquier modelo de IA. A este √∫ltimo paso, es decir, al de proporcionar entradas para obtener una salida lo llamamos activar la neurona. El usar dicho verbo viene directamente de c√≥mo funcionan las neuronas reales en nuestro cerebro: una neurona recibe se√±ales a trav√©s de sus conexiones, las procesa, y si la se√±al es suficientemente fuerte, se activa y dispara una respuesta el√©ctrica. El siguiente esquema muestra el flujo b√°sico de aprendizaje: ¬øPero c√≥mo ‚Äúaprende‚Äù? El aprendizaje de una neurona artificial no es m√°s que un proceso de prueba y error. Le damos ejemplos, calcula una salida, ve cu√°nto se ha equivocado y ajusta sus par√°metros internos para hacerlo mejor la pr√≥xima vez. Este proceso seguro que te suena, pues lo que hacemos cuando aprendemos una habilidad nueva, ya sea programar, aprender a tocar un instrumento musical, etc. Pero yendo a la parte m√°s t√©cnica. ¬øQu√© par√°metros son los que ajusta la neurona? Pesos : cada entrada tiene un peso asociado. Es como decirle a la neurona ‚Äúesta entrada es m√°s importante que esta otra‚Äù. Al principio, esos pesos son aleatorios, pero la neurona los ajusta poco a poco durante el entrenamiento. Sesgo (o bias ): es un valor adicional que se suma al total antes de aplicar la funci√≥n de activaci√≥n. Sirve como una especie de empuj√≥n extra, permitiendo que la neurona genere salidas m√°s flexibles. Piensa en √©l como el ‚Äúestado de √°nimo‚Äù base de la neurona: si est√° muy alto o muy bajo, afecta al resultado aunque las entradas sean las mismas. Funci√≥n de activaci√≥n : una vez sumamos todas las entradas multiplicadas por sus pesos y le a√±adimos el sesgo, ese valor pasa por dicha funci√≥n, que lo que hace b√°sicamente, es convertir ese n√∫mero a algo que tenga sentido como ‚Äúrespuesta‚Äù. Le da no linealidad al sistema, permitiendo que aprenda comportamientos complejos. Entonces, en cada iteraci√≥n de la fase de aprendizaje, la neurona: Predice un resultado a partir de las entradas y los pesos que tenga guardados. Compara ese resultado con la salida esperada, o lo que es lo mismo calcula el error . Usa el error de la salida para ajustar los pesos y el sesgo , gui√°ndose por la derivada de la funci√≥n de activaci√≥n. Repite el proceso. ¬øCu√°ntas veces hay que entrenarla? Una pregunta com√∫n es: ¬øcu√°ntas veces hay que entrenar una neurona artificial? Para eso usamos el n√∫mero de √©pocas o iteraciones , es decir, cu√°ntas veces la neurona recorre todos los ejemplos para ajustar sus pesos y su sesgo. Si usamos muy pocas iteraciones , la neurona apenas aprende. Los pesos se quedan mal ajustados y la predicci√≥n ser√° incorrecta en muchos casos. Pero si usamos demasiadas , tambi√©n puede ser un problema. ¬øPor qu√©? Sobreajuste (overfitting) : Aunque en un problema tan simple como un AND o un OR esto no se nota mucho, en problemas reales con muchos datos, entrenar en exceso puede hacer que la neurona ‚Äúmemorice‚Äù los datos de entrenamiento y no sea capaz de generalizar cuando le damos datos nuevos. P√©rdida de tiempo y recursos : Cada iteraci√≥n consume tiempo y potencia de c√°lculo. Si despu√©s de cierto punto el modelo ya no mejora, seguir entrenando es simplemente ineficiente. Oscilaci√≥n de pesos : Si no se ha afinado bien la tasa de aprendizaje , demasiadas iteraciones pueden provocar que los pesos ‚Äúse pasen de largo‚Äù en cada ajuste, impidiendo que la neurona estabilice una soluci√≥n. Por eso, buscar el equilibrio es la clave . ¬øSiempre deberemos usar el mismo n√∫mero de iteraciones? Pues como dir√≠a Pau Don√©s: &quot;depende&quot;. En ejemplos sencillos como las operaciones AND u OR, 1000 iteraciones funcionan bien. Pero en problemas m√°s grandes, elegir el n√∫mero de iteraciones se convierte en toda una ciencia. Caso pr√°ctico La clase Neuron Esta clase representa una neurona artificial, y tiene todo lo necesario para poder entrenarse y activarse posteriormente. Sus atributos son los siguientes: learningRate : tasa o ratio de aprendizaje. Permite ajustar la desviaci√≥n de los pesos en cada iteraci√≥n del entrenamiento. bias : almacena el sesgo calculado. Puedes ver m√°s arriba informaci√≥n sobre el sesgo. weights : almacena los pesos. Igualmente, puedes ver en qu√© consisten m√°s arriba. inputsNumber : es importante almacenar el n√∫mero de entradas que permite la neurona. Est√© ser√° el atributo que lo guarde. activationFunction : funci√≥n que actuar√° como una especie de &quot;filtro&quot; que transforma el resultado en crudo calculado por la neurona es un valor normalizado. Hay varios tipos de funciones de activaci√≥n seg√∫n el uso que se le quiera dar a la neurona. Algo que comentaremos en futuros art√≠culos. derivateFunction : ser√≠a la funci√≥n derivada de la de activaci√≥n. Nos servir√° para ajustar el sesgo. Es por ello, que siempre depender√° de la funci√≥n de activaci√≥n. Adem√°s de los m√©todos: activate : se encarga de activar la neurona, es decir, darnos un resultado a partir de una serie de entradas. training : inicia el entrenamiento de la neurona. Recibe un conjunto de datos (por cada dato tenemos una o varias entradas y una salida). Adem√°s, recibe el n√∫mero de iteraciones que hay que realizar para entrenar cada dato. train : m√©todo privado que realiza el entrenamiento de un dato. adjust : como su nombre indica, este m√©todo, se encargar√° de ajustar tanto los pesos como el sesgo a partir del error entre la salida real y la esperada. calculateError : nos devuelve el error entre la salida esperada y la generada por la neurona. calculateAdjust : obtiene el valor ajuste que hay que realizar a partir del error. Entrenamiento Para cada paso del entrenamiento tendr√≠amos lo siguiente: Este m√©todo hace cuatro cosas muy importantes: Activa la neurona con las entradas actuales. O lo que es lo mismo, obtiene la salida calculada por la neurona con los pesos que tenemos actualmente ( computedOutput ) Calcula el error comparando lo que sali√≥ con lo que esper√°bamos. Usa la derivada de la funci√≥n de activaci√≥n para calcular cu√°nto debe ajustarse . Finalmente, ajusta pesos y sesgo . Para este ajuste de pesos tenemos el m√©todo privado #adjust . NOTA En JavaScript los atributos y m√©todos privados usan como prefijo la almohadilla # . Este es el m√©todo crucial para que funcione el proceso de aprendizaje de la neurona. Realiza el ajuste de pesos seg√∫n el valor que calculamos de desviaci√≥n con la derivada. Lo que deber√≠a ir reduciendo los errores entre la salida esperada y la obtenida. Adem√°s, en esta parte incluimos el ratio de aprendizaje ( learningRate en el c√≥digo), que ser√° un ajuste para poder usarlo en la desviaci√≥n. Ahora para entrenar a nuestra neurona para realizar operaciones AND. Usar√≠amos los datos siguientes: De forma que a partir de esos datos y de usar la funci√≥n de activaci√≥n sigmoide, podr√≠amos comenzar el entrenamiento: En este caso, estamos diciendo que la neurona: Tiene dos entradas Usa como funci√≥n de activaci√≥n, la funci√≥n sigmoide y su derivada. Tiene una tasa de aprendizaje de 0.1. O lo que es lo mismo, ir√° haciendo ajustes de pesos de 0.1 por cada iteracion. Finalmente, le damos los datos con los que entrenar y le indicamos que itere 1000 veces con dichos datos. Activaci√≥n Como indicamos anteriormente, cuando activamos la neurona, hacemos referencia al momento en el que &quot;piensa&quot; y da una respuesta. No est√° aprendiendo, est√° actuando seg√∫n lo que ya aprendi√≥. En nuestro c√≥digo JavaScript la activaci√≥n consistir√≠a en lo siguiente: Recibe los inputs , por ejemplo [1, 1]. El valor inicial parte del sesgo que calculamos durante el aprendizaje. Multiplica cada input por su peso correspondiente , ya que durante el entrenamiento a cada entrada le dimos &quot;una importancia&quot; diferente. Suma la multiplicaci√≥n de todos los pesos con el sesgo. Pasa ese resultado por la funci√≥n de activaci√≥n , que como vimos terminar√° actuando como un filtro. En este caso, al usar como funci√≥n de activaci√≥n, la funci√≥n sigmoide, transforma ese n√∫mero crudo en un valor entre 0 y 1. Con lo que al m√©todo anterior, si le damos [1, 1] como entrada, y est√° bien entrenada, nos devolver√° algo cercano a 1. Si le damos [0, 1] o [1, 0], nos devolver√° algo cercano a 0. Y es que cabe destacar que la salida no es un uno o un cero exacto . En nuestro ejemplo, como la funci√≥n de activaci√≥n devuelve valores continuos, puede darnos algo como 0.97 (que interpretamos como &quot;casi 1&quot;) o 0.04 (que interpretamos como &quot;casi 0&quot;). En nuestro caso real, la salida ser√° algo como: Finalmente El c√≥digo que he generado durante el desarrollo de este art√≠culo lo he publicado en GitHub . En intentado poner bastantes comentarios, principalmente en la clase Neuron, para que os pueda ser m√°s sencillo seguirlo. Ya que explicarlo al completo en este art√≠culo se har√≠a demasiado extenso. A√∫n nos queda mucho por aprender, por lo que en futuros art√≠culos: Veremos que aunque con nuestro c√≥digo actual podemos obtener buenos resultados para las operaciones AND y OR. Cuando pasamos a una operaci√≥n XOR debemos subir un nivel y crear nuestra primera red neuronal. Hablaremos un poco m√°s de las distintas funciones de activaci√≥n y en qu√© casos deber√≠amos usar cada una. Aprenderemos a persistir la informaci√≥n de las neuronas, para evitar entrenarlas cada vez. Para terminar, como ejercicio sencillo si descarg√°is el c√≥digo: probad a entrenar una neurona para que funcione con las operaciones OR.",
    "imageMini": "/images/neuronas-artificiales-mini.webp"
  },
  {
    "slug": "20240301.html",
    "title": "Aritm√©tica binaria",
    "description": "Hoy vamos a ver algo que se sale un poco de la t√≥nica habitual de este blog. Pero, siempre viene bien volver a las bases de la inform√°tica. As√≠ que espero que esta peque√±a introducci√≥n al sistema binario y a su aritm√©tica, pueda serte √∫til.",
    "url": "/articles/posts/20240301.html",
    "date": "2024-03-01",
    "categories": [
      "programaci√≥n",
      "binario",
      "aritm√©tica"
    ],
    "content": "Hoy vamos a ver algo que se sale un poco de la t√≥nica habitual de este blog. Pero, siempre viene bien volver a las bases de la inform√°tica. As√≠ que espero que esta peque√±a introducci√≥n al sistema binario y a su aritm√©tica, pueda serte √∫til. Sistemas de Numeraci√≥n Un sistema de numeraci√≥n lo podemos definir como un conjunto de reglas y convenios que nos permiten la representaci√≥n de todos los n√∫meros mediante varias cifras o s√≠mbolos. Los m√∫ltiples sistemas de numeraci√≥n que existen podemos agruparlos principalmente en dos familias: Por un lado, est√°n los que se rigen por reglas estrictas sin importar d√≥nde est√© la cifra o el s√≠mbolo. Estos son los sistemas basados en el Valor Absoluto . Un ejemplo de esto es el sistema de numeraci√≥n romana, que utiliza las letras I , V , X , L , C , D y M . En este sistema, el valor de una letra siempre es el mismo, sin importar su posici√≥n dentro del n√∫mero. Por ejemplo, el valor de C siempre ser√° 100 independientemente de su posici√≥n: Por otro lado tenemos a los sistemas basados en valores relativos . En este caso el mismo s√≠mbolo puede representar valores diferentes dependiendo de d√≥nde est√© ubicado en el n√∫mero. El sistema decimal es el m√°s destacado y conocido entre estos sistemas de numeraci√≥n. El sistema decimal fue ideado en la India en el siglo V a.C., posteriormente tra√≠do a Europa por los √°rabes en la Edad Media. Su base es el n√∫mero diez, habi√©ndose elegido este n√∫mero por ser diez los dedos de las manos y emplearse habitualmente √©stos para contar. Este sistema consta de diez d√≠gitos diferentes: 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 y 9 ; con los que debidamente agrupados puede representarse cualquier n√∫mero. En el sistema decimal cada signo tiene un valor dependiendo del lugar que ocupa. Y este valor viene dado por su valor absoluto multiplicado por potencias de 10 sucesivas (10‚Å∞, 10¬π, 10¬≤, etc.). As√≠ el n√∫mero cuatro mil trescientos cincuenta y dos equivaldr√° a: Sistemas de numeraci√≥n con valores relativos La construcci√≥n de un sistema de numeraci√≥n basado en valores relativos seguir√° la definici√≥n siguiente: El valor decimal de un n√∫mero es igual a la suma de los valores de los d√≠gitos o s√≠mbolos correspondientes, multiplicados por la base elevada a la potencia definida por su posici√≥n. es decir, si: ser√°: Por ejemplo, si partimos del n√∫mero 561‚Çà, de tres cifras ( T = 3 ) y con base ocho ( B = 8 ), tendr√≠amos la siguiente conversi√≥n a decimal: Con lo que tenemos que el valor decimal del n√∫mero 561 en base 8 es 369 ; lo que podemos expresar como 591‚Çà = 369‚ÇÅ‚ÇÄ . Equivalencias entre sistemas de valores relativos En la tabla siguiente se pueden observar las equivalencias de distintos sistemas de numeraci√≥n. Decimal (10) Quinario (5) Octal (8) Duodecimal (12) Hexadecimal (16) 0 0 0 0 0 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 4 4 4 4 4 5 10 5 5 5 6 11 6 6 6 7 12 7 7 7 8 13 10 8 8 9 14 11 9 9 10 20 12 A A 11 21 13 B B 12 22 14 10 C 13 23 15 11 D 14 24 16 12 E 15 30 17 13 F Sistema Binario (Base 2) El sistema binario, es la piedra angular del mundo de la inform√°tica. Es m√°s, s√≥lo nos tenemos que detener en el significado de bit , para comprobar como es una abreviatura de &quot; binary digit &quot; o d√≠gito binario. Este sistema utiliza solamente dos s√≠mbolos diferentes: 0 y 1 . En el mundo inform√°tico esto es justo lo que representa un bit de informaci√≥n, podemos hablar de verdadero y falso , encendido y apagado , etc. Pero, ¬øpor qu√© es tan crucial el sistema binario en la programaci√≥n? B√°sicamente por dos razones entre otras: Eficiencia : Las computadoras digitales utilizan el sistema binario debido a su eficiencia. Es m√°s f√°cil construir m√°quinas que solo necesitan distinguir entre dos estados. Operaciones l√≥gicas : Las operaciones fundamentales de la l√≥gica booleana ( AND , OR , NOT , etc.) se pueden representar y manipular f√°cilmente en el sistema binario. Conversi√≥n de decimal a binario Para convertir enteros decimales a la notaci√≥n binaria, tan s√≥lo hay que dividir el n√∫mero decimal por 2 hasta que el cociente sea cero. Los restos de cada divisi√≥n formar√°n el n√∫mero binario equivalente; el primer resto ser√° la cifra que se encuentre m√°s a la derecha mientras que el √∫ltimo resto ser√° la cifra que se encuentre m√°s a la izquierda. Como ejemplo, vamos a convertir el n√∫mero 13 a su valor binario: Si ahora le damos la vuelta a los restos que hemos obtenido, nos queda que: Cuando el cociente sea 1, tambi√©n puedes usar dicho cociente en lugar de tener que hacer una nueva divisi√≥n. Esto se ve mejor si expresamos la divisi√≥n con otro formato. Si paramos cuando el cociente sea 1 , usando el ejemplo anterior tendr√≠amos lo siguiente: Conversi√≥n de binario a decimal Al igual que con el resto de sistemas de numeraci√≥n, cada s√≠mbolo tiene un valor en funci√≥n del lugar que ocupa. As√≠, por ejemplo, el valor decimal del n√∫mero 101011‚ÇÇ es: Otro m√©todo muy utilizado es el denominado duplicidad y suma . La manera de proceder en este m√©todo es la siguiente: Se multiplica por 2 la cifra de orden superior, la que est√° m√°s a la izquierda del n√∫mero. Al producto se le suma el valor de la cifra de la derecha. La suma obtenida se multiplica por 2. Al producto obtenido se le suma la cifra a la derecha. Se repite la operaci√≥n hasta que no nos queden cifras a la derecha. Veamos la conversi√≥n por este sistema del mismo n√∫mero del ejemplo del caso anterior, es decir con el n√∫mero 101011‚ÇÇ: Fracciones Conversi√≥n de fracciones decimales en binarias En general el proceso de conversi√≥n de un sistema a otro de la parte fraccionaria de un n√∫mero es diferente al utilizado para la parte entera. Con frecuencia este proceso es el inverso para la fracci√≥n. Para convertir una fracci√≥n decimal en binaria se multiplica la fracci√≥n binaria por 2, correspondiendo la parte entera del producto al primer d√≠gito binario. Se repite la operaci√≥n con la parte decimal del producto anterior obteniendo un nuevo entero que ser√° el siguiente d√≠gito binario. As√≠ sucesivamente hasta que la fracci√≥n quede reducida a cero, o se haya quedado una cantidad suficiente de d√≠gitos binarios, en el caso de una fracci√≥n peri√≥dica. Ejemplo: convertir la fracci√≥n decimal 0,828125 en fracci√≥n binaria. Si tuvi√©ramos un n√∫mero con parte decimal y fraccionaria, podemos hacer las conversiones en dos partes: Conversi√≥n de fracciones binarias a decimales El m√©todo m√°s c√≥modo de conversi√≥n, resulta del desarrollo del n√∫mero binario en sus respectivas potencias de 2, con exponente negativo descendente de izquierda a derecha. Suma binaria En esencia, la suma binaria es muy semejante a la suma decimal; la tabla de sumar binaria, es mucho m√°s reducida que la decimal, como se puede observar a continuaci√≥n. Al sumar 1 + 1 en sistema binario, se excede el l√≠mite de la cuenta, ya que s√≥lo disponemos de los s√≠mbolos 0 y 1, y en consecuencia, el resultado ser√° 0 con acarrreo de 1 a la posici√≥n inmediata superior. Veamos a continuaci√≥n dos ejemplos de suma binaria. El primero no necesita comentarios, basta con seguir la tabla de sumar binaria. El segundo tiene varios acarreos de 1. As√≠ que para que se pueda entender un poco mejor, se ha indicado con super-√≠ndices encima de los valores afectados: Resta binaria Las reglas de la resta binaria aparecen esquematizadas a continuaci√≥n: Cuando en una columna la cifra del minuendo es menor que la del sustraendo, es preciso pedir una unidad a la columna inmediata superior, con lo que se aumenta en dos unidades el valor del minuendo en la que estamos trabajando (o lo que es lo mismo sumamos 10‚ÇÇ ). Al restar en la columna superior hay que tener en cuenta la unidad del minuendo que se ha pasado a la columna inferior y descontarla de aquella. Pero mejor, veamos un ejemplo: Multiplicaci√≥n binaria Las reglas de multiplicar en binario ser√≠an las siguientes: La multiplicaci√≥n binaria sigue el mismo sistema que la decimal. S√≥lo debemos recordar que la suma final de los productor parciales obtenidos al multiplicar el multiplicando por cada una de las cifras del multiplicador, debe hacerse en binario, como es obvio. Como siempre, ser√° mejor ver un ejemplo: Como se puede observar, s√≥lo hay dos casos, o repetir el multiplicando cuando el valor a usar del multiplicador es 1 o tener el valor 0, en caso de que ese sea el valor a usar del multiplicador. Divisi√≥n binaria La divisi√≥n binaria debe hacerse de id√©ntica manera a como se hace la divisi√≥n decimal con la salvedad de que la diferencia entre la parte correspondiente del dividendo y el producto obtenido al multiplicar el divisor por la cifra correspondiente del cociente, debe hacerse e binario. Veamos un ejemplo: Como se ha visto, en el caso anterior 100010‚ÇÇ : 110‚ÇÇ = 101‚ÇÇ con resto 100‚ÇÇ. Podemos verificar si la operaci√≥n ha sido correcta multiplicando divisor por cociente y sumando el resto:",
    "imageMini": "/images/aritmetica-binaria-mini.webp"
  },
  {
    "slug": "20230625.html",
    "title": "Hablemos de acoplamiento y cohesi√≥n. Parte 2. Cohesi√≥n",
    "description": "En el art√≠culo anterior estuvimos viendo un poco por encima en qu√© consisten los conceptos de acoplamiento y cohesi√≥n. En esta segunda parte nos centraremos es ver los distintos tipos de cohesi√≥n que hay. Eso s√≠, dependiendo del autor o autora, puede variar la lista, as√≠ que he intentado unificar lo m√°ximo posible para poner los tipos que hay en com√∫n.",
    "url": "/articles/posts/20230625.html",
    "date": "2023-06-25",
    "categories": [
      "Dise√±o y arquitectura"
    ],
    "content": "En el art√≠culo anterior estuvimos viendo un poco por encima en qu√© consisten los conceptos de acoplamiento y cohesi√≥n. En esta segunda parte nos centraremos es ver los distintos tipos de cohesi√≥n que hay. Eso s√≠, dependiendo del autor o autora, puede variar la lista, as√≠ que he intentado unificar lo m√°ximo posible para poner los tipos que hay en com√∫n. Tipos de cohesi√≥n Nombre Descripci√≥n &#x2b06; Alta Cohesi√≥n funcional Los elementos de un m√≥dulo realizan una tarea √∫nica y espec√≠fica. Cohesi√≥n secuencial Los elementos de un m√≥dulo est√°n conectados en una secuencia l√≥gica. Cohesi√≥n comunicativa Los elementos de un m√≥dulo est√°n relacionados porque trabajan juntos para producir un resultado com√∫n. Cohesi√≥n temporal Los elementos de un m√≥dulo est√°n relacionados en el tiempo. Cohesi√≥n l√≥gica Los elementos de un m√≥dulo est√°n relacionados porque todos contribuyen a un resultado l√≥gico com√∫n. &#x2b07; Baja Cohesi√≥n de coincidencia Los elementos de un m√≥dulo est√°n relacionados porque todos est√°n asociados con un evento o entidad com√∫n. Cohesi√≥n de coincidencia Los elementos de un m√≥dulo est√°n relacionados porque todos est√°n asociados con un evento o elemento com√∫n. Para explicar esto de una manera m√°s pr√°ctica, consideremos un ejemplo. Imagina que tienes un m√≥dulo que se encarga de la validaci√≥n de formularios. Este m√≥dulo contiene varias funciones, como validateEmail() , validatePassword() , validateName() , etc. Estas funciones comparten algunas constantes o variables globales, como las expresiones regulares para verificar el formato de entrada. En este caso, podr√≠amos decir que el m√≥dulo tiene una cohesi√≥n de coincidencia, ya que las funciones no est√°n conectadas entre s√≠, pero comparten algunos recursos. En lugar de esto, podr√≠amos dividir el m√≥dulo en subm√≥dulos m√°s peque√±os y espec√≠ficos, como uno para validar correos electr√≥nicos, otro para contrase√±as, etc. De esta manera, cada m√≥dulo tendr√≠a una mayor cohesi√≥n, lo que facilitar√≠a su mantenimiento y escalabilidad. Es importante tener en cuenta que la cohesi√≥n de coincidencia no siempre es mala. De hecho, en algunos casos, puede ser dif√≠cil evitarla por completo. Sin embargo, es importante asegurarse de que la cohesi√≥n de coincidencia no se convierta en un problema en el futuro. Cohesi√≥n l√≥gica La cohesi√≥n l√≥gica implica que un conjunto de componentes que pueden trabajar para conseguir un fin deber√≠an estar juntos, mientras que los que no tienen ninguna relaci√≥n directa con ese fin deber√≠an estar separados. Este tipo de cohesi√≥n, generalmente, resulta en un c√≥digo compartido, que es dif√≠cil de modificar y que implica estar pasando par√°metros entre m√≥dulos que en ocasiones pueden ser innecesarios. Si pensamos en el t√≠pico y t√≥pico caso de una tienda online. Podr√≠amos tener varios m√≥dulos que se relacionan entre s√≠, como el m√≥dulo de autenticaci√≥n, el m√≥dulo de gesti√≥n de productos, y el m√≥dulo de gesti√≥n de pedidos. Cada uno de estos m√≥dulos tendr√≠a su propia funcionalidad, pero estar√≠an l√≥gicamente conectados entre s√≠. Cuando un usuario inicia sesi√≥n, el m√≥dulo de autenticaci√≥n se encargar√≠a de autenticar al usuario y el m√≥dulo de gesti√≥n de productos mostrar√≠a los productos disponibles en la tienda. El problema aparecer√° si los m√≥dulos est√°n muy entrelazados y se cambia el funcionamiento o el comportamiento, mejor dicho de alguno de ellos, ya que implicar√° que se adapte el resto de m√≥dulos. Si cada m√≥dulo es verdaderamente independiente, entonces podemos hacer cambios en uno, y no deber√≠a implicar la modificaci√≥n del resto. Cohesi√≥n temporal La cohesi√≥n temporal es parecida a la l√≥gica pero, como su nombre indica, en este caso los distintos m√≥dulos tienen relaci√≥n en el tiempo. Un ejemplo muy claro se da cuando tenemos una parte en nuestro c√≥digo que se encarga de inicializar la aplicaci√≥n. En ese momento estaremos uniendo distintos m√≥dulos que s√≥lo tienen tienen en com√∫n el actuar dentro de esa funcionalidad. Este tipo de cohesi√≥n tiende a presentar las desventajas de los m√≥dulos con cohesi√≥n l√≥gica. Sin embargo, se considera una cohesi√≥n m√°s fuerte, ya que los m√≥dulos tienden a ser m√°s simples puesto que todos los elementos se ejecutan en un solo momento (es decir, normalmente no hay par√°metros y l√≥gica para determinar qu√© elemento ejecutar). Cohesi√≥n comunicativa En este tipo de cohesi√≥n, los elementos operan sobre los mismos datos o sobre un subconjunto de ellos. Por ejemplo, el elemento que gestiona el estado de conexi√≥n de un usuario o usuaria en un sistema de mensajer√≠a, y el que muestra el estado de los contactos. Operan sobre el mismo dato (estado de conexi√≥n), pero son elementos distintos. Cohesi√≥n secuencial Se da cuando la salida de un elemento es la entrada del siguiente. Un ejemplo de cohesi√≥n secuencial se puede dar cuando llega una llamada a una API para almacenar un dato. Se van pasando por distintas capas que convierten por ejemplo un JSON a un objeto, para terminar llegando a la persistencia. En este ejemplo, cuando termina un elemento de hacer su trabajo, el resultado es enviado al elemento siguiente en la cadena. Cohesi√≥n funcional En un m√≥dulo cohesionado funcionalmente, todos los elementos est√°n relacionados para llevar a cabo una sola funci√≥n, siendo lo suficientemente peque√±os. Pensemos en una aplicaci√≥n de procesamiento de im√°genes. En este caso, podr√≠amos tener diferentes m√≥dulos para la captura de im√°genes, la edici√≥n de im√°genes y la exportaci√≥n de im√°genes. Cada uno de estos m√≥dulos tiene una funci√≥n espec√≠fica, pero est√°n conectados para permitir una edici√≥n y exportaci√≥n efectiva de las im√°genes. Si estos m√≥dulos no estuvieran funcionalmente conectados, podr√≠a ser dif√≠cil mantener y escalar el c√≥digo. Por ejemplo, si el m√≥dulo de edici√≥n de im√°genes no estuviera dise√±ado para trabajar de manera efectiva con el m√≥dulo de exportaci√≥n de im√°genes, las im√°genes podr√≠an no exportarse correctamente. En este tipo de cohesi√≥n cada m√≥dulo es lo suficientemente peque√±o como para que se pueda comprender toda su implementaci√≥n de una sola vez. En el momento en que empezamos a a√±adir distintos caminos y flujos, el m√≥dulo seguramente se pueda hacer a√∫n m√°s peque√±o. ¬øC√≥mo detectar el tipo de cohesi√≥n? Una t√©cnica √∫til para determinar el tipo de cohesi√≥n de un m√≥dulo consiste en escribir una oraci√≥n que describa el prop√≥sito del m√≥dulo y luego examinar la oraci√≥n. Se pueden realizar las siguientes pruebas: Si la oraci√≥n es compuesta, contiene una coma o m√°s de un verbo, el m√≥dulo probablemente est√° realizando m√°s de una funci√≥n; de modo que, probablemente, tiene cohesi√≥n secuencial o comunicativa . Si la oraci√≥n contiene palabras relacionadas con el tiempo, como &quot;primero&quot;, &quot;siguiente&quot;, &quot;entonces&quot;, &quot;despu√©s&quot;, &quot;cuando&quot;, &quot;comenzar&quot;, etc., entonces el m√≥dulo probablemente tiene cohesi√≥n secuencial o temporal . Si el predicado de la oraci√≥n no contiene un objeto espec√≠fico que siga al verbo, es probable que el m√≥dulo tenga cohesi√≥n l√≥gica . Por ejemplo, &quot;Editar Todos los Datos&quot; tiene un cohesi√≥n l√≥gica; sin embargo, &quot;Editar la Declaraci√≥n de Origen&quot; puede tener cohesi√≥n funcional . Palabras como &quot;inicializar&quot;, &quot;limpiar&quot;, etc. implican cohesi√≥n temporal .",
    "imageMini": "/images/acoplamiento-cohesion-mini.webp"
  },
  {
    "slug": "20230324.html",
    "title": "Hablemos de acoplamiento y cohesi√≥n. Parte 1",
    "description": "Ya hemos hablado del Principio de Responsabilidad √önica, y no, no es una idea original de Robert C. Martin, sino que este principio parte del concepto de \"**cohesi√≥n**\". Es m√°s, el Principio de Inversi√≥n de Dependencias, tampoco es algo original y lo que nos habla es de \"**acoplamiento**\".",
    "url": "/articles/posts/20230324.html",
    "date": "2023-03-24",
    "categories": [
      "Dise√±o y arquitectura"
    ],
    "content": "Un poco de historia Ya hemos hablado del Principio de Responsabilidad √önica , y no, no es una idea original de Robert C. Martin , sino que este principio parte del concepto de &quot; cohesi√≥n &quot;. Es m√°s, el Principio de Inversi√≥n de Dependencias , tampoco es algo original y lo que nos habla es de &quot; acoplamiento &quot;. Las primeras personas que hablaron de estos dos conceptos, fueron Wayne P. Stevens , Glenford Myers y Larry Constantine en su art√≠culo &quot; Structured Design &quot; publicado en 1968 en la revista IBM Systems Journal . M√°s tarde, en 1978, Tom DeMarco , en su libro &quot; Structured Analysis and System Specification &quot;, tambi√©n describi√≥ la importancia de la cohesi√≥n como un factor clave para la calidad del software. Por lo que a lo largo de este art√≠culo veremos que los conceptos de acoplamiento y cohesi√≥n, son la base y el origen de otros principios y patrones que ya conocemos. ¬øQu√© es la cohesi√≥n? La cohesi√≥n se refiere a la medida en que los elementos de un m√≥dulo((Con el t√©rmino m√≥dulo nos estamos refiriendo a una parte de c√≥digo con nombre que puede ser llamada desde otra parte y, preferentemente tiene su propio conjunto de variables)) est√°n relacionados y trabajan juntos para cumplir una √∫nica funci√≥n. Por lo tanto, podemos pensar en ella como un rompecabezas: cuanto mejor encajen las piezas, m√°s alta ser√° la cohesi√≥n. ¬øY qu√© significa esto? Pues ya que la cohesi√≥n nos dice c√≥mo est√°n relacionadas las diferentes partes de un m√≥dulo. Si las partes trabajan juntas de manera efectiva para cumplir una tarea espec√≠fica, se dice que el sistema tiene alta cohesi√≥n. Pero si las partes no est√°n bien conectadas o si cada parte hace muchas cosas diferentes, el sistema tendr√° baja cohesi√≥n. Y como un ejemplo en c√≥digo vale m√°s que mil palabras. Comencemos con esta clase, en la que dejaremos los m√©todos vac√≠os porque lo importante es el nombre de √©stos: Se puede ver que la clase Library hace demasiadas cosas. Si la introducimos en un m√≥dulo para gesti√≥n de bibliotecas, b√°sicamente har√° todo el trabajo ella. Y cualquier en cualquier tipo de gesti√≥n de la biblioteca, implicar√° un cambio en la propia clase. Para poder aumentar la cohesi√≥n del m√≥dulo necesitamos separar responsabilidades, para que haya distintas clases cada una con la suya, pero puedan trabajar en conjunto para conseguir el objetivo de gestionar una biblioteca. Como hab√©is podido ver tras el ejemplo en c√≥digo... ¬øesto no os suena del Principio de Responsabilidad √önica? Efectivamente, en otras palabras, el principio nos dice que necesitamos tener una alta cohesi√≥n. ¬øY el acoplamiento? Con acoplamiento nos referimos a la forma de definir c√≥mo est√°n conectadas las diferentes partes de un sistema. Si dos m√≥dulos est√°n altamente acoplados, significa que est√°n muy interconectados y que cualquier cambio en uno de ellos puede afectar el funcionamiento del otro. Por otro lado, si dos m√≥dulos tienen un bajo acoplamiento, significa que est√°n menos interconectados y que los cambios en uno de ellos no afectar√°n al otro. De forma que, lo ideal es que los m√≥dulos tengan un bajo acoplamiento, ya que al minimizar las conexiones entre m√≥dulos tambi√©n se reducen los caminos por lo que se pueden propagar los cambios y los errores a otras partes del sistema. De este modo, se elimina el efecto de que un cambio en un m√≥dulo pueda causar errores en otro, as√≠ evitando realizar modificaciones adicionales para solventarlo. De todas formas, voy a poner un ejemplo para simplificarlo. En este caso, vamos a dos funciones que hacen los mismo (calcular el √°rea de un cuadrado), pero tienen dos niveles de acoplamiento distinto. La primera funci√≥n depende de recibir un input HTML del que se va a leer el valor del lado del cuadrado, para posteriormente devolver el √°rea calculada. Si cambiamos el m√©todo de entrada, no nos quedar√° otra que modificar la funci√≥n. As√≠ que esta funci√≥n representa un alto acoplamiento. Sin embargo, en la segunda funci√≥n, no importa como se haya obtenido el dato que representa el lado del cuadrado, es por ello que presenta un bajo acoplamiento. Resumiendo, cuando hay un alto acoplamiento, es la se√±al de que debemos abstraer de la existencia de otros m√≥dulos en la medida de lo posible. Y como comentamos en el primer p√°rrafo de este art√≠culo, ¬øesto a que os suena? Efectivamente, al Principio de Inversi√≥n de Dependencias. Bajo acoplamiento, alta cohesi√≥n El acoplamiento y la cohesi√≥n, son dos conceptos muy importantes y estrechamente relacionados. Ya que como vimos en los apartados anteriores, si los m√≥dulos de nuestro programa est√°n altamente acoplados, significa que cualquier cambio en uno de ellos puede afectar a los dem√°s y hacer que el c√≥digo sea dif√≠cil de entender y mantener. Por otro lado, si los m√≥dulos tienen alta cohesi√≥n, significa que est√°n altamente relacionados entre s√≠ y que trabajan juntos para lograr una tarea espec√≠fica. Por lo tanto, el objetivo es tener un c√≥digo con alta cohesi√≥n y bajo acoplamiento. Esto hace que el c√≥digo sea f√°cil de entender, modificar y mantener, lo que conduce a un software de mayor calidad y eficiencia. Es como tener un equipo de trabajo bien coordinado, donde cada miembro sabe exactamente lo que tiene que hacer y trabaja en armon√≠a con los dem√°s para conseguir un objetivo com√∫n. En resumen, podemos decir que el acoplamiento y la cohesi√≥n son dos caras de la misma moneda en la programaci√≥n. Una buena gesti√≥n de ambos conceptos puede llevar a un c√≥digo limpio, f√°cil de entender y mantener. As√≠ que ya sabes, ¬°reduce el acoplamiento y aumenta la cohesi√≥n para subir un nivel en el mundo de la programaci√≥n! (con pareado de regalo). Espero que esta primera parte os haya servido para comprender los conceptos. En la segunda parte, veremos m√°s en detalle cada una de ellas, centr√°ndonos en los tipos de acoplamiento y cohesi√≥n existentes, incluyendo ejemplos de cada tipo.",
    "imageMini": "/images/acoplamiento-cohesion-mini.webp"
  },
  {
    "slug": "20230310.html",
    "title": "Caso pr√°ctico TDD",
    "description": "Por poner el broche de oro a esta mini-serie de art√≠culos sobre TDD, vamos a ver un caso pr√°ctico con algo muy sencillo que todos conoc√©is: una pila. Por si queda alg√∫n despistado o despistada, una pila es una lista ordenada que permite almacenar y recuperar valores. El acceso a estos datos sigue el patr√≥n LIFO (del ingl√©s Last In, First Out, \"el √∫ltimo en entrar es el primero en salir\"). B√°sicamente, pod√©is pensar en la t√≠pica pila de platos, en la que el √∫ltimo plato que se pone encima, ser√° el primero que quitemos.",
    "url": "/articles/posts/20230310.html",
    "date": "2023-03-10",
    "categories": [
      "Testing"
    ],
    "content": "Por poner el broche de oro a esta mini-serie de art√≠culos sobre TDD , vamos a ver un caso pr√°ctico con algo muy sencillo que todos conoc√©is: una pila. Por si queda alg√∫n despistado o despistada, una pila es una lista ordenada que permite almacenar y recuperar valores. El acceso a estos datos sigue el patr√≥n LIFO (del ingl√©s Last In, First Out, &quot;el √∫ltimo en entrar es el primero en salir&quot;). B√°sicamente, pod√©is pensar en la t√≠pica pila de platos, en la que el √∫ltimo plato que se pone encima, ser√° el primero que quitemos. Para este caso, se usar√° JavaScript est√°ndar, haciendo uso de clases. De todas formas, si alguien tiene dudas sobre algo del lenguaje, pod√©is preguntarme en comentarios que responder√© con todo gusto. Primer test. Crear una instancia Como estamos usando TDD, lo primero de todo ser√° definir el test a probar: Si ahora ejecutamos el test, fallar√° como cabe espera: Tenemos que escribir el c√≥digo m√≠nimo para que el test pase, as√≠ que, crearemos la clase: Y tendremos nuestro test pasado: De aqu√≠ en adelante, ya no os pondr√© la salida de error y de passed por consola üòâ. Segundo test. Null al quitar un elemento de la pila vac√≠a En este segundo test, vamos a verificar que si ejecutamos la operaci√≥n de quitar un elemento de la pila, y esta se encuentra vac√≠a, se devuelve el valor null . Para hacer que el test pase, como tenemos que escribir el c√≥digo m√≠nimo, simplemente crearemos un m√©todo pop() que devolver√° null al ejecutarlo. Tercer test. A√±adir un valor y eliminarlo Ahora tenemos que probar que si a√±adimos un valor y lo eliminamos se obtiene ese mismo valor. Ahora el c√≥digo de la clase deber√≠a seguir haciendo lo m√≠nimo posible, pero vamos a ir un paso m√°s all√° (para no eternizar el ejemplo), y nos vamos a la fase de refactor, tras la que tendr√≠amos: Cuarto test. Devolver null si no quedan elementos por quitar Obs√©rvese que como a√∫n no hemos gestionado m√°s de un objeto en la cola, no estamos controlando que haya varios, es por ello que en este paso, asignaremos a null el valor, en cuanto llamemos a pop() . Y esto es por la regla de escribir el m√≠nimo c√≥digo posible. Quinto test. A√±adir y eliminar varios valores a la pila Es necesario hacer una aclaraci√≥n en esta parte, ya que si en el test, s√≥lo hubi√©semos a√±adido la √∫ltima comprobaci√≥n, omitiendo el resto de expects , no se hubiera podido verificar la pila nos devuelve cada valor eliminado, y seg√∫n el c√≥digo que ya ten√≠amos, el test pasar√≠a. Es por ello, que tenemos que dar mucha importancia a qu√© se quiere probar, porque un test que no est√© bien escrito, es como si no existiera. En estos casos tambi√©n es importante tener en cuenta, que si escribimos un test, y pasa sin tocar nada de c√≥digo, puede que no estemos probando lo que queremos. Tras un refactor, en este caso tendremos lo siguiente: Se ha incluido una nueva clase, y en este caso, no hemos a√±adido tests para dicha clase, ya que es un getter/setter. A√±adir tests en estos casos no tendr√≠a mucho sentido. Sin embargo, si hubi√©semos necesitado una clase m√°s compleja. Si que en este momento pausar√≠amos el test actual, para comenzar el desarrollo de la nueva clase con TDD. Una vez que hiciera todo lo que necesitamos, volver√≠amos a este test. Sexto test. Devolver longitud 0 cuando la pila est√° vac√≠a S√©ptimo test. Obtener el n√∫mero de elementos a√±adidos En este punto, como el test s√≥lo ha probado el a√±adir elementos, no tenemos que tocar el resto del c√≥digo, s√≥lo la parte de a√±adir. Aunque sea cansino, recordad que vamos a m√≠nimos en cada paso. √öltimo test. Obtener el n√∫mero de elementos tras a√±adir y eliminar varios elementos Conclusiones Despu√©s de haber visto un caso de uso de TDD, creo que podemos concluir que esta t√©cnica es una herramienta valiosa para garantizar la calidad del software y mejorar la eficiencia del proceso de desarrollo. Al escribir las pruebas antes de escribir el c√≥digo, se obliga a pensar cuidadosamente en los requisitos del software y en c√≥mo se comportar√° en diferentes situaciones. El enfoque incremental de TDD tambi√©n significa que el software se desarrolla en peque√±os pasos, lo que facilita la detecci√≥n de errores y la resoluci√≥n de problemas antes de que se conviertan en problemas mayores. ¬øOs ha parecido interesante? ¬øten√©is dudas o sugerencias? Pues ya sab√©is, pod√©is dejar un mensajito en la caja de comentarios.",
    "imageMini": "/images/caso-practico-tdd-mini.webp"
  },
  {
    "slug": "20230225.html",
    "title": "Testing y TDD. Algunos consejos",
    "description": "Tras la introducci√≥n a TDD que tuvimos hace un tiempo, he cre√≠do conveniente ampliar un poco la informaci√≥n del anterior art√≠culo, para exponer algunas anotaciones sobre esta t√©cnica.",
    "url": "/articles/posts/20230225.html",
    "date": "2023-02-25",
    "categories": [
      "testing",
      "TDD"
    ],
    "content": "Tras la introducci√≥n a TDD que tuvimos hace un tiempo, he cre√≠do conveniente ampliar un poco la informaci√≥n del anterior art√≠culo, para exponer algunas anotaciones sobre esta t√©cnica. Si hacemos un repaso r√°pido, podemos recordar que con TDD tendremos los pasos siguientes (de forma resumida): An√°liza : antes de escribir el primer test, nos conviene estudiar que comportamiento deseamos probar, sus posibles entradas y salidas, restricciones, etc. Escribir un test que falle : escribe un test que va a fallar. Ya sea porque falta c√≥digo, o porque aunque ya existe parte de ese c√≥digo a√∫n no tiene todas las funcionalidades que se esperan de √©l. Haz que el test pase : realiza los cambios m√≠nimos para que el test pase correctamente. Refactoriza : ahora puedes cambiar el c√≥digo para mejorarlo. En este punto hay que probar todos los tests para asegurar que no se ha roto nada con el refactor. Escribir el siguiente test que falle . Una vez visto este mini-repaso, pasemos a realizar algunas anotaciones sobre TDD. Anotaci√≥n 1. Conjunto de datos de testing incompleto Uno de los puntos m√°s importantes a tener en cuenta a la hora de trabajar con TDD, es tener un conjunto de datos de entrada y salida que nos d√© la seguridad de tener todas las posibilidades probadas (al menos dentro de lo razonablemente posible). Y es que tener pocos datos, puede provocar que haya casos espec√≠ficos que no sean correctos. Como norma general deber√≠amos tener casos de prueba para lo siguientes tipos de datos: Datos l√≠mite : esto es, el m√≠nimo y m√°ximo permitido. Aplicado a nivel de valores, par√°metros de entrada variables, elementos en una lista, etc. Datos err√≥neos : datos que podr√≠an generar una excepci√≥n en el c√≥digo. Datos que difieran para cubrir lo m√°ximo posible : por ejemplo, en el caso de que la entrada sea un usuario, podr√≠an ser combinaciones dejando campos vac√≠os. Datos que provoquen distintas l√≥gicas : en el caso de una cesta de la compra, deber√≠amos tener pruebas con los distintos m√©todos de pago. Anotaci√≥n 2. Refactorizar dividiendo el c√≥digo Puede que durante un ref√°ctor de una clase o funci√≥n con TDD, veas necesario separar la l√≥gica, ya que el c√≥digo ha crecido mucho y puede que est√© comenzando a incumplir alguno de los principios SOLID . Aqu√≠ tenemos dos posibilidades la l√≥gica y un poco m√°s costosa y la il√≥gica pero m√°s r√°pida: La opci√≥n l√≥gica , ser√≠a comenzar a hacer TDD con esa nueva clase o funci√≥n. Lo bueno es que puedes aprovechar seguramente parte de los casos que tienes y que afectaban al c√≥digo que ibas a extraer. As√≠ se mantiene todo el flujo de TDD, teniendo tests independientes para esta nueva parte. La opci√≥n il√≥gica , implica seguir manteniendo los tests en el componente inicial para que prueben la otra parte. Es m√°s r√°pido porque no requiere cambiar los tests, pero a cambio, tienes tests de una parte de tu c√≥digo en otro elemento. Si este nuevo componente comienza a crecer, el mantenimiento comenzar√° a flaquear por todos lados, adem√°s de que no estar√°n bien organizados. Y recordemos que el c√≥digo de tests, debe ser tan &quot;limpio&quot; como el c√≥digo del proyecto. Anotaci√≥n 3. Actuaci√≥n ante errores Pese a seguir la t√©cnica de TDD, pueden surgir bugs, por ejemplo por casu√≠sticas que no se hab√≠an tenido en cuenta. En este caso, no resuelvas el problema directamente. A√±ade un test con la l√≥gica para provocar el fallo. Una vez hecho esto, comienza a corregir el c√≥digo. Anotaci√≥n 4. Tests de c√≥digo externo previo a una actualizaci√≥n En este caso, la t√©cnica es parecida a la de la anotaci√≥n anterior. Si vamos a actualizar un c√≥digo externo (por ejemplo, una librer√≠a) y queremos usar una funcionalidad nueva. Nos podemos asegurar de que sabemos llamar a esa funcionalidad y que devuelve lo que esperamos, escribiendo primero un test que la intente usar. Posteriormente, actualizaremos la librer√≠a y probaremos de nuevo para ver si hemos entendido como funciona. Crear tests para c√≥digo externo tambi√©n nos permite asegurarnos de que al actualizar la versi√≥n de √©ste, no rompe ninguno de los flujos y comportamientos que esper√°bamos. Como ejemplo: se cambia una entrada de la API p√∫blica y ahora pasa a ser obligatorio un par√°metro que antes era opcional. Al actualizar la librer√≠a y lanzar los tests, todos aquellos que no pasen ese par√°metro obligatorio se romper√°n. Gracias a ello, estaremos en preaviso de que no somos a√∫n compatibles con esa versi√≥n. En este caso, hablar de c√≥digo externo dar√≠a casi para otro art√≠culo. Conclusiones TDD es una herramienta muy potente y permite cierta libertad a la hora de tomar algunas decisiones. Pero ello, no implica que usemos el martillo cogiendo la cabeza en lugar del mango. Es importante tener en cuenta los datos y la utilidad de los tests que estamos creando.",
    "imageMini": "/images/tdd-consejos-mini.webp"
  },
  {
    "slug": "20221220.html",
    "title": "BDD y Gherkin. Una peque√±a introducci√≥n",
    "description": "BDD (Behavior Driven Development) o Desarrollo Dirigido por Comportamiento es una metodolog√≠a que lleva varios a√±os en el tintero, pero d√≠a a d√≠a va cobrando m√°s fuerza. En este art√≠culo aprenderemos m√°s sobre ella.",
    "url": "/articles/posts/20221220.html",
    "date": "2022-12-20",
    "categories": [
      "Testing"
    ],
    "content": "BDD (Behavior Driven Development) o Desarrollo Dirigido por Comportamiento es una metodolog√≠a que lleva varios a√±os en el tintero, pero d√≠a a d√≠a va cobrando m√°s fuerza. En este art√≠culo aprenderemos m√°s sobre ella. Historia de BDD BDD parti√≥ de distintas metodolog√≠as √°giles, que primero fueron comentadas sobre los a√±os 2000 por Dan North . Posteriormente, Dan public√≥ un art√≠culo llamado Introducing BDD , donde comenz√≥ a desarrollar m√°s el tema. Finalmente, el concepto de BDD termin√≥ haci√©ndose un est√°ndar, con la ayuda de Elizabeth Keogh en las charlas que dieron durante la &quot;Agile specifications, BDD and Testing eXchange&quot; celebrada en el a√±o 2009. Y es que BDD naci√≥ como respuesta a los problemas que surg√≠an al empezar con TDD (Desarrollo Dirigido por Pruebas). Ya que la mayor√≠a de programadores y programadoras se encontraban con las mismas preguntas: ¬øD√≥nde comienza el proceso de tests? ¬øQu√© probar y qu√© no probar? ¬øCu√°nto abarca una prueba? ¬øC√≥mo llamar a las pruebas? ¬øC√≥mo entender por qu√© falla una prueba? Conceptos de BDD Inicialmente, la idea de nuestros amigos Dan y Liz era que los tests m√°s complejos se definieran de forma similar a las historias de usuario. Por lo que cualquier persona sin conocimientos t√©cnicos podr√≠a plantear las pruebas. Es por ello, que partiendo de la t√≠pica definici√≥n de historia en el desarrollo √°gil: Se pas√≥ a una definici√≥n de comportamientos y escenarios. As√≠ que ya no definiremos una prueba como tal, sino que pensaremos en el comportamiento que deber√≠a tener dicha aplicaci√≥n. Es por ello, que al desarrollar con BDD, debemos pensar: &quot;¬øcu√°l es la funci√≥n m√°s importante que la aplicaci√≥n no hace?&quot;. Con esa idea en mente, podremos pasar de pensar &quot;no s√© que probar&quot; a tener un comportamiento con &quot;la aplicaci√≥n deber√≠a hacer X&quot;. Una vez que pensamos en comportamientos, en BDD se plantea el siguiente esquema: Esta definici√≥n comprende las siguientes partes: Comportamiento a probar, o funcionalidad que se espera que cumpla el sistema. Por ejemplo, si estamos en una tienda online, el funcionamiento del carrito de la compra. Un comportamiento se compone de distintos escenarios. Los escenarios son los casos que ayudan a verificar el comportamiento. Siguiendo con el ejemplo anterior, pueden ser escenarios: a√±adir un art√≠culo, eliminar un art√≠culo, cambiar la cantidad, etc. Un escenario se compone de lo que se llama pasos, √©stos se encuentran agrupados en: Requisitos , es aquel estado inicial que deja el escenario listo para probar. Las operaciones son los pasos a seguir para probar el escenario. El resultado , tal y como su nombre indica, es lo que se desea verificar tras seguir los pasos. El conjunto de pasos de cada escenario, se pueden relacionar con el sistema de tests en cuatro fases de la forma siguiente: Se puede observar como la fase &quot;Tear down&quot;, no existe de base en BDD, lo que no quita que frameworks como Cucumber permitan tener esta fase en BDD. Ventajas de BDD Tras haber visto un poco la introducci√≥n a BDD, lo siguiente que pod√©is pensar es ¬øqu√© ventajas puede acarear el definir as√≠ las pruebas? Define un est√°ndar para que negocio y desarrollo puedan entenderse : Para ello, se utiliza un lenguaje natural, o muy aproximado al lenguaje natural, de forma que cualquiera puede aprenderlo sin tener conocimientos t√©cnicos. Ayuda a comprender mejor qu√© se espera del desarrollo de la historia : Gracias a la naturalizaci√≥n de los conceptos y las definiciones (sin tener abreviaturas y huyendo de los t√©rminos t√©cnicos de cada tecnolog√≠a), se puede tener un objetivo claro en mente que ayude a comprender que se debe llevar a cabo. Cualquier persona relacionada con la aplicaci√≥n puede definir los casos de uso : Tal y como comentamos antes, al usarse un lenguaje sencillo, no importa que la persona que quiera definir los comportamientos no tenga conocimientos t√©cnicos. Eso s√≠, ser√° importante que s√≠ tenga conocimiento de negocio para evitar casos innecesarios o poco definidos. Ya lo dec√≠a Martin Fowler en su charla Not Just Code Monkeys : &quot;No es tan importante saber determinados lenguajes, estos van y vienen, y en realidad no son tan diferentes entre s√≠. Aprender el dominio en el que est√°s trabajando. Esa s√≠ que es una habilidad muy √∫til.&quot; Martin Fowler En independiente del framework de pruebas utilizado : BDD nos da una serie de pautas para definir los comportamientos, es por ello que, al igual que los patrones de dise√±o se pueden aplicar a pr√°cticamente cualquier lenguaje, todos los frameworks que usemos para BDD ser√°n muy similares. Es muy f√°cil convertir la definici√≥n de una historia en casos BDD y viceversa : Ya hemos visto que los pasos que definen un escenario part√≠an de la definici√≥n est√°ndar de historias en el desarrollo √°gil. Es por ello, que la transcripci√≥n de una historia a BDD es algo casi autom√°tico, si hemos definido la historia de forma correcta. BDD + TDD Recapitulando, hemos visto hasta ahora que, con BDD tenemos una forma est√°ndar de poder definir casos de prueba, as√≠ como de llevarlos a cabo. Pero ¬øc√≥mo encaja esto en un flujo de desarrollo habitual? Pues bien, BDD, se basa en los mismos principios que TDD, es decir, se escribe un caso que falle, se desarrolla y/o se refactoriza hasta hacer que funcione. Como pod√©is ver en la imagen anterior: Escribimos un escenario que falle. Comenzamos con TDD hasta que todos los tests pasen. Una vez que pasen todos los test de lo que podr√≠amos decir, que es la parte TDD, volvemos al escenario para ver si el escenario se prueba correctamente. Si no es as√≠, seguiremos refactorizando. BDD en la pir√°mide de tests No hemos mandado a BDD de viaje por Egipto como si fuera una historia de Ast√©rix, sino que vamos a ver como se integrar√≠a BDD en la famosa pir√°mide introducida por Mike Cohn en su libro Succeeding with Agile . Para aquellas personas que no conozc√°is la pir√°mide de test, b√°sicamente nos indica que peso en la aplicaci√≥n debe tener cada tipo de test. De forma que, de forma resumida, debe haber m√°s tests unitarios y menos tests manuales. La pir√°mide de la imagen tiene algunos cambios respecto a la original, basado en mi experiencia, as√≠ que la podr√≠amos llamar la pir√°mide V2. Paso a comentaros que es cada escal√≥n: Tests unitarios : permiten probar peque√±os componentes o funcionalidades sencillas para verificar que funcionan como se espera de forma aislada. Tests de componentes : siguen siendo tests unitarios pero que agrupan varias funcionalidades en una. Por ejemplo, un test unitario puede aplicarse a un elemento de un men√∫, y un test de componente lo podr√≠amos ejecutar sobre todo un men√∫ compuesto de distintos elementos. En el caso de un servicio REST, un test unitario podr√≠a ser la creaci√≥n de un usuario, y un test de componente, toda la API para gesti√≥n de usuarios. Tests de integraci√≥n : hasta ahora, los dos tipos de tests anteriores si requer√≠an de alguna entidad externa, se creaban mocks para simularla. Sin embargo, con este tipo de tests lo que hacemos es verificar que el comportamiento de nuestro sistema es el esperado cuando interacciona con elementos externos. Por ejemplo, tenemos un servicio REST que llama a otro servicio. Este tipo de tests pueden requerir bastante configuraci√≥n, es por ello que aunque importantes, no tienen tanto peso como los dos escalones anteriores. Tests de sistema o de aceptaci√≥n : se aplicar√≠a o a la interfaz de usuario, pero tambi√©n implica pruebas en sistemas sin interfaz gr√°fica. En este escal√≥n lo que queremos es probar que todo el conjunto de nuestro sistema opera correctamente. Son los tests autom√°ticos que tardan m√°s en ejecutarse, es por ello que normalmente habr√° menos tests de sistema. Test manuales : toda prueba que realiza una persona. Este tipo de tests dependen mucho de qui√©n los realice, es por ello que puede darse el caso que no sean todo lo fiable que nos gustar√≠a. Esta pir√°mide no es algo obligatorio a seguir, incluso dependiendo del tipo de aplicaci√≥n, puede que se llegue a dar incluso una pir√°mide invertida, donde los tests de sistema tengan m√°s peso que los unitarios, una en formato trofeo, donde los de integraci√≥n sean los importantes, etc. Como todo en el mundo de la programaci√≥n, no viene prefijado y se puede ajustar seg√∫n necesidad. Tras el inciso para hablar de la pir√°mide, pod√©is ver que BDD se integrar√≠a en los tests de componentes, integraci√≥n y sistema. No tendr√≠an sentido a nivel de tests unitarios, puesto que tendr√≠amos que definir con BDD hasta el m√°s m√≠nimo comportamiento del m√©todo m√°s peque√±o, esto ser√≠a algo muy engorroso. Por otro lado, respecto a los tests manuales, a una persona se le puede dejar los comportamientos de BDD para que los pruebe, pero es mejor evitar guiar a quien testea, puesto que siempre tender√° a ce√±irse a los escenarios definidos en BDD. Sobre como plantear los test manuales podemos profundizar m√°s en otro art√≠culo, s√≠ as√≠ gust√°is. Gherkin. Un lenguaje para dominarlos a todos Una vez que sabemos como proceder, nos falta conocer el est√°ndar. A nivel conceptual con BDD, no es obligatorio casarse con ning√∫n lenguaje, pero pr√°cticamente el que ha prevalecido sobre los dem√°s, es Gherkin. √âste permite definir las pruebas de una forma natural y expresiva. Pero como todo lenguaje tiene ciertas palabras clave. Y estas son: Ya hab√©is podido comprobar como esa estructura se parece mucho a lo que vimos al principio, y que como la definici√≥n de una historia de usuario puede f√°cilmente adaptarse a ese esquema. De ahora en adelante, los ejemplos tendr√°n las definiciones en ingl√©s, simplemente para que pod√°is ver algo m√°s real, aunque hay librer√≠as como Cucumber que permiten usar otros idiomas, como por ejemplo, el espa√±ol. De todas formas, en la mayor√≠a de los casos seguro que os encontr√°is con definiciones en ingl√©s. Comencemos con un ejemplo de un caso de prueba en la especificaci√≥n de un supuesto reproductor de v√≠deo podr√≠a ser: Esta claro que la especificaci√≥n anterior podr√≠a ser escrita por cualquier persona sin conocimientos t√©cnicos. Y es por ello que Gherkin es tan potente. Pero claro, seguro que echas en falta poder indicar valores a las pruebas, pues bien, en Gherkin se pueden indicar valores para que sean tenidos en cuenta en las pruebas. Sigamos con nuestro reproductor de v√≠deo y pensemos en un bot√≥n que salte un segundo hacia delante. Un escenario podr√≠a ser: Ese valor entrecomillado es un atributo que nuestras pruebas podr√°n leer, aunque por ejemplo, con los valores num√©ricos no es necesario. Eso s√≠, podemos ir m√°s all√°, y trabajar incluso con tablas. Lo siguiente ejecutar√° una prueba por cada fila de la tabla: En este caso, se puede apreciar como es posible recoger los valores de cada columna encerrando el nombre de √©sta entre los s√≠mbolos &lt; y &gt; . Pero esto no termina aqu√≠. Gherkin tiene muchos m√°s operadores y palabras clave: And : permite a√±adir una condici√≥n a cualquiera de los pasos But : condici√≥n negativa para cualquier paso Background : define una condici√≥n que se cumple antes de todos los escenarios. Scenario Outline : permite repetir un escenario varias veces con un conjunto de datos. | : se usa para delimitar tablas. @ : define etiquetas para filtrar escenarios. # : al inicio de una l√≠nea indica comentario. &quot;&quot;&quot; : permite definir un texto de varias l√≠neas. Y con todo lo anterior podemos tener casos todo lo complejos que queramos, como por ejemplo, el siguiente, en el que vamos a simular un almacenamiento en la nube: Qu√© evitar hacer en Gherkin Para mejorar nuestras definiciones de comportamientos hay dos cosillas que deber√≠amos evitar siempre: Usa lenguaje de negocio no tecnol√≥gico Hay que evitar definir los pasos de los escenarios de forma dependiente a la tecnolog√≠a, es decir, deberiamos evitar frases como &quot;haz click&quot;, &quot;realiza una llamada POST&quot;, etc. Por un lado, porque podremos reutilizar los escenarios entre distintas partes del proyecto; y por otro, y m√°s importante, porque qui√©n defina la historia, ya dijimos que puede que no tenga conocimientos t√©cnicos, de forma que no tiene por qu√© saber que por ejemplo una llamada va por API REST, por WS, etc. Con el ejemplo anterior podemos ver como el segundo escenario es posible utilizarlo en una parte back y front. En la primera se tomar√°n credenciales de un rol que pueda crear usuarios y el test terminar√° realizando una llamada a un API, y en la segunda se realizar√°n todos los pasos necesarios para crear el usuario desde interfaz. Evitar pasos que puedan tener doble sentido Es importante evitar utilizar nombres de steps que tengan distintos contextos. Si por ejemplo, tenemos un paso con el contenido &quot;se borra el texto&quot;, seguramente depender√° del escenario en qu√© se use. Es por ello, que es preferible tenemos pasos con contenidos como &quot;se borra el nombre de usuario&quot;, &quot;se borra el t√≠tulo del art√≠culo&quot;, etc. Por un lado, queda mucho m√°s claro qu√© hace el paso, y por otro permite evitar confusiones. Antes de terminar Una vez que hemos aprendido algo sobre BDD y Gherkin es manos de ponerse a la obra, as√≠ que ¬øc√≥mo podemos seguir? Pues, para aplicar esto ten√©is frameworks como Cucumber que nos ayuda a implementar BDD. Pero, recordad que BDD es una metodolog√≠a, por lo que no os obliga a casaros con ning√∫n framework y lo pod√©is implementar libremente.",
    "imageMini": "/images/bdd-mini.webp"
  },
  {
    "slug": "20221218.html",
    "title": "Plantilla de proyecto TypeScript",
    "description": "A la hora de comenzar un nuevo proyecto, suele costar bastante configurar todo. Es por ello, que por simplificar un poco las cosas, acabo de crear una plantilla, basada en TypeScript, Vite y Jest. Para usarla, pod√©is crear un fork o descargar el c√≥digo y ajustarlo a vuestras necesidades libremente. Este c√≥digo lo pod√©is encontrar en GitHub. Esta plantilla necesita de node en su versi√≥n 16.0.0 como m√≠nimo.",
    "url": "/articles/posts/20221218.html",
    "date": "2022-12-18",
    "categories": [
      "TypeScript",
      "plantilla"
    ],
    "content": "A la hora de comenzar un nuevo proyecto, suele costar bastante configurar todo. Es por ello, que por simplificar un poco las cosas, acabo de crear una plantilla, basada en TypeScript , Vite y Jest . Para usarla, pod√©is crear un fork o descargar el c√≥digo y ajustarlo a vuestras necesidades libremente. Este c√≥digo lo pod√©is encontrar en GitHub . Esta plantilla necesita de node en su versi√≥n 16.0.0 como m√≠nimo. Comandos Una vez que teng√°is el proyecto, podr√©is ejecutar distintos comandos anteponiendo npm run . dev : Modo de desarrollo, lanza un servidor de live-preview, que va actualiz√°ndose seg√∫n hac√©is cambios en el c√≥digo: compilando el c√≥digo TypeScript y actualizando las referencias. build : Compila y minifica el c√≥digo, de forma que lo deja listo para usar en el entorno de distribuci√≥n. El resultado final lo podr√°s encontrar en el directorio dist . preview : Lanza un servidor para poder ver los cambios del distribuible generado. test : Lanza los tests unitarios. Estructura La estructura del proyecto es muy sencilla. En la carpeta ra√≠z se tiene el fichero index.html , que hace de punto de partida, y todo el c√≥digo fuente se almacena en el directorio src . Dicho directorio, a su vez, contiene la carpeta __tests__ , donde se incluir los tests unitarios a desarrollar con Jest. Enlace al repositorio typescript-boilerplate .",
    "imageMini": "/images/tsvitejest-mini.webp"
  },
  {
    "slug": "20221211.html",
    "title": "Testing y TDD",
    "description": "A d√≠a de hoy, muchas veces el software falla porque lo programan personas, por lo que es factible que tenga errores. As√≠ que como desarrolladores y desarrolladoras, debemos siempre intentar minimizar esos fallos. Para ello disponemos de varias herramientas, y una de las m√°s √∫tiles son los tests. Estos pueden ser autom√°ticos o manuales.",
    "url": "/articles/posts/20221211.html",
    "date": "2022-12-11",
    "categories": [
      "testing",
      "TDD"
    ],
    "content": "Tests A d√≠a de hoy, muchas veces el software falla porque lo programan personas, por lo que es factible que tenga errores. As√≠ que como desarrolladores y desarrolladoras, debemos siempre intentar minimizar esos fallos. Para ello disponemos de varias herramientas, y una de las m√°s √∫tiles son los tests. Estos pueden ser autom√°ticos o manuales. Si hablamos de la vertiente autom√°tica, se puede definir un test como un bloque de c√≥digo que permite aseverar el cumplimiento de determinadas afirmaciones. A su vez, cada afirmaci√≥n viene dada por una sentencia, en la que un m√©todo o una funci√≥n comprueban si un valor cumple con las expectativas. ¬øC√≥mo deber√≠an ser los tests? A la hora de testear podemos seguir algunas directrices: Confianza en el c√≥digo : Es importante que pruebes todo lo que sea necesario para tener confianza en el c√≥digo desarrollado. No significa que se deba probar hasta el m√°s m√≠nimo resquicio, sino que pruebes todos los comportamientos que se esperan. Reducir el c√≥digo malo : Usa los tests para reducir en la medida de lo posible el mal c√≥digo. Por ejemplo, si surge un error, deber√≠as crear un test que asegure que √©ste problema no se vaya a repetir en el futuro. Adem√°s, estos nuevos tests te ayudar√°n a documentar el error. Prueba una cosa, afirma varias : Incluye todas las afirmaciones que sean necesarias en un test. Lo importante es asegurarnos de que todas las partes afectadas por el test tengan los datos correctos. Los tests primero : Deber√≠as definir los tests a realizar antes de programar. Esto significa que es buena idea pensar el enunciado de los tests, para tener una visi√≥n global de la funcionalidad a desarrollar. Adem√°s, ayudar√° a entender mejor que se debe hacer. Ejecuta los tests : Parece una obviedad, pero es muy importante que una vez que exista un test se ejecute siempre. Por ejemplo, los tests unitarios deber√≠as ejecutarlos al menos, antes de hacer un commit y antes de hacer un deploy a un entorno de test. Lanzar los tests necesarios en los momentos necesarios : Es importante que aprendas a ejecutar un subconjunto de tests unitarios, ya que aunque los tests sean r√°pidos por si s√≥los, en cuanto haya unos cientos, el tiempo de ejecuci√≥n total puede ser bastante alto. Es por ello, que mientras desarrollas debes saber como poder ejecutar s√≥lo los tests que est√©s modificando, para ahorrar tiempo. Esto no quita que, de vez en cuando, ejecutes toda la suite de tests para asegurarte de que todo sigue en su sitio. Automatiza la ejecuci√≥n de tests : A d√≠a de hoy resulta casi impensable que haya un sistema de CI/CD (Integraci√≥n continua, despliegue cont√≠nuo), que durante el proceso no ejecute los tests, ya sean unitarios, de integraci√≥n, etc. Tests en las revisiones : Es buena idea comenzar a ver los casos de tests que has creado en las revisiones de c√≥digo. Por un lado, junto con la definici√≥n de la historia, puede ayudar a quienes van a revisar el c√≥digo a entender si se cumple el comportamiento de la funcionalidad desarrollada. Por otro, seguro que te obliga a revisar mejor los tests antes de ense√±arlos a otras personas. Y si no haces revisiones de c√≥digo, deber√≠as comenzar cuanto antes &#x1f609;. Nomenclatura de los tests Una de las primeras recomendaciones al escribir el nombre de los tests, es comenzar a utilizar la palabra &quot;should&quot; (&quot;deber√≠a&quot; en castellano). Puede parecer una tonter√≠a, pero su sem√°ntica nos puede ayudar a entender el por qu√©: cuando indicamos, por ejemplo, un nombre del estilo &quot;deber√≠a hacer X cuando Y&quot;, √©ste ya nos est√° ayudando a pensar si realmente esa funcionalidad es del componente a testear. Incluso si a futuro la funcionalidad ha cambiado, tendr√° todo el sentido del mundo ver que el nombre del test nos &quot;pregunte&quot; si deber√≠a seguir ocurriendo lo que hac√≠a. Si vemos que no se puede escribir un test bajo esa premisa, quiz√°s sea porque √©ste deber√≠a pertenecer a otro elemento en el c√≥digo: una clase nueva, otra funci√≥n, etc. Y es que a la hora de redactar pruebas, se comprueba como un test con un buen nombre brilla en los momentos en los que √©ste falla. Si el nombre no te aporta nada cuando el test falla, debes darle una vuelta para mejorarlo. Pensemos por ejemplo en la t√≠pica funcionalidad que nos env√≠a un correo de confirmaci√≥n al cambiar nuestra contrase√±a. Si tengo una clase que gestiona la autenticaci√≥n de usuario, no tiene sentido tener un test: &quot;deber√≠a autenticarme con el usuario X, acceder a su configuraci√≥n, cambiar la contrase√±a y recibir un email de confirmaci√≥n&quot;. Con esto, vemos por ejemplo, como el nombre del test nos da la pista de que esa clase est√° haciendo demasiadas cosas, lo que incumple la S de los principios SOLID , llev√°ndonos a liberarla de responsabilidades. Flujo de test en cuatro fases A la hora de escribir tus pruebas viene bien seguir el patr√≥n de test en cuatro fases , que nos define qu√© flujo de ejecuci√≥n deber√≠a seguir cada test: Setup : fase en la que se construye todo lo necesario para que el test tenga listo el entorno de su ejecuci√≥n. Exercise : pasos para que el test se ejecute. Por ejemplo: instanciar una clase y llamar a varios de sus m√©todos. Verify : comprobaci√≥n del resultado esperado tras ejecutar los pasos de Exercise. Teardown : fase opcional en la que se restaura todo lo modificado por el test. Normalmente, esto aplicar√° m√°s a estructuras compartidas globalmente, mocks est√°ticos, etc. TDD A finales de los 90 del siglo pasado Kent Beck , como parte de Extreme Programming, desarroll√≥ y especific√≥ la t√©cnica TDD (Test-Driven Development o Desarrollo Guiado por Test). B√°sicamente, se basa en construir el software a trav√©s de la escritura de tests, definiendo tres sencillos pasos a seguir basados en los colores de los sem√°foros: Beneficios de TDD TDD pone el foco en el comportamiento (recordad esta palabra) del c√≥digo y no en su implementaci√≥n, puesto que al desarrollar con TDD se escribe cada test antes de su correspondiente c√≥digo de producci√≥n. Seguir esta orientaci√≥n en el desarrollo te proporciona varios beneficios: Vas a escribir c√≥digo como respuesta a que un test pase. Esto significa que el c√≥digo va a estar bien testeado y el c√≥digo no har√° m√°s de lo que debe. El segundo es que este planteamiento te har√° pensar primero en la interfaz del c√≥digo, antes de que en su implementaci√≥n. Lo que te ayudar√° a tener mejor estructurado el c√≥digo y s√≥lo hacer p√∫blico lo que sea necesario. Finalmente, como resultado a los dos beneficios anteriores, tenemos un c√≥digo con menos errores. Y es que en el estudio &quot;Does Test-Driven Development Really Improve Software Design Quality?&quot; de David S. Janzen y Hossein Saiedian, ya se indica como con TDD se reduce sustancialmente el n√∫mero de errores que aparecen en el software al aplicar la t√©cnica. Flujo de desarrollo en TDD Momento de pensar : por desgracia es la fase m√°s olvidada en los flujos de desarrollo, y es que antes de escribir una s√≥la l√≠nea de c√≥digo, habr√≠a que detenerse a pensar cu√°l es el objetivo del c√≥digo que vamos a desarrollar, que posibles restricciones o casos especiales hay, etc. Todo esto nos ayudar√° a tener un esquema del comportamiento esperado para la funcionalidad a crear, y evitar√° los cambios de √∫ltima hora porque no tuvimos en cuenta el alcance de lo que se quer√≠a desarrollar. Escribe el primer test : una vez que tenemos claro el objetivo a conseguir. Escribiremos el primer test... S√≠, a√∫n no hay nada de c√≥digo, pero el test usar√° la interfaz que nos gustar√≠a crear, esto te ayudar√° a pensar no en la implementaci√≥n del c√≥digo, sino en la interfaz que como &quot;agente externo&quot; te gustar√≠a usar. Este primer test, como es l√≥gico, va a fallar. Hora de programar : ahora es el momento de implementar el esqueleto que usaste en el test, hasta hacer que √©ste pase. Refactoriza : una vez que los tests de la funcionalidad que quer√≠as desarrollar se ejecuten correctamente, es el momento de revisar y refactorizar el c√≥digo para que quede lo mejor posible. Sobra decir, que tras refactorizar, los tests deben seguir terminando de forma satisfactoria. Eso s√≠, lim√≠tate a refactorizar el c√≥digo actual, no pienses en futuras mejoras (que puede que nunca lleguen), recuerda que refactorizar no significa cambiar el comportamiento del c√≥digo. Volver a la casilla de salida : cuando tengas una nueva funcionalidad, tan s√≥lo tendr√°s que repetir los pasos. La clave principal de este flujo de desarrollo, es realizar peque√±os cambios de forma incremental. Por lo que en todo momento, se espera que el c√≥digo escrito est√© bien testeado. Legacy code y TDD TDD no s√≥lo sirve para desarrollos nuevos. En el caso de tener que modificar legacy code (c√≥digo antiguo u obsoleto y que normalmente no tendr√° tests), TDD nos permitir√° seguir un flujo que ayude a comprobar este c√≥digo. Primero escribiremos los tests para verificar que se comprueba lo que hace el c√≥digo antiguo. Una vez que tenemos los tests, ya podemos comenzar a a√±adir o corregir las funcionalidades. Si es una nueva funcionalidad seguiremos el flujo habitual. En caso de que se vaya a corregir un comportamiento err√≥neo, se partir√° por retocar el test que se hizo pasar con el comportamiento err√≥neo, para adaptarlo a la correcci√≥n. A partir de ah√≠, el test fallar√° y ya podremos comenzar con nuestro ciclo TDD habitual. Conclusiones TDD plantea muchas ventajas a la hora de desarrollar: Permite pensar primero antes de escribir una sola l√≠nea de c√≥digo. Ayuda a definir una interfaz √∫til basada en lo que es necesario. Permite reducir sustancialmente el n√∫mero de errores. Mejora la mantenibilidad del software. Por contra, su mayor inconveniente es el coste de acostumbrarse a aplicarlo. Por lo que inicialmente desarrollar√°s m√°s lento. Pero a la larga, aparte de mejorar en velocidad, podr√°s comprobar como el tiempo de desarrollo global se reduce, puesto que estar√°s introduciendo menos errores en el c√≥digo, de forma que no se perder√° tanto tiempo en mantenerlo. Una vez que conocemos los conceptos de TDD, el siguiente paso ser√° ir a por BDD...",
    "imageMini": "/images/tdd-mini.webp"
  },
  {
    "slug": "20221029.html",
    "title": "Cosas que quiz√°s no sab√≠as de CSS",
    "description": "Con la reciente encuesta del estado de CSS, vamos a comentar algunas caracter√≠sticas que pueden ser menos conocidas de CSS. Espero que os sirva de ayuda &#x1f603;.",
    "url": "/articles/posts/20221029.html",
    "date": "2022-10-29",
    "categories": [
      "Programaci√≥n",
      "CSS"
    ],
    "content": "Con la reciente encuesta del estado de CSS , vamos a comentar algunas caracter√≠sticas que pueden ser menos conocidas de CSS. Espero que os sirva de ayuda &#x1f603;. 1. Visualizar texto en vertical ¬øAlguna vez has querido poner un texto en vertical y has estado jugando con los filtros de CSS? Pues, una forma muy sencilla de situar un texto en vertical es con la propiedad writing-mode . 2. Espacio entre elementos ¬øRecuerdas los tiempos en los que para dise√±os con varias filas y columnas usabas las propiedades margin y padding para dejar espacio entre ellas? Pues eso es cosa del pasado gracias a la propiedad gap . Quiz√°s, ya conoc√≠as esto, pero lo que menos gente sabe es que, por un lado, gap, es unalias de grid-gap (puedes usar ambas de forma indistinta); y por otro que ambos son un shorthand o propiedad abreviada de grid-row-gap , y column-row-gap . Por lo que podemos especificar un espaciado distinto para filas y columnas, algo que pod√©is comprobar en el ejemplo siguiente: Esta propiedad la podr√©is usar con flex, grid y columnas (algo que veremos en el punto siguiente). 3. Texto en columnas de forma sencilla Lo primero que se te vendr√° a la cabeza al hablar de texto en columnas, puede que sea un peri√≥dico. Y es que si necesitamos aplicar ese estilo, ya no nos tenemos que romper la cabeza, pues la propiedad column-count viene al rescate. Con ella, b√°sicamente podemos indicar en cuantas columnas se dividir√° el texto. 4. Filtros Ya llevan varios a√±os entre nosotros, pero por si no lo sab√≠as puedes aplicar una gran cantidad de efectos gr√°ficos mediante el uso de CSS con la propiedad filter . Esta propiedad permite un sinf√≠n de posibilidades, tantas que dar√≠an para un art√≠culo (o varios). Ya que podemos combinar distintos efectos en un √∫nico filtro. En el c√≥digo de ejemplo, os pongo una imagen (aunque se puede aplicar a cualquier elemento sea o no una imagen), a la que se aplican distintos filtros con CSS. 5. Ajustar el alto (y el ancho) al contenido Una de los valores predefinidos menos conocidos de CSS es fit-content . Aplicado al alto o al ancho de un componente, lo que hace es ajustar el tama√±o del bloque HTML (ya sea ancho, alto o ambos) a su contenido. Un ejemplo lo pod√©is ver a continuaci√≥n, donde al usar en √©ste flex, el alto de cada elemento se &quot;estira&quot; para igualarse al que tenga un alto mayor. Con la funci√≥n fit-content , lo que haremos es que el componente que menos altura tiene se quede con √©sta, en lugar de estirarse. Esta funci√≥n se puede usar sin par√°metros o de una forma m√°s compleja, especificando el m√≠nimo y el m√°ximo. 6. Cambiar el color de fondo de algunos controles Seguro que m√°s de una vez has visto que se oculta un checkbox con CSS para poner una especie de capa por encima que deje el checkbox con otro estilo u otros colores. Desde hace un tiempo, al menos si lo hac√≠a por cambiar los colores, ya no es necesario. En este caso, con la propiedad accent-color , podr√°s modificar el color de fondo de checkbox, radio buttons, rangos y barras de progreso. 7. Aplicar estilos seg√∫n el tema de color del sistema operativo CSS ha avanzado mucho en los √∫ltimos tiempos, y prueba de ello es que ahora podemos aplicar distintos estilos seg√∫n el tema de color del sistema operativo. Para ello, disponemos de la media-query prefers-color-scheme . Con ella podemos comprobar si el usuario ha seleccionado un tema claro u oscuro (valores light y dark ), y seg√∫n esto aplicar distintos estilos. Para probar el ejemplo siguiente, cambia el tema de color de tu sistema operativo. Si el navegador con el que est√°s viendo esta p√°gina lo soporta, deber√≠as ver como cambian los colores del fondo y el texto.",
    "imageMini": "/images/css-mini.webp"
  },
  {
    "slug": "20220914.html",
    "title": "Web Workers en JavaScript",
    "description": "Estar√°s acostumbrado o acostumbrada a escuchar que JavaScript corre sobre un √∫nico hilo de ejecuci√≥n. Esto puede en ocasiones acarrear problemas si una tarea es demasiada pesada, pues dejar√° bloqueado el hilo.",
    "url": "/articles/posts/20220914.html",
    "date": "2022-09-14",
    "categories": [
      "JavaScript"
    ],
    "content": "Estar√°s acostumbrado o acostumbrada a escuchar que JavaScript corre sobre un √∫nico hilo de ejecuci√≥n. Esto puede en ocasiones acarrear problemas si una tarea es demasiada pesada, pues dejar√° bloqueado el hilo. Para solventar ese problema, se dispone de los Web Workers , que permiten ejecutar c√≥digo JavaScript en hilos que se lanzan en segundo plano. Cabe destacar que estos workers utilizan un contexto global distinto al de la ventana (o worker) que lo lanza. Como consejo puedes usar globalThis para reducir dependencias de usar window , self , etc. El m√©todo de comunicaci√≥n del worker con su creador es a trav√©s de mensajes gestionados como eventos. De forma muy parecida al sistema de comunicaci√≥n entre iframes. Pero como siempre, ser√° mejor que veamos el funcionamiento de los workers con varios ejemplos. Hola mundo de los workers En el c√≥digo superior se puede ver lo sencillo que es crear un Web Worker. La ejecuci√≥n del c√≥digo terminar√° mostrando en la consola: &quot;Message received from worker: Hello from the worker&quot; . A la hora de definir un worker, se especifica la ruta en la que se encuentra el script que se ejecutar√° en segundo plano. Posteriormente, se pasa a escuchar los mensajes que env√≠e el worker asignando un callback al atributo onmessage . El callback asignado, recibir√° como un objeto como par√°metro que contendr√° el atributo data con el contenido del mensaje enviado por el worker. Este contenido puede ser de cualquier tipo de dato. Mensajer√≠a entre Worker y creador En el caso de enviar un objeto en los mensajes, no hay problema de recursos compartidos, ya que se hace autom√°ticamente un deep clone de dicho objeto. Este clonado se lleva a cabo gracias a la funci√≥n structuredClone , que por si la desconoces, permite clonar objetos. Todo esto lo veremos con un ejemplo que incluye algo de sobreingenier√≠a, pero nos servir√° para verificar que no hay paso de objetos por referencia. Al ejecutar el c√≥digo anterior, se podr√° comprobar como en result se recibe un objeto con atributo value igual a 123; por otro lado el objeto data sigue teniendo el atributo value con valor 3. Esto es por lo que hemos comentado al principio de este apartado, los valores de los mensajes se pasan por valor y no por referencia. Control de errores Aparte de la mensajer√≠a est√°ndar, es posible capturar aquellos errores que generen los Web Workers. Para ello asignaremos al atributo onerror del worker un callback que recibir√° el evento con el error. La ejecuci√≥n superior mostrar√° en consola: Como se puede apreciar, se recibe aparte del error generado, el fichero, as√≠ como la l√≠nea y columna en la que √©ste ha ocurrido. Finalizar un worker En el caso que queramos dar por finalizado un worker desde el creador, llamaremos al m√©todo terminate() , de forma que en este caso se termine la ejecuci√≥n del worker, sin darle tiempo a realizar un &quot;cierre ordenado&quot;. Por otro lado, un worker puede indicar que ha terminado llamando a globalThis.close() (o self.close() ). En ambos casos, aunque se intenten enviar mensajes entre creado y worker, ya se habr√° cerrado ese canal de comunicaci√≥n. Conclusi√≥n Los Web Worker permiten llevar a cabo tareas pesadas fuera del hilo principal de JavaScript, y como habr√©is podido comprobar, es posible definirlos de forma muy sencilla. Tan s√≥lo hay que especificar el fichero a utilizar como worker, y comunicar el creador y el worker con mensajes. Finalmente, tan s√≥lo remarcar, que no todos los objetos globales est√°n disponibles en los Web Workers, puedes encontrar el listado completo en MDN .",
    "imageMini": "/images/web-worker-mini.webp"
  },
  {
    "slug": "20220912.html",
    "title": "Faker: usa datos realistas en tus pruebas y demos",
    "description": "¬øTe has cansado de usar siempre John Doe o Juanita Banana como nombre en tus pruebas? ¬øSientes que los tests no tienen datos realistas? ¬øQuieres hacer una demo con datos que parezcan completamente aut√©nticos?",
    "url": "/articles/posts/20220912.html",
    "date": "2022-09-12",
    "categories": [
      "librer√≠as",
      "JavaScript",
      "TypeScript",
      "programaci√≥n",
      "testing"
    ],
    "content": "¬øTe has cansado de usar siempre John Doe o Juanita Banana como nombre en tus pruebas? ¬øSientes que los tests no tienen datos realistas? ¬øQuieres hacer una demo con datos que parezcan completamente aut√©nticos? En ese caso, Faker es exactamente lo que necesitas. Esta librer√≠a para JavaScript y TypeScript te permite generar datos aleatorios pero incre√≠blemente veros√≠miles: nombres, direcciones, correos electr√≥nicos, colores, contrase√±as, t√≠tulos de trabajo, elementos qu√≠micos, palabras, im√°genes y much√≠simo m√°s. En este art√≠culo ampliado veremos c√≥mo usarla y a√±adiremos un ejemplo completo de generaci√≥n de datos falsos para una aplicaci√≥n realista. Instalaci√≥n del proyecto Para que puedas hacer una prueba r√°pida, lo primero ser√° inicializar un proyecto con TypeScript e instalar la librer√≠a: Ahora debemos indicar que podamos importar m√≥dulos. Para ello a√±ade al package.json lo siguiente: Listo. Ya podemos comenzar a generar datos realistas. Uso b√°sico Ejemplo realista: generar usuarios para una API o demo Imagina que quieres poblar una base de datos local o simular un backend para una demo de frontend. Necesitas 20 usuarios coherentes , con su nombre, email, imagen de avatar, direcci√≥n completa y un rol laboral. Con Faker es tan sencillo como esto: Esto produce algo del estilo: Como puedes ver, esta librer√≠a es perfecta en casos como los siguientes: Necesitas rellenar una base de datos ficticia. Debes mostrar un listado de ejemplo con usuarios, productos, etc. en tu interfaz. Quieres simular peticiones a una API con datos realistas. Vas a preparar demos sin datos personales reales. Conclusi√≥n Hemos podido ver como Faker es una herramienta imprescindible para demos, prototipos y testing. Te ahorra tiempo, te evita tener que inventar datos y te permite trabajar con ejemplos mucho m√°s naturales. Adem√°s, de a√±adir un punto de aletoriedad que puede venir bien a la hora de testear el c√≥digo. A√∫n hay muchas m√°s funciones a utilizar. Pero lo mejor es dar una vuelta a la documentaci√≥n para descubrirlas todas. Espero que de ahora en adelante, puedas enriquecer los datos simulados gracias a esta librer√≠a.",
    "imageMini": "/images/faker-mini.webp"
  },
  {
    "slug": "20220807.html",
    "title": "Decorator para gente novata",
    "description": "Si hay un patr√≥n de dise√±o que suele provocar algunas dudas, es el patr√≥n Decorator. Pero b√°sicamente, este patr√≥n nos permite a√±adir responsabilidades a objetos de forma din√°mica, es decir, que podemos ajustar el comportamiento de los objetos durante la ejecuci√≥n de la aplicaci√≥n. Con ello podemos ir a√±adiendo o quitando los cambios en el comportamiento en tiempo real. Esto por ejemplo, no ser√≠a posible con herencia, ya que se realiza de forma est√°tica y no podemos cambiarla en tiempo de ejecuci√≥n. La herencia tampoco nos permitir√≠a tener varias clases madre (en la mayor√≠a de lenguajes), por lo que no podemos \"unir\" varios de esos cambios de comportamiento.",
    "url": "/articles/posts/20220807.html",
    "date": "2022-08-07",
    "categories": [
      "programaci√≥n",
      "dise√±o y arquitectura"
    ],
    "content": "Introducci√≥n Si hay un patr√≥n de dise√±o que suele provocar algunas dudas, es el patr√≥n Decorator. Pero b√°sicamente, este patr√≥n nos permite a√±adir responsabilidades a objetos de forma din√°mica, es decir, que podemos ajustar el comportamiento de los objetos durante la ejecuci√≥n de la aplicaci√≥n. Con ello podemos ir a√±adiendo o quitando los cambios en el comportamiento en tiempo real. Esto por ejemplo, no ser√≠a posible con herencia, ya que se realiza de forma est√°tica y no podemos cambiarla en tiempo de ejecuci√≥n. La herencia tampoco nos permitir√≠a tener varias clases madre (en la mayor√≠a de lenguajes), por lo que no podemos &quot;unir&quot; varios de esos cambios de comportamiento. Ejemplo Para entenderlo un poco mejor, partamos de un ejemplo sencillo del mundo &quot;videojueguil&quot;. Pensemos en un juego como el reboot de Tomb Raider, en el que las armas tienen modificaciones. Estas modificaciones incrementan el da√±o de las armas, la precisi√≥n, etc. Lo anterior podr√≠amos resolverlo de muchas formas, pero una de ellas es con decoradores, podemos tener el arco base, al que si le a√±adimos &quot;Palas Reforzadas&quot;, se incrementa el da√±o, si aparte le a√±adimos &quot;Cuerda Trenzada&quot; incrementamos m√°s el da√±o, etc. Pues bien, cada tipo de &quot;a√±adido&quot; ser√≠a un decorador que modificar√≠a las propiedades del arco, y lo mejor de todo, es que podremos tener varios decoradores de forma simult√°nea. De forma que un arco, siguiendo el ejemplo anterior podr√° tener las &quot;Palas Reforzadas&quot; y la &quot;Cuerda Trenzada&quot; de forma simult√°nea. Diagrama En el diagrama UML, vemos que b√°sicamente hay una interfaz que implementa las operaciones p√∫blicas de la clase que queremos &quot;envolver&quot; con decoradores, y que dicha clase, pasar√° a implementar la interfaz. Por otro lado, tenemos la parte de decoradores, en la que tenemos un decorador base y los decoradores hijos, todos ellos implementando la interfaz inicial. Paso a paso Con todo lo anterior, tendr√≠amos los pasos siguientes para implementar el patr√≥n Decorator: Extraer a una interfaz los m√©todos de la clase o las clases que queremos decorar. Crear un decorador base que implemente la interfaz y que reciba adem√°s dicha interfaz como par√°metro en su constructor. Crear clases hijas del decorador, que se encargar√°n de actuar sobre la clase base. Ejemplo de c√≥digo Ahora que tenemos las nociones, hemos visto el UML, y tenemos &quot;la chuleta&quot; para aplicarlo, vamos a ver un ejemplo muy sencillo a aplicar en un juego de naves. Nuestra nave parte de un arma base que puede modificarse, y tambi√©n puede tener mini-naves a los lados que le ayuden. Si seguimos el primer paso del apartado anterior, lo primero que haremos ser√° sacar a una interfaz los m√©todos p√∫blicos de nuestra clase. El segundo paso es crear un decorador base: Y finalmente, definimos los decoradores que necesitamos, En nuestro caso, tenemos la posibilidad de a√±adir misiles y l√°sers, adem√°s de mini-naves. Como pod√©is ver en este ejemplo, los decoradores no tienen por qu√© modificar siempre todos los m√©todos p√∫blicos: Ahora que tenemos los tres decoradores, pasemos a jugar con ellos para ver los resultados. Y listo, ya tenemos nuestro primer ejemplo de patr√≥n Decorator listo para entregar. Desventajas Hay que tener mucho cuidado con el uso del objeto original, ya que si en alg√∫n momento lo hemos decorado, pero en otros sitios del c√≥digo estamos usando el objeto sin decoraci√≥n, puede provocar problemas y ser complejo de encontrar si no lo recordamos. Puede que se necesiten generar demasiados decoradores para unas clases, lo que nos generar√° much√≠simas clases peque√±as, que si no est√°n bien organizadas, ser√°n dif√≠ciles de seguir. Si se necesitan llamadas a m√©todos p√∫blicos que no van a ser usados por decoradores, tocar√° implementar igualmente la llamada del decorador base. Por ejemplo, si en tu clase s√≥lo necesitas decorar, 1 o 2 m√©todos, y tienes otros 10 m√©todos p√∫blicos para los que no es necesario, quiz√°s debas de darle una vuelta al c√≥digo. En algunos casos los decoradores deben tener un orden espec√≠fico para usarse, si no provocar√°n otro tipo de resultados. Es por ello, que estos casos hay que documentarlos muy bien y dejar el m√≠nimo margen de error. Es complejo poder quitar un decorador de la pila aplicada al objeto base. Por lo que o cada vez que haya que cambiar decoradores los aplicas de nuevo uno a uno, o debes implementar un sistema para poder quitar decoradores intermedios. Conclusiones El patr√≥n Decorator, como todos los patrones, ofrece mucha potencia para ciertos casos, pero hay que tener cuidado con saber distinguirlos bien, puesto que como hemos visto en las desventajas, su uso libre en todas las ocasiones que lo sugieran puede complicar las cosas en lugar de hacerlas m√°s sencillas. Es por ello, que te recomiendo que experimentes y analices bien cada situaci√≥n que lo requiera. Eso s√≠, como hab√©is podido comprobar, es muy sencillo de llevar a cabo.",
    "imageMini": "/images/decorator-mini.webp"
  },
  {
    "slug": "20220715.html",
    "title": "AbortController: cancela operaciones en JavaScript",
    "description": "Hasta ahora, en JavaScript, cuando se lanzaba una llamada a una API con fetch, no resultaba sencillo detenerla. Tambi√©n se pod√≠a dar el caso de que quisi√©ramos detener varias operaciones que se ejecutaban de simult√°neamente de forma centralizada, por lo que ten√≠amos que implementar sistemas como el patr√≥n observador.",
    "url": "/articles/posts/20220715.html",
    "date": "2022-07-15",
    "categories": [
      "programaci√≥n",
      "JavaScript"
    ],
    "content": "Hasta ahora, en JavaScript, cuando se lanzaba una llamada a una API con fetch, no resultaba sencillo detenerla. Tambi√©n se pod√≠a dar el caso de que quisi√©ramos detener varias operaciones que se ejecutaban de simult√°neamente de forma centralizada, por lo que ten√≠amos que implementar sistemas como el patr√≥n observador. Pero en la actualidad, estos flujos ahora son m√°s f√°ciles gracias a la clase AbortController que viene a proporcionarnos una forma de enviar una se√±al de parada a todo elemento que lo utilice. B√°sicamente, tendremos una se√±al ( AbortSignal ) que se emitir√° cuando queramos cancelar una operaci√≥n. Veamos el uso m√°s b√°sico, y que est√° en miles de ejemplos: En el c√≥digo anterior podemos ver como el uso de AbortController se reduce a obtener su se√±al, con signal , y a llamar al m√©todo abort() para lanzar la se√±al. Aunque es una herramienta muy potente, no hay mucho m√°s que explicar... bueno s√≠, el 99,9% de los ejemplos que pod√©is encontrar, son como el que he puesto en las l√≠neas anteriores, pero, ¬øy si quer√©is usar la clase AbortController en algo que no sea un fetch? ¬øC√≥mo se puede escuchar el cambio en la se√±al? Pues a continuaci√≥n he preparado un c√≥digo muy sencillito. En √©l pod√©is ver como hay tres contadores avanzando, lo que haremos es detenerlos mediante una se√±al: Lo que hemos hecho es definir una clase Timer a la que pasamos la se√±al de abortar la operaci√≥n: En el constructor escuchamos el evento abort para dicha se√±al asoci√°ndolo con un event listener e indicando al c√≥digo a ejecutar cuando llegue dicha se√±al. En nuestro caso el m√©todo #onAbort() : Podemos, adem√°s enviar una cadena para indicar la raz√≥n por la que hemos enviado la se√±al. Esta raz√≥n se recoger√° en el atributo reason del evento. Como punto final, imaginad que ten√©is varias llamadas simult√°neas a un API porque es necesario solicitar datos en paralelo en vuestra aplicaci√≥n. Ahora pong√°monos en una situaci√≥n en la que el usuario quiere cancelar la carga de datos en paralelo, por ejemplo, abri√≥ una modal que hace varias llamadas y la cierra inmediatamente. Podemos detener de forma centralizada todas estas llamadas (al igual que hicimos con el ejemplo de los temporizadores): Como hab√©is podido comprobar, AbortController es una herramienta muy sencilla a la par que potente, y que nos puede dar muchos m√°s usos de los que he comentado aqu√≠. Como siempre, espero que este breve art√≠culo os haya servido de ayuda.",
    "imageMini": "/images/abort-controller-mini.webp"
  },
  {
    "slug": "20220601.html",
    "title": "Aprendiendo a usar JavaScript Proxy",
    "description": "Los Proxies en JavaScript son, sin lugar a dudas, una caracter√≠stica poco utilizada en JavaScript. Al menos eso se desprende de la encuesta anual The State of JS.",
    "url": "/articles/posts/20220601.html",
    "date": "2022-06-01",
    "categories": [
      "programaci√≥n",
      "JavaScript",
      "patr√≥n proxy"
    ],
    "content": "Introducci√≥n Los Proxies en JavaScript son, sin lugar a dudas, una caracter√≠stica poco utilizada en JavaScript. Al menos eso se desprende de la encuesta anual The State of JS . La verdad es que es una herramienta muy potente, que en ocasiones nos puede ayudar a tener unas clases m√°s sencillas, abstrayendo funcionalidad extra mediante lo que se conoce como manejador o interceptor. Su uso principal puede venir condicionado en el caso de que por cuestiones de dise√±o, queramos evitar el tener que definir clases para realizar operaciones muy espec√≠ficas, es m√°s, aunque no es exactamente lo mismo, nos puede servir como aproximaci√≥n para aplicar una especie de decoradores, mientras √©stos llegan realmente a JavaScript . ¬øY qu√© es lo que nos permite hacer un interceptor? Pues bien, con √©l podemos capturar el instante en que se va a guardar o leer un atributo, interceptar cuando se a√±ade o elimina un atributo, etc. A los m√©todos que definiremos en nuestro interceptor y que estar√°n encargados de hacer esas capturas se les llama trap , ya que &quot;atrapan&quot; la llamada al objeto destino e interact√∫an con √©l. Primer ejemplo: interceptar una operaci√≥n get Para no aburriros con tanta teor√≠a, veamos un ejemplo pr√°ctico muy sencillo. Imaginad que cada persona conectada a nuestra aplicaci√≥n puede consultar su contrase√±a en todo momento. Pero temporalmente, durante una actualizaci√≥n, queremos evitar que quien no tenga permisos administrativos pueda verla. Normalmente, este caso implicar√≠a hacer cambios en nuestro c√≥digo que podr√≠an afectar a otras partes. Y adem√°s, luego tendr√≠amos que quitar dichos cambios al terminar. Pues con este sencillo c√≥digo podremos utilizar: Analicemos poco a poco el c√≥digo anterior: El interceptor es un objeto que seg√∫n los m√©todos que defina atrapar√° un momento de ejecuci√≥n del c√≥digo sobre el objeto sobre el que realizar el proxy. Cabe destacar, que se pueden usar clases, siendo este c√≥digo de interceptor equivalente al que hab√©is visto en el ejemplo: El uso de Reflect, es por aportar robustez, ya que podr√≠amos haber escrito return target[prop] , teniendo el mismo resultado. En otro art√≠culo si quer√©is podemos comentar las ventajas de usar Reflect vs Object.- Para utilizar un Proxy, se crea una instancia de este a la que se le pasa el objeto para el que queremos atrapar sus operaciones, junto con el objeto del interceptor. La instancia que devuelve es la que deberemos utilizar.- A nivel de llamadas al interceptor pod√©is comprobar como entra en juego la condici√≥n que especificamos.- Finalmente, se pone como ejemplo, que en el momento de llamar al objeto original, no se tendr√°n en cuenta las reglas de interceptor. Esto es muy importante, puesto que si terminamos utilizando el objeto err√≥neo, perderemos ese control intermedio. Segundo ejemplo: interceptar una operaci√≥n set Ahora veamos un ejemplo, de lo que podr√≠a ser el inicio de un mini-framework tipo React. En este caso queremos que cuando se cambie un atributo de la clase, √©sta se vuelva a renderizar: Como hemos visto en el ejemplo anterior, interceptamos el momento en el que se intenta establecer el valor de un atributo. Y cuando el valor de este, es el mismo, se evita llamar a render de nuevo. Tercer ejemplo: definir propiedades &quot;virtuales&quot; En esta ocasi√≥n hemos aprovechado para a√±adir l√≥gica extra como si existiera una propiedad llamada &quot;information&quot; en el objeto Car. De esta forma podemos llamar a dicha propiedad como si realmente estuviera definida. Algunos m√©todos trap √∫tiles apply(obj, method, parameters) Este trap es un tanto especial pues sirve para interceptar llamadas a funciones. get(obj, prop) Se ejecuta en el momento en que se quiere leer un atributo de la clase. Como par√°metros recibe el objeto interceptado, y el nombre del atributo. set(obj, prop, value) Intercepta el cambio de valores en los atributos de un objeto. Recibe como primer par√°metro el objeto interceptado, como segundo par√°metro el nombre del atributo y como tercer par√°metro el valor a guardar. deleteProperty(obj, prop) Captura el instante en que se ejecuta el borrado de una propiedad del objeto, por ejemplo, delete myObject.myProperty . Recibe el objeto y el nombre de la propiedad. ownKeys(obj) Se ejecutar√° cuando se use Object.keys() , o por ejemplo lancemos un for...in . Recibe el objeto. has(obj, prop) En este caso, el m√©todo se ejecutar√° cuando llamemos a una sentencia in (menos el bucle for..in ). Por ejemplo &quot;property&quot; in myObject . defineProperty(obj, prop, descriptor) Llamado en el momento en que se declara una nueva propiedad para el objeto. Hay que tener en cuenta, que si hay un trap para set, no se llegar√° a llamar a este m√©todo. Cuando definamos la propiedad directamente, en ese caso s√≠ se llamar√° cuando usamos el m√©todo defineProperties de Object. Si al c√≥digo anterior le quitamos el trap de set, ver√≠amos lo siguiente: construct(constructorType, parameters) Este trap permite captura el momento de instanciaci√≥n de una clase, es ideal para simular decoradores sobre la misma.",
    "imageMini": "/images/javascript-proxy-mini.webp"
  },
  {
    "slug": "20220414.html",
    "title": "Patr√≥n observer",
    "description": "Para hablar del patr√≥n Observer, antes deber√≠amos \"empezar por el principio\" (me encanta cuando la gente utiliza esa expresi√≥n redudante). En la teor√≠a del software, los patrones de dise√±o nos ayudan a resolver los problemas m√°s comunes a los que nos enfrentamos con una serie de soluciones a √©stos. Podr√≠amos hacer un poco de historia, pero no es el objetivo de este art√≠culo contaros batallitas &#x1f61b;. De forma resumida, hace muchos a√±os ya se conoc√≠an bastantes patrones pero dicho conocimiento estaba disperso, de forma que la conocida como \"Banda de los Cuatro\" (Erich Gamma, Richard Helm, Ralph Johnson y John Vlissides) decidieron escribir un libro que recogiera la definici√≥n de cada uno de los 23 patrones que se conoc√≠an en su momento. Dicho libro se llama Patrones de Dise√±o, por lo que es un buen punto de partida para quienes quer√°is ahondar m√°s en este tema.",
    "url": "/articles/posts/20220414.html",
    "date": "2022-04-14",
    "categories": [
      "patr√≥n observer",
      "dise√±o y arquitectura",
      "patrones de dise√±o",
      "programaci√≥n"
    ],
    "content": "Para hablar del patr√≥n Observer, antes deber√≠amos &quot;empezar por el principio&quot; (me encanta cuando la gente utiliza esa expresi√≥n redudante). En la teor√≠a del software, los patrones de dise√±o nos ayudan a resolver los problemas m√°s comunes a los que nos enfrentamos con una serie de soluciones a √©stos. Podr√≠amos hacer un poco de historia, pero no es el objetivo de este art√≠culo contaros batallitas &#x1f61b;. De forma resumida, hace muchos a√±os ya se conoc√≠an bastantes patrones pero dicho conocimiento estaba disperso, de forma que la conocida como &quot;Banda de los Cuatro&quot; (Erich Gamma, Richard Helm, Ralph Johnson y John Vlissides) decidieron escribir un libro que recogiera la definici√≥n de cada uno de los 23 patrones que se conoc√≠an en su momento. Dicho libro se llama Patrones de Dise√±o , por lo que es un buen punto de partida para quienes quer√°is ahondar m√°s en este tema. Estos patrones se clasificaron en tres categor√≠as: Patrones creacionales: como su nombre indica, permiten ayudar en la instanciaci√≥n de clases. Patrones estructurales: estos patrones, permiten definir las relaciones entre clases y su composici√≥n. Patrones de comportamiento: definen como pueden interaccionar y comportarse las clases. En el art√≠culo de hoy, aprenderemos en qu√© consiste el Patr√≥n Observer, atendiendo primero a su definici√≥n estricta, y luego viendo un ejemplo del mundo real. Como siempre, cualquier duda, comentario o correcci√≥n que quer√°is hacer la pod√©is dejar en comentarios. Teor√≠a del patr√≥n Observer Si atendemos a la definici√≥n estricta. Este patr√≥n: Define una dependencia uno a muchos entre objetos. De forma que cuando un objeto (subject) cambie de estado, este cambio se notificar√° a aquellos otros objetos (observers) que est√©n &quot;suscritos&quot; a √©l. En el diagrama superior podemos distinguir las siguientes clases: Subject : esta clase gestiona la suscripci√≥n de los observadores. Guardar√° la lista de objetos suscritos para poder notificarles cuando hay cambios. Observer : tendr√° un m√©todo p√∫blico al que los sujetos podr√°n llamar cuando le quieran notificar. ConcreteSubject : almacena un estado concreto para una serie de observadores. ConcreteObserver : se suscribe a un sujeto concreto y se encarga de actualizar su estado interno a partir del estado del sujeto, cuando √©ste √∫ltimo le notifique. La secuencia que seguir√≠a el flujo original del patr√≥n ser√≠a la siguiente: Tras tanto diagrama os explico un poco. Pr√°cticamente lo que hacemos es que el observador se suscriba al sujeto. En el momento en que el sujeto cambia su estado (en la definici√≥n del patr√≥n, este cambio lo hace el propio observador), √©ste notifica a todos los observadores para que puedan consultar el nuevo estado del sujeto. Un ejemplo pr√°ctico Voy a simplificar mucho el c√≥digo en TypeScript para que ve√°is un ejemplo muy tontorr√≥n quitando algunas clases, pero que creo que os puede ayudar a entenderlo mejor: Pues bien, una vez que hemos definido las dos clases simplonas, veamos que pasar√≠a si ejecutamos algo de c√≥digo para probarlo: Se puede ver como en cuanto realizamos un cambio de estado en el sujeto, este notifica a todos los observadores que se hayan suscrito. As√≠ que, aunque hemos visto el patr√≥n de forma muy simplificada, creo que os puede dar una pista de como es su funcionamiento. Un ejemplo del mundo real Si eres una persona nueva en el mundo de la programaci√≥n, m√°s exactamente si acabas de empezar con JavaScript, quiz√°s no sepas que has estado usando el patr√≥n observer de forma continua. Y lo has usado cuando has llamado al m√©todo addEventListener() . Para gente que lo desconozca, hacemos un breve inciso. En JavaScript podemos escuchar eventos que se lancen sobre un componente HTML, por ejemplo, podemos escuchar el evento &quot;click&quot; sobre un bot√≥n, de forma que cada vez que se haga clic en dicho bot√≥n, seamos notificados. Esto lo conseguimos con este tipo de llamadas: elementoHTML.addEventListener(&quot;tipoDeEvento&quot;, funcionALaQueNotificar); Y seguimos tras esta breve aclaraci√≥n &#x1f609;. El sistema que se utiliza en JavaScript para ser notificados cuando ocurre un evento, podr√≠amos decir que es una patr√≥n Observer &quot;mutado&quot;, ya que tiene cuatro diferencias principalmente: Por un lado, la suscripci√≥n se realiza sobre un &quot;cambio&quot; concreto del sujeto, en lugar de realizar una suscripci√≥n general. En este caso te suscribes al evento para el que quieres ser notificado. Muchos de los patrones de dise√±o se pueden aplicar a funciones, por lo que no estamos limitados a utilizar siempre clases para utilizarlos. Precisamente este es un ejemplo del funcionamiento del patr√≥n Observer con funciones, ya que al suscribirse se indicar√° la funci√≥n que ser√° llamada. La notificaci√≥n tambi√©n cambia, ya que en lugar de s√≥lo avisar que hay un cambio por parte del sujeto, √©ste lo que har√° es enviar directamente los datos involucrados en el cambio, con lo que la funci√≥n que hemos usado como observadora, recibir√°, en este caso, los datos del evento lanzado. Finalmente, el sujeto no notifica cambios en su estado. Es decir, que en el evento que recibimos, se incluyen los datos b√°sicos del sujeto. Pero los datos del evento en s√≠, no son parte del estado del sujeto, sino una acci√≥n llevada a cabo sobre este. Un diagrama muy b√°sico de como funciona ser√≠a el siguiente: Cosillas a tener en cuenta Hemos visto la definici√≥n est√°ndar del patr√≥n, as√≠ como una implementaci√≥n del mundo real con algunos cambios. Precisamente, una de las cosas a tener en cuenta es que los patrones de dise√±o no son algo cerrado que debas seguir al 100%, ya que dependiendo del caso, puede que te interese hacer algunos ajustes. En el caso del patr√≥n observer, hemos visto como se puede expandir con: suscripciones a datos en particular, notificaciones con datos en la llamada, suscripci√≥n de funciones en lugar de clases y que los observadores (las funciones en este caso), no est√°n lanzando el cambio que provoca las notificaciones. Como conclusi√≥n podemos decir que los patrones son los planos con los que trabajar, pero no impide que podamos hacer correcciones a √©stos para ajustarlos a nuestras necesidades. Otro de los puntos importantes en este patr√≥n, es que los observadores no saben el coste de actualizar el sujeto, ya que no conocer al resto de observadores. Me explico: si cada observador trata la notificaci√≥n de forma s√≠ncrona, cualquier observador que bloquee el hilo principal con alg√∫n proceso que lleve demasiado tiempo, dejar√° al resto en espera. De ah√≠ que es ideal evitar el tener observadores bloqueantes sin vamos a trabajar en modo s√≠ncrono. Y bien, hasta aqu√≠ los datos b√°sicos del patr√≥n Observer, espero que os pueda ayudar cuando surja la necesidad de utilizarlo en vuestro proyectos. Y sin m√°s, me despido hasta el pr√≥ximo art√≠culo.",
    "imageMini": "/images/patron-observer-mini.webp"
  },
  {
    "slug": "20220323.html",
    "title": "Optimiza tus transacciones con ACID",
    "description": "En el desarrollo de software definimos una transacci√≥n como un conjunto de pasos que deben ejecutarse de forma ordenada. El ejemplo m√°s com√∫n en el que solemos pensar es en las transacciones de las bases de datos, pero se utilizan en muchos m√°s ambitos, como por ejemplo: una transacci√≥n distribuida en micro-servicios, blockchains o incluso puede que debamos desarrollar un sistema de transacciones que hayamos creado de cero para nuestro proyecto.",
    "url": "/articles/posts/20220323.html",
    "date": "2022-03-23",
    "categories": [
      "programaci√≥n",
      "dise√±o y arquitectura",
      "bases de datos",
      "transacciones",
      "ACID"
    ],
    "content": "En el desarrollo de software definimos una transacci√≥n como un conjunto de pasos que deben ejecutarse de forma ordenada. El ejemplo m√°s com√∫n en el que solemos pensar es en las transacciones de las bases de datos, pero se utilizan en muchos m√°s ambitos, como por ejemplo: una transacci√≥n distribuida en micro-servicios, blockchains o incluso puede que debamos desarrollar un sistema de transacciones que hayamos creado de cero para nuestro proyecto. Es por ello que si deseamos disponer de transacciones que operen de la forma m√°s estable posible, lo ideal es que cumplan las caracter√≠sticas :strong[A]{.text-green-500}:strong[C]{.text-red-500}:strong[I]{.text-sky-700}:strong[D]{.text-yellow-500}. :strong[A]{.text-green-500}:span[tomicity] (atomicidad) La definici√≥n original ser√≠a la siguiente: Por cada paso en una secuencia de acciones realizada dentro de los l√≠mites de una transacci√≥n, √©sta debe, o completarse correctamente, o en caso contrario todo el trabajo deber√≠a ser revertido. Martin Fowler ~ Patterns of Enterprise Application Architecture Esta caracter√≠stica, viene a indicar que s√≥lo podemos dar una transacci√≥n como completada, cuando todos los pasos que la componen finalicen correctamente. Si hay un problema en cualquiera de los pasos, habr√° que desechar todos los pasos realizados hasta ahora. :strong[C]{.text-red-500}:span[onsistency] (consistencia) Los recursos de un sistema deben permanecer en un estado consistente y no corrupto, tanto al principio como al final. Martin Fowler ~ Patterns of Enterprise Application Architecture Este principio, lo que nos viene a decir, es que no deber√≠amos tener datos que incongruentes o incorrectos en cualquier paso de la transacci√≥n. Cada paso, debe dejar el estado totalmente consistente. :strong[I]{.text-sky-700}:span[solation] (aislamiento) El resultado de una transacci√≥n no debe ser visible a otras transacciones abiertas hasta que no termine correctamente. Martin Fowler ~ Patterns of Enterprise Application Architecture Al aislar las transacciones hasta que finalicen, conseguiremos aumentar la consistencia de nuestro sistema. Ya que si no cumplimos esta norma, imaginad que hay un error en un paso de una transacci√≥n y otra accede en ese momento a los datos. La transacci√≥n que haya fallado, revertir√≠a los cambios, con lo que la segunda transacci√≥n tendr√° datos incorrectos. Es por ello que hasta que no termine la primera, la segunda no podr√° acceder al resultado ni la informaci√≥n generada. :strong[D]{.text-yellow-500}:span[urability] (durabilidad) Cualquier resultado de una transacci√≥n que haya terminado correctamente debe ser permanente. Martin Fowler ~ Patterns of Enterprise Application Architecture Finalmente, con el √∫ltimo de los principios, lo que se viene a decir es que una vez que una transacci√≥n ha terminado, los datos deben quedan realizados de forma permanente, es decir, que para modificarlos, debe lanzarse otra transacci√≥n que opere con ellos, pero √©stos no deben ser revertidos parcialmente si la transacci√≥n finaliz√≥ correctamente. Conclusi√≥n Si tienes que trabajar con transacciones, ya conoces los principios ACID, que se deber√≠an cumplir para mantener un sistema lo m√°s consistente y robusto posible. Todo esto ha sido extra√≠do de un libro que es pr√°cticamente de lectura obligada si quer√©is profundizar en la arquitectura del software. El autor es el gran maestro Martin Fowler , y el libro en cuesti√≥n es Patterns of Enterprise Application Architecture .",
    "imageMini": "/images/acid-mini.webp"
  },
  {
    "slug": "20220319.html",
    "title": "Curiosidades del objeto global console",
    "description": "Seguro que est√°s harto o harta de usar console.log, console.warn, etc, para ver mensajes por consola mientras desarrollas en JavaScript. Sin embargo, hay algunos m√©todos del objeto global `console` que quiz√°s no conoces y pueden llegar a ser muy √∫tiles. En este art√≠culo vamos a ver algunos de los m√©todos m√°s √∫tiles.",
    "url": "/articles/posts/20220319.html",
    "date": "2022-03-19",
    "categories": [
      "programaci√≥n",
      "JavaScript"
    ],
    "content": "Seguro que est√°s harto o harta de usar console.log, console.warn, etc, para ver mensajes por consola mientras desarrollas en JavaScript. Sin embargo, hay algunos m√©todos del objeto global console que quiz√°s no conoces y pueden llegar a ser muy √∫tiles. En este art√≠culo vamos a ver algunos de los m√©todos m√°s √∫tiles. console.assert Uno de sus usos puede ser para controlados casos que sea muy raros que ocurran. Por ejemplo, tenemos una zona de c√≥digo en la que pensemos que es imposible que llegue un array vac√≠o. Y quiz√°s el c√≥digo falla en un punto dif√≠cil de depurar, pues si esperamos que siempre llegue un array con contenido, no nos cuesta dejar un assert en el c√≥digo: console.clear El nombre ya lo dice todo. Al igual que el comando clear en Linux, o cls en Windows, borra el contenido de la consola. console.count Cada vez que se ejecuta incrementa un contador que muestra en la consola. Se puede indicar un nombre para el contador. Se puede reiniciar la cuenta con console.countReset() , indicando el nombre del contador en el caso de que se quiera resetear uno nombreado. console.dirxml Seguro que ya has mostrado el contenido de objetos por consola, ya sea con console.dir() o usando el objeto como argumento en los m√©todos log , info , etc. Pero ¬ørecuerdas que ocurre cuando lo haces por ejemplo con un elemento HTML? S√≠, normalmente veremos el objeto que representa el nodo XML en s√≠, en lugar de la estructura. As√≠ que con este fin existe dirxml : console.time Cuando quieras medir tiempos en tu aplicaci√≥n, puedes jugar haciendo diferencias con objetos de tipo Date , pero hay una forma mucho m√°s sencilla para hacerlo en JavaScript. Con time y timeEnd podremos ver el tiempo transcurrido entre las dos llamadas. Podemos llamarlo sin par√°metros, o pasando un par√°metro para darle un nombre el contador. console.group Puede que alguna vez hayas querido indentar los mensajes que muestras por consola. Para ello, en el objeto console tienes los m√©todos group y groupEnd . Con el primero incrementas un nivel la indentaci√≥n y con el segundo lo quitas.",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20220311.html",
    "title": "Convertir una imagen en caracteres con JavaScript",
    "description": "Pele√°ndome un poco con los canvas de JavaScript, estuve viendo que era posible extraer la informaci√≥n de color de cada pixel. Por lo que pens√© ¬øy si convierto esa informaci√≥n de color en un car√°cter? Pues dicho y hecho, en este art√≠culo vamos a ver el c√≥digo de un proyecto de ejemplo (del que pod√©is ver todo su c√≥digo en Github), y que es capaz de transformar una fotograf√≠a en un conjunto de caracteres.",
    "url": "/articles/posts/20220311.html",
    "date": "2022-03-11",
    "categories": [
      "TypeScript",
      "programaci√≥n"
    ],
    "content": "Pele√°ndome un poco con los canvas de JavaScript, estuve viendo que era posible extraer la informaci√≥n de color de cada pixel. Por lo que pens√© ¬øy si convierto esa informaci√≥n de color en un car√°cter? Pues dicho y hecho, en este art√≠culo vamos a ver el c√≥digo de un proyecto de ejemplo (del que pod√©is ver todo su c√≥digo en Github ), y que es capaz de transformar una fotograf√≠a en un conjunto de caracteres. Por ejemplo, gracias a √©l he podido convertir una foto con muchos a√±os en la que salimos mi hermana y yo, en lo siguiente: Adem√°s, es posible escoger un conjunto personalizado de caracteres, as√≠ como el n√∫mero de caracteres utilizado como ancho y como alto de la imagen convertida. Pero, dejo de enrollarme y pasamos a ver c√≥mo funciona todo esto. Dentro del c√≥digo El c√≥digo est√° escrito en TypeScript, pero vamos, cualquier persona que s√≥lo conozca JavaScript no creo que tenga problemas para entenderlo. Comenzaremos por la parte de m√°s bajo nivel. Lo primero que necesitamos es una de las varias f√≥rmulas que hay para convertir los colores RGB a un tono de gris, para ello tenemos la funci√≥n siguiente: Esta funci√≥n la utilizaremos en otra en la que obtendremos el tono de gris de un pixel en concreto dentro de un canvas: Seguimos subiendo otro nivel, y ahora lo que vamos a ver es la funci√≥n que hace el trabajo de convertir todos los p√≠xeles de un canvas a letras. Para ello incluyo comentarios en el c√≥digo que os puedan ayudar a la comprensi√≥n: La funci√≥n anterior es la que realiza todo el trabajo, y espero haber incluido comentarios descriptivos que os hayan podido ayudar a comprenderla. De todas formas, para cualquier duda pod√©is escribir en los comentarios. Para terminar tenemos otras tres funciones que se encargan de obtener el canvas que usaremos para pintar la imagen temporalmente antes de convertirla: Resumiendo, lo que hemos hecho primero es volcar una imagen cualquiera a un elemento canvas. Y dicho elemento lo hemos aprovechado para leer cada pixel y as√≠ convertirlo primero a un tono de gris, y de ah√≠, luego lo hemos convertido a un car√°cter. Como conjunto de caracteres base, la funci√≥n usa los siguientes si no se define ninguno: Estos vendr√°n ordenados del que represente tonos m√°s oscuros, a tonos m√°s claros. De regalo... Como extra, parte del c√≥digo anterior podr√≠a servirnos para hacer una copia en blanco y negro de una imagen. Para ello, podemos crear un canvas con las mismas dimensiones y por cada pixel podr√≠amos hacer lo siguiente: En conclusi√≥n Espero que este c√≥digo os haya servido como curiosidad, y est√°is invitados a sugerir cualquier mejora, avisar de cualquier error, trastear con el c√≥digo, probar vuestros propios ajustes de caracteres, etc. Y cualquier comentario siempre ser√° bienvenido. ¬°Hasta la pr√≥xima! &#x1f596;",
    "imageMini": "/images/ascii-mini.webp"
  },
  {
    "slug": "20220223.html",
    "title": "async y await: la magia del c√≥digo as√≠ncrono en JavaScript",
    "description": "Para terminar de hablar de promesas en JavaScript (al menos por una temporada), veremos la forma de olvidarnos de los callbacks y comenzar a programar usando `async` y `await`.",
    "url": "/articles/posts/20220223.html",
    "date": "2022-02-23",
    "categories": [
      "JavaScript",
      "asincron√≠a",
      "programaci√≥n"
    ],
    "content": "Para terminar de hablar de promesas en JavaScript (al menos por una temporada), veremos la forma de olvidarnos de los callbacks y comenzar a programar usando async y await . Durante la escritura de este art√≠culo ning√∫n callback ha sufrido da√±o alguno. Introducci√≥n Seguramente, habr√°s o√≠do hablar del infierno de los callbacks. No, ah√≠ no es donde van los callbacks que se portan mal, sino que con esa expresi√≥n hacemos referencia a las ejecuciones de c√≥digo as√≠ncronas en JavaScript, que se van enlazando mediante callbacks. Por desgracia es com√∫n encontrar a√∫n c√≥digo con este aspecto: En el fragmento anterior no he a√±adido mucho c√≥digo; pero imaginad lo que se complicar√≠a, si adem√°s de todos esos callbacks tuvi√©ramos m√°s c√≥digo de por medio. Ese es uno de los motivos por los que podemos usar async...await . Otro motivo, por ejemplo, puede ser por claridad. En el caso de que no nos guste tener callbacks, ya sea definidos inline o como llamadas a funciones. Pero realmente, async...await es una herramienta que viene a ayudarnos en ciertos casos, y puede depender mucho de las preferencias de qui√©n est√© programando, el usarlos o no. Primer ejemplo Para comenzar veamos el c√≥digo anterior traducido a async...await: Vale, &quot;nos has puesto dos ejemplos de c√≥digo, y el segundo parece que queda m√°s bonito, pero ¬øqu√© hace?&quot;. Tranquilos y tranquilas que ya voy a la explicaci√≥n &#x1f600;. ¬øQu√© hacen async y await? Cuando tenemos una promesa, en lugar de que tener que usar callbacks como hasta ahora, podemos utilizar la palabra clave await delante de la promesa. Esto har√° que el c√≥digo quede esperando a que termine la promesa, siempre se suele decir que permite tener c√≥digo as√≠ncrono, definido como c√≥digo s√≠ncrono. Si la promesa se resuelve y adem√°s, lo hace con un valor, podremos asignarlo (como en las l√≠neas 7, 8 y 9 del c√≥digo anterior). Si la promesa es rechazada, se lanzar√° como excepci√≥n. De forma que tendremos que envolver la o las sentencias que usen await , con un bloque try...catch si queremos controlar las excepciones rechazadas. Puede que nos interese que estas excepciones se controlen en un bloque superior, por lo que no es obligatorio poner el try...catch junto al await . Pero eso s√≠, recuerda que si la promesa puede ser rechazada, en alguna parte del c√≥digo deber√≠as capturarla. Recapitulando, tenemos await que se espera a que termine una promesa, y los bloques try...catch para capturar las promesas rechazadas. Entonces, ¬øpara que sirve async ? Pues bien, await s√≥lo se puede utilizar en funciones que haya declarado como as√≠ncronas (obs√©rverse la primera l√≠nea del c√≥digo anterior). Es decir, no se puede utilizar await fuera de una funci√≥n que no sea as√≠ncrona. Con todo lo anterior, ahora puedes volver a subir al c√≥digo que usa async...await y revisarlo. Si me he explicado bien en los p√°rrafos anteriores, ahora entender√°s un poquito m√°s el funcionamiento de √©stas palabras. Detalle extra sobre las funciones as√≠ncronas As√≠ que pr√°cticamente, eso ser√≠a todo, o al menos, eso es lo que suelen explicarse casi siempre. Pero aparte las funciones as√≠ncronas tienen una peculiaridad m√°s que mucha gente omite, y es que devuelven autom√°ticamente una promesa. Con esto en mente, podemos esperar a que termine una funci√≥n que ya es as√≠ncrona sin tener que hacer c√≥digo extra: Ahora s√≠, con esto terminamos nuestro repaso a las promesas en JavaScript. Como siempre, espero que os haya podido servir de ayuda, y cualquier pregunta que teng√°is pod√©is dejarla en comentarios. Para ampliar algo de informaci√≥n sobre las promesas pod√©is recurrir a los siguientes libros: Understanding JavaScript Promises ‚Äì Nicholas C. Zakas JavaScript with Promises: Managing Asynchronous Code ‚Äì Daniel Parker Mastering JavaScript Promises ‚Äì Muzzamil Hussain",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20220209.html",
    "title": "M√©todos del objeto Promise en JavaScript",
    "description": "Como hasta ahora no hemos hablado de promesas en este blog, vamos a comenzar haciendo una peque√±a introducci√≥n a la breve pero apasionante historia de las promesas en JavaScript, para a continuaci√≥n ver los distintos m√©todos para trabajar con promesas.",
    "url": "/articles/posts/20220209.html",
    "date": "2022-02-09",
    "categories": [
      "JavaScript",
      "asincron√≠a",
      "programaci√≥n"
    ],
    "content": "‚ÄúHab√≠a permanecido en la sombra, esperando, sin prisa, a que alguna fuerza lo trajese de nuevo al mundo de los vivos. Y nada tiene tanta fuerza como una promesa‚Ä¶‚Äù Carlos Ruiz Zaf√≥n - El Pr√≠ncipe de la Niebla Como hasta ahora no hemos hablado de promesas en este blog, vamos a comenzar haciendo una peque√±a introducci√≥n a la breve pero apasionante historia de las promesas en JavaScript, para a continuaci√≥n ver los distintos m√©todos para trabajar con promesas. En caso de que os interese el tema, principalmente el caso de async...await que puede llegar a ser confuso en algunos √°mbitos, pod√©is escribir en comentarios las dudas, y puedo preparar un art√≠culo para ampliarlas. Introducci√≥n En un principio, al trabajar con JavaScript, cuando nos encontr√°bamos con un c√≥digo que se deb√≠a ejecutar de forma as√≠ncrona se utilizaban callbacks para controlar cuando hab√≠a terminado la ejecuci√≥n del c√≥digo as√≠ncrono. Pondremos en los siguientes ejemplos, el mismo c√≥digo evolucionando: Con el paso del tiempo, la librer√≠a jQuery comenz√≥ a usar lo que llamaban deferreds , un sistema con el que la gesti√≥n de las llamadas as√≠ncronas pasa a ser un poco m√°s descriptiva. Para ello se ten√≠a un objeto al que se pod√≠an ir enlazando callbacks por cada resultado de la operaci√≥n as√≠ncrona. Con este esquema se paso a tener una estructura muy similar cuando llegaron las promesas al propio JavaScript: Cabe destacar que tambi√©n existe la estructura then() con dos par√°metros, en la que el primero funcionar√≠a como callback cuando la promesa termina correctamente, y el segundo, cuando termina de forma err√≥nea. La siguiente evoluci√≥n en JavaScript fue la llegada de async...await . Esta estructura ayuda a &quot;leer&quot; el c√≥digo as√≠ncrono como si fuera s√≠ncrono: M√©todos del objeto Promise resolve() y reject() Estos dos m√©todos son los m√°s sencillos de utilizar y permiten generar una promesa resuelta (con resolve) o una promesa rechazada con (reject). any() Este m√©todo puede recibir varias promesas, y terminar√° en cuanto la primera de ellas se cumpla. El resto de promesas ser√°n &quot;omitidas&quot;. race() En esta ocasi√≥n, el m√©todo terminar√° en cuanto una promesa se cumpla o finalice err√≥neamente. Como resumen de los m√©todos any() y race() . Tenemos que, con any esperamos a que al menos una promesa termine bien, y si ninguna termina correctamente el flujo finalizar√° con la √∫ltima promesa. Con race , sin embargo, el c√≥digo se espera a que la promesa m√°s r√°pida termine, ya sea correcta o err√≥neamente. all() Se resuelve cuando terminan todas las promesas correctamente. En caso de que una de ellas falle, la promesa generada por all() ser√° rechazada. allSettled() El √∫ltimo de los m√©todos de Promise, lo que har√° es terminar cuando hayan acabado todas las promesas que recibe, ya sea correcta, o err√≥neamente. Para ello, el resultado ser√° un array con las promesas. Resumen M√©todo Explicaci√≥n resolve Genera una promesa resuelta autom√°ticamente. reject Genera una promesa rechazada autom√°ticamente. any Genera una promesa que se finaliza en cuanto termina correctamente una de las que recibe. race Genera una promesa que finaliza en cuanto termina una de las promesas que recibe, ya sea correcta o err√≥neamente. all Espera a que terminen todas las promesas. Si falla una de ellas, la promesa ser√° rechaza. allSettled Espera a que terminen todas las promesas, independientemente de si terminan correctamente o fallan. Para ampliar algo de informaci√≥n sobre las promesas pod√©is recurrir a los siguientes libros: Understanding JavaScript Promises ‚Äì Nicholas C. Zakas JavaScript with Promises: Managing Asynchronous Code ‚Äì Daniel Parker Mastering JavaScript Promises ‚Äì Muzzamil Hussain",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20220205.html",
    "title": "Clases vs Clases abstractas vs Interfaces",
    "description": "En el art√≠culo de hoy vamos a intentar resolver una duda bastante habitual: ¬øcu√°ndo usar clases base, cu√°ndo clases abstractas y cu√°ndo interfaces? Repasaremos qu√© es cada una y en qu√© situaciones resulta m√°s recomendable utilizarlas.",
    "url": "/articles/posts/20220205.html",
    "date": "2022-02-05",
    "categories": [
      "dise√±o y arquitectura",
      "programaci√≥n orientada a objetos",
      "POO",
      "programaci√≥n"
    ],
    "content": "En el art√≠culo de hoy vamos a intentar resolver una duda bastante habitual: ¬øcu√°ndo usar clases base, cu√°ndo clases abstractas y cu√°ndo interfaces? Repasaremos qu√© es cada una y en qu√© situaciones resulta m√°s recomendable utilizarlas. Clase Heredaremos de una clase base, cuando tengamos otras clases que resulten en una especializaci√≥n de la primera y no haya ninguna obligaci√≥n de implementar m√©todos de la clase madre. Suele ser el caso m√°s habitual de herencia. Por ejemplo, si tenemos una clase base con una serie de comportamientos ya predefinidos para todas las clases derivadas, cada clase hija puede sobrescribir √∫nicamente las partes que necesite. En el ejemplo superior, tenemos una clase de la que heredan otras dos. La primera no necesita sobrescribir ning√∫n m√©todo, mientras que la segunda redefine el comportamiento de saltar() . Es decir, una clase base no obliga a implementar o, mejor dicho en este caso, sobrescribir ninguno de sus m√©todos. Clase abstracta Una clase abstracta es aquella en la que alguno de sus m√©todos es abstracto. A primera vista puede parecer una obviedad, pero conviene matizar el concepto. Un m√©todo abstracto dentro de una clase es aquel que no tiene &quot;contenido&quot; o cuerpo. Esto obliga a que todas las clases que hereden de una clase abstracta implementen esos m√©todos, salvo que tambi√©n se declaren como abstractas. Veamos un ejemplo con nuestro amigo Super Mario de nuevo. Imaginad que tenemos esta clase abstracta: Como se puede comprobar, tenemos un m√©todo mover() , que ya tendr√≠a una serie de l√≥gica por defecto. Las clases hijas no tendr√≠an por qu√© sobrescribir dicho m√©todo. Sin embargo, el m√©todo atacar() es abstracto, no tiene cuerpo; es por ello que se obliga a toda clase hija (que no sea abstracta) a tener que implementarlo: Por lo que podr√≠amos decir que usaremos las clases abstractas cuando tengamos la necesidad de proporcionar una l√≥gica com√∫n a las clases hijas, pero existan operaciones que queramos que cada clase hija deba implementar por su cuenta. Interfaz En el caso de las interfaces, podr√≠amos pensar que son clases abstractas puras, es decir, clases con todos los m√©todos abstractos (y adem√°s con visibilidad p√∫blica). Es m√°s, en el caso de lenguajes como C++, al no haber interfaces, √©stas pasar√≠an a definirse con clases abstractas puras. Las interfaces a nivel sem√°ntico no requieren tener obligatoriamente relaci√≥n alguna con las clases, simplemente permiten definir comportamientos comunes sin imponer una jerarqu√≠a de herencia. Eso s√≠, las clases que implementan las interfaces est√°n obligadas a implementar todos sus m√©todos. Veamos un ejemplo: üóíÔ∏è NOTA En TypeScript, las interfaces pueden definir la forma de los datos , no solo comportamiento. Resumen Una vez vistos los conceptos, la siguiente tabla resume las principales diferencias entre clases, clases abstractas e interfaces: Caracter√≠stica Clase Clase abstracta Interfaz ¬øPuede tener implementaci√≥n? S√≠ S√≠ No ¬øPuede tener m√©todos abstractos? No S√≠ S√≠ (todos) ¬øObliga a implementar m√©todos? No S√≠ (los abstractos) S√≠ (todos) ¬øHerencia m√∫ltiple? No No S√≠ Uso principal recomendado Reutilizar comportamiento Mezclar comportamiento com√∫n y obligaci√≥n Definir contratos o capacidades üóíÔ∏è NOTA Tambi√©n puedes ver un resumen en Instagram . Bibliograf√≠a Aqu√≠ ten√©is algunos libros sobre programaci√≥n orientada a objetos con los que aprender m√°s: Introducci√≥n a Programaci√≥n Orientada a Objetos - Yolanda Blanco Fern√°ndez Object Oriented Programming in C++ - Richard Baker Practical Object-Oriented Design - Metz Sandi",
    "imageMini": "/images/uml-mini-png"
  },
  {
    "slug": "20220203.html",
    "title": "5 cosas que haces mal en JavaScript",
    "description": "JavaScript en ocasiones a√±ade el \";\" de forma explicita cuando hay un salto de l√≠nea. Si no tenemos cuidado con esto, puede haber comportamientos no esperados en nuestra aplicaci√≥n. Es por ello que se aconseja evitar, tanto partir l√≠neas en algunos casos, como abrir las llaves en la l√≠nea siguiente. En el siguiente ejemplo pod√©is ver lo que ocurre:",
    "url": "/articles/posts/20220203.html",
    "date": "2022-02-03",
    "categories": [
      "JavaScript",
      "programaci√≥n"
    ],
    "content": "1. A√±adir saltos de l√≠nea donde no corresponde JavaScript en ocasiones a√±ade el &quot;;&quot; de forma explicita cuando hay un salto de l√≠nea. Si no tenemos cuidado con esto, puede haber comportamientos no esperados en nuestra aplicaci√≥n. Es por ello que se aconseja evitar, tanto partir l√≠neas en algunos casos, como abrir las llaves en la l√≠nea siguiente. En el siguiente ejemplo pod√©is ver lo que ocurre: Como se puede ver en el ejemplo tenemos dos funciones que, en primera instancia, parece que debieran devolver una cadena anteponiendo el texto &quot;Hola &quot;. En realidad en la primera funci√≥n obtendremos undefined . Esto es, porque JavaScript aplica una regla llamada Automatic Semicolon Insertion (ASI), que en ciertos contextos inserta un ; impl√≠citamente. 2. Usar siempre los bucles for tradicionales con arrays Siempre que puedas, comienza a utilizar los bucles for...of (con aquellos elementos que sean iterables) o el m√©todo forEach en los arrays, ya que ofrecen una mejora en la legibilidad. En el siguiente c√≥digo puedes ver un ejemplo sencillo de los tres bucles. Con for , debemos declarar el √≠ndice e indicar su incremento. Esto implica que para acceder a cada elemento necesitamos usar la nomenclatura nombreArray[indice] . Con for..of obtenemos el elemento de cada posici√≥n sin usar un contador. Adem√°s podemos usar break y continue para controlar el flujo del recorrido. En el caso de necesitar un √≠ndice, si que tendremos que llevar un control manual. Con forEach el recorrido del bucle ser√° completo. Por lo que si tienes que interrumpir el recorrido es mejor la otra opci√≥n. El segundo par√°metro del callback es la posici√≥n, as√≠ que podremos usarla sin llevar un control manual como en for..of . 3. Usar == y !=, en lugar de === y !== Seguramente, esta te sonar√°. Y es que, a no ser que partas de un lenguaje tipado como TypeScript, el operadores de igualdad/desigualdad y no de identidad puede dar alg√∫n quebradero de cabeza. El uso de los operadores == y != compara el valor de cada variable y realiza un casting a otro tipo de dato si fuera necesario. Por el contrario, los operadores de identidad ( === y !== ) aparte del valor, verifican que el tipo de dato sea el mismo. 4. Seguir usando funciones para definir las clases A no ser que tengas que hacer desarrollos para un navegador como IE (por tu bienestar mental, espero que no sea as√≠). Deber√≠as comenzar a usar la definici√≥n nativa de clases en JavaScript. La nueva sintaxis de JavaScript para definici√≥n de clases te proporciona un estilo mucho m√°s pr√≥ximo a lo que puedes ver en otros lenguajes de programaci√≥n, as√≠ que olv√≠date de manipular directamente prototype , salvo que tengas un motivo muy concreto. Las clases no cambian el modelo de herencia, solo lo hacen m√°s legible. Puedes aprender m√°s sobre esta sintaxis de JavaScript en la serie de art√≠culos Orientaci√≥n a objetos con JavaScript . 5. Usar var en lugar de let y const ¬øA√∫n defines tus variables con var aunque nunca vayan a cambiar su valor? Pues bien, puedes usar let y const para evitar los problemas de hoisting ; que se modifique lo que pensabas que era una constante; o, que pienses que una variable se encontraba en un √°mbito acotado y es global. Al usar let o const , evitar√°s que las variables y constantes puedan usarse antes de su declaraci√≥n. Puedes ver m√°s informaci√≥n sobre las diferencias entre let y var en este art√≠culo .",
    "imageMini": "/images/javascript-mini.webp"
  },
  {
    "slug": "20220131.html",
    "title": "Principios SOLID. Cap√≠tulo D: Dependency Inversion Principle",
    "description": "Terminamos los principios SOLID con el Principio de Inversi√≥n de Dependencias, que viene a decir:",
    "url": "/articles/posts/20220131.html",
    "date": "2022-01-31",
    "categories": [
      "programaci√≥n",
      "dise√±o y arquitectura",
      "SOLID"
    ],
    "content": "Terminamos los principios SOLID con el Principio de Inversi√≥n de Dependencias, que viene a decir: Los m√≥dulos de alto nivel no deber√≠an depender de los m√≥dulos de bajo nivel. Ambos deber√≠an depender de abstracciones. Las abstracciones no deber√≠an depender de los detalles. Los detalles deben depender de abstracciones. Robert C. Martin ~ The Dependency Inversion Principle Aunque parezca un trabalenguas, lo que viene a decir el t√≠o Bob en esta ocasi√≥n es que las clases que utilizan otras no deber√≠an depender de como funcionen. Estas a su vez, tendr√°n interfaces gen√©ricas que no hagan depender a la clase de alto nivel de cada una. Pero como siempre veamos todo con un ejemplo. Imaginad una clase para compartir datos que en su inicio s√≥lo sirva para compartir por Bluetooth: ¬øQu√© pasa si queremos el d√≠a de ma√±ana compartir por email, por ftp, etc? ¬øTener un atributo de cada tipo? ¬øConsultar de forma externa a√±adiendo una dependencia no necesaria? Pues justo, con esto nos va a ayudar la inversi√≥n de dependencias. Lo primero que har√≠amos es crear una interfaz a la que poder llamar de una forma gen√©rica: El siguiente paso ser√° pasar a nuestra clase la interfaz como par√°metro, de forma que nuestra clase o (en la cita del principio, m√≥dulo de alto nivel) deja de depender de la clase que utiliza (m√≥dulo de bajo nivel). As√≠ que recibir√° la implementaci√≥n espec√≠fica de la interfaz que necesite en cada momento, sin tener que cambiar su contenido: Pero... seguramente cada tipo de conexi√≥n no requiera exactamente los mismos datos, pues bien aqu√≠ entra en juego un segundo componente en juego, que ser√≠an los adaptadores (patr√≥n adapter). Estos har√≠an de interfaz entre cada tipo de conexi√≥n y la interfaz que tenemos, haciendo que &quot;la abstracci√≥n no dependa de los detalles&quot;. Y es que imaginad para este caso que con cada tipo de conexi√≥n (bluetooth, email, etc), usamos librer√≠as. Cada librer√≠a tendr√° una API distinta, y diferentes formas de poder enviar datos. Pues bien, crearemos un adaptador por cada una para que se pueden comunicar con nuestro sistema con la misma interfaz. Por ejemplo, en el caso de la conexi√≥n Bluetooth: Esto quedar√≠a con un esquema del tipo: ¬øY al final en qu√© se traduce todo esto? Pues que en nuestro ejemplo, hemos hecho que la clase ShareAction, al recibir sus dependencias del exterior deje de depender de la implementaci√≥n de dichas clases. Permiti√©ndonos poder cambiar de un tipo de conexi√≥n a otra sin que ShareAction se vea modificada. Si el d√≠a de ma√±ana se a√±ade otro tipo de conexi√≥n, s√≥lo hay que pasar en el constructor la referencia al nuevo adaptador y listo. Por otro lado, no necesitamos las clases &quot;reales&quot; para testear, podemos usar mocks que pasaremos a la clase ShareAction, de forma que si hay un fallo en un test sabremos que es de la clase ShareAction y no de la dependencia que le hemos pasamdo. Finalmente, cabe aclarar que la inyecci√≥n de dependencias no es lo mismo que la inversi√≥n de dependencias. La primera es una herramienta con la que conseguir la segunda. Pod√©is ver un resumen de todo lo que hemos visto en este art√≠culo en este post de Instagram . Conclusiones Con este art√≠culo hemos terminado de ver los principios SOLID. Quiero aclarar una cosilla para terminar, aunque los principios ofrecen ideas muy buenas, no siempre tienen que aplicarse desde el comienzo, sobre todo si no se sabe como evolucionar√° el proyecto; sino que se pueden aplicar cuando llegue el momento. Si tenemos una buena cobertura de test, refactorizar el c√≥digo para adaptar alg√∫n principio no deber√≠a ser problema. Y es que en mi experiencia hay algunos casos que nunca cambian en la vida de un proyecto, por lo que aplicar desde el inicio estos principios puede resultar en una sobre-ingenier√≠a que puede complicar de m√°s el proyecto innecesariamente. Al final son herramientas que hay que saber cuando es el momento oportuno de usarlas, y eso se consigue con pr√°ctica y experiencia. Espero que os haya gustado esta serie de art√≠culos y ¬°nos vemos en el pr√≥ximo! M√°s art√≠culos de esta serie :strong[Cap√≠tulo S]{.text-red-500}: Single Responsibility Principle o Principio de responsabilidad √∫nica :strong[Cap√≠tulo O]{.text-orange-500}: Open-Closed Principle o Principio abierto/cerrado :strong[Cap√≠tulo L]{.text-green-500}: Liskov Substitution Principle o Principio de sustituci√≥n de Liskov :strong[Cap√≠tulo I]{.text-pink-500}: Interface Segregation Principle o Principio de segregaci√≥n de interfaces Si quieres leer algo m√°s de Robert C. Martin, aparte de su web , tiene varios libros interesantes: La Artesan√≠a del C√≥digo Limpio C√≥digo Limpio Clean Architecture",
    "imageMini": "/images/solid-logo-mini.webp"
  },
  {
    "slug": "20220124.html",
    "title": "Principios SOLID. Cap√≠tulo I: Interface-Segregation Principle",
    "description": "Si en el cap√≠tulo anterior vimos como una mala herencia puede provocar que haya clases con m√©todos que no deber√≠an implementar, para este cuarto principio tenemos un ejemplo muy parecido, pero con el caso de las interfaces.",
    "url": "/articles/posts/20220124.html",
    "date": "2022-01-24",
    "categories": [
      "programaci√≥n",
      "dise√±o y arquitectura",
      "SOLID"
    ],
    "content": "Si en el cap√≠tulo anterior vimos como una mala herencia puede provocar que haya clases con m√©todos que no deber√≠an implementar, para este cuarto principio tenemos un ejemplo muy parecido, pero con el caso de las interfaces. Su nacimiento se remonta a los tiempos en los que Robert C. Martin trabajaba en la empresa Xerox. Dicha empresa hab√≠a creado un software que llevaba a cabo la mayor parte de tareas que puede llevar a cabo un sistema de impresi√≥n. El problema es que hab√≠a una sola clase que hac√≠a todo el trabajo, algo que ya tambi√©n incumpl√≠a varios de los principios que hemos visto (como el Principio de Responsabilidad √önica). Pues bien, tras ver como cada cambio implicaba cada un mayor tiempo de desarrollo, se opt√≥ por crear varias interfaces que acotaran las tareas: grapado, env√≠o de fax, impresi√≥n, etc. Y de ah√≠ sali√≥ la definici√≥n del Principio de Segregaci√≥n de Interfaces: Los clientes no deber√≠an estar forzados a depender de interfaces que no van a usar. Robert C. Martin ~ The Interface Segregation Principle Y como siempre, vamos a intentar definir de una forma m√°s &quot;mundana&quot; este principio. En este caso, lo que viene a decir, es que las clases no deber√≠an implementar m√©todos de interfaces que no van a usar; algo muy parecido al problema que provocaba el que tuvi√©ramos que usar el Principio de Sustituci√≥n de Liskov, pero aplicado a relaciones con interfaces, en lugar de con herencia de clases. En nuestro ejemplo, partiremos de un ejemplo videojueguil que casi todo el mundo conocer√©is. En Super Mario tenemos entre otros estos enemigos: Enemigo Descripci√≥n Goombas Son los champi√±ones que s√≥lo avanzan. Koopa Troopa Las tortugas que al saltar sobre ellas se esconden. Koopa Paratroopa Tortugas con alas que van dando saltos, tambi√©n al saltar sobre ellas se esconden. Hermanos Martillo Con forma de tortuga. Lanzan martillos y dan saltos Vale, pues imaginad que tenemos esta interfaz para los enemigos: Si usamos esa interfaz con todos los personajes tendr√≠amos un problema, ya que el c√≥digo quedar√≠a tal que as√≠: Como se puede apreciar, hay una interfaz que obliga a las clases (los clientes seg√∫n el t√©rmino de este principio) a implementar m√©todos que no tiene sentido que usen. Esto a la larga dar√° muchos quebraderos de cabeza, tal y como se vio con el principio anterior. ¬øC√≥mo se podr√≠a solventar este problema? Pues creando interfaces m√°s espec√≠ficas que obliguen a desglosar las tareas (o en este caso acciones) a realizar por las clases: Como anotaci√≥n importante, en nuestro ejemplo quedan tres interfaces, cada una con un m√©todo, esto no significa que en todos los casos se tengan mini interfaces &quot;uni-metodales&quot;, sino que depender√° del caso. Tras la aclaraci√≥n anterior, ahora nuestros enemigos quedar√≠an con esta definici√≥n: Ahora las clases s√≥lo implementan lo que necesitan, evitando en este caso a√±adir m√©todos vac√≠os, que devuelvan valores &quot;sin sentido&quot;, o que lancen excepciones. Aparte se han dejado mejor agrupadas las acciones u operaciones a las que representa cada interfaz, dando algo m√°s de sem√°ntica al c√≥digo. Como extra seguramente se podr√≠a a√±adir una clase base que implemente la interfaz IEnemigo, ya que todas las clases tienen un avanzar que en el ejemplo de este art√≠culo, hace pr√°cticamente lo mismo, pero tampoco era el objetivo salir de la explicaci√≥n del principio en s√≠, y as√≠ os lo pod√≠a comentar mejor. Pues b√°sicamente este es el Principio de Segregaci√≥n de Interfaces. En el pr√≥ximo art√≠culo terminaremos la serie de principios SOLID. Ya sab√©is que pod√©is encontrar un resumen de este principio en Instagram . M√°s art√≠culos de esta serie :strong[Cap√≠tulo S]{.text-red-500}: Single Responsibility Principle o Principio de responsabilidad √∫nica :strong[Cap√≠tulo O]{.text-orange-500}: Open-Closed Principle o Principio abierto/cerrado :strong[Cap√≠tulo L]{.text-green-500}: Liskov Substitution Principle o Principio de sustituci√≥n de Liskov :strong[Cap√≠tulo D]{.text-violet-500}: Dependency Inversion Principle o Principio de inversi√≥n de dependencias Si quieres leer algo m√°s de Robert C. Martin, aparte de su web , tiene varios libros interesantes: La Artesan√≠a del C√≥digo Limpio C√≥digo Limpio Clean Architecture",
    "imageMini": "/images/solid-logo-mini.webp"
  },
  {
    "slug": "20220121.html",
    "title": "Principios SOLID. Cap√≠tulo L: Liskov Substitution Principle",
    "description": "En el cap√≠tulo :strong[L]{.text-green-500}, hablaremos del Principio de Sustituci√≥n de Liskov, una idea formulada por Barbara Liskov y Jeannette M. Wing, en su art√≠culo A Behavioral Notion of Subtyping de 1994. Si quieres entender c√≥mo formalizar los conceptos abstractos que manejamos, te recomiendo que lo leas.",
    "url": "/articles/posts/20220121.html",
    "date": "2022-01-21",
    "categories": [
      "dise√±o y arquitectura",
      "programaci√≥n",
      "SOLID"
    ],
    "content": "En el cap√≠tulo :strong[L]{.text-green-500}, hablaremos del Principio de Sustituci√≥n de Liskov, una idea formulada por Barbara Liskov y Jeannette M. Wing , en su art√≠culo A Behavioral Notion of Subtyping de 1994. Si quieres entender c√≥mo formalizar los conceptos abstractos que manejamos, te recomiendo que lo leas. Este principio est√° escrito con varias f√≥rmulas que no entraremos a detallar, pero que de forma resumida dir√≠an lo siguiente: Dado un conjunto de clases que heredan de otra. Todas las clases hijas pueden ser sustituidas por la clase madre, y viceversa, sin requerir de cambios en el c√≥digo que las usa. En otras palabras, cualquier clase o sus subclases en una relaci√≥n de herencia deber√≠an ser intercambiables sin afectar la funcionalidad de la aplicaci√≥n. La violaci√≥n del principio de sustituci√≥n de Liskov se puede detectar cuando las clases hijas contienen m√©todos vac√≠os, devuelven valores sin sentido o lanzan excepciones que indican que no est√°n implementados. Para entender mejor este principio, consideremos el ejemplo de una clase Veh√≠culo que tiene las operaciones acelerar() y volar() . Si queremos usar estas operaciones en una funci√≥n despegar() , deber√≠amos ser capaces de hacerlo con cualquier objeto de tipo Veh√≠culo o sus subtipos, sin importar la clase espec√≠fica del objeto. En el c√≥digo anterior, podemos observar que si se recibe un objeto de tipo Coche en la funci√≥n despegar() , se producir√° una excepci√≥n y se romper√° el flujo de ejecuci√≥n. Esto significa que tendr√≠amos que cambiar el c√≥digo de despegar() para adaptarlo al comportamiento particular de la clase hija. Sin embargo, este enfoque viola el principio de sustituci√≥n de Liskov, que es fundamental para mantener la flexibilidad y la extensibilidad del c√≥digo. Es m√°s, no solo estamos incumpliendo dicho principio, sino que tambi√©n estamos violando el principio Abierto/Cerrado , que establece que un m√≥dulo debe estar abierto para su extensi√≥n pero cerrado para su modificaci√≥n. Para resolver este problema, debemos buscar un comportamiento com√∫n para todas las clases que se utilizan en la funci√≥n despegar() . En el ejemplo dado, podemos crear una nueva clase hija llamada Veh√≠culoVolador que extienda de la clase Veh√≠culo y que implemente el m√©todo volar() . De esta manera, podemos mantener la funcionalidad com√∫n en la clase Veh√≠culo y agregar el comportamiento espec√≠fico en las clases hijas. Ahora al a√±adir clases como: Dron, Aeroplano, Helic√≥ptero, etc. Si hacemos que todas ellas hereden de Veh√≠culoVolador , ya no ser√° necesario modificar el c√≥digo de la funci√≥n despegar() . Con esto terminamos el tercero de los principios SOLID, en el cap√≠tulo siguiente pasaremos a ver el Principio de Segregaci√≥n de Interfaces. Y si quer√©is un resumen de todo esto, pod√©is verlo en Instagram . M√°s art√≠culos de esta serie :strong[Cap√≠tulo S]{.text-red-500}: Single Responsibility Principle o Principio de responsabilidad √∫nica :strong[Cap√≠tulo O]{.text-orange-500}: Open-Closed Principle o Principio abierto/cerrado :strong[Cap√≠tulo I]{.text-pink-500}: Interface Segregation Principle o Principio de segregaci√≥n de interfaces :strong[Cap√≠tulo D]{.text-violet-500}: Dependency Inversion Principle o Principio de inversi√≥n de dependencias Si quieres leer algo m√°s de Barbara Liskov, tiene un libro muy completo para aquellas personas que programan en Java: Program Development in Java: Abstraction, Specification, and Object-Oriented Design .",
    "imageMini": "/images/solid-logo-mini.webp"
  },
  {
    "slug": "20220115.html",
    "title": "Principios SOLID. Cap√≠tulo O: Open/Closed Principle",
    "description": "En esta segunda parte de los principio SOLID, vamos a ver el llamado principio abierto/cerrado (open/closed).",
    "url": "/articles/posts/20220115.html",
    "date": "2022-01-15",
    "categories": [
      "programaci√≥n",
      "dise√±o y arquitectura",
      "SOLID"
    ],
    "content": "En esta segunda parte de los principio SOLID, vamos a ver el llamado principio abierto/cerrado (open/closed). Introducci√≥n Este principio fue formulado por uno de los grandes Bertrand Meyer , en su libro Object-Oriented Software Construction . Si nos vamos a la definici√≥n que hay dada ser√≠a: Las entidades de software (clases, m√≥dulos, funciones, etc.) deben estar abiertas para su extensi√≥n, pero cerradas para su modificaci√≥n. Bertrand Meyer Cuando un cambio en una aplicaci√≥n provoca cambios en cascada en m√∫ltiples m√≥dulos interdependientes que no deber√≠an ser modificados, esto indica un problema de dise√±o en el programa. Este acoplamiento excesivo hace que cada cambio sea una tarea dif√≠cil y compleja, especialmente en proyectos grandes. El principio &quot;Open/Closed&quot; nos insta a desarrollar elementos de software que realicen su funci√≥n sin la necesidad de modificaciones en el futuro. Al seguir este principio, podemos evitar modificar c√≥digo que funciona correctamente y evitar la introducci√≥n de errores innecesarios. La implementaci√≥n de este principio requiere una planificaci√≥n cuidadosa y una arquitectura adecuada para asegurar que los elementos de software est√©n dise√±ados para ser extensibles sin necesidad de ser modificados. De esta manera, podemos reducir la complejidad del c√≥digo y mejorar la capacidad de mantenimiento y extensibilidad del software. Ejemplo Comencemos con el siguiente c√≥digo en TypeScript. Aunque los conceptos son gen√©ricos, aquellos familiarizados con lenguajes como Java, C++, o C# encontrar√°n la sintaxis similar. En este ejemplo, tenemos un controlador de dispositivos inteligentes capaz de ejecutar los comandos de encendido y apagado de dispositivos. En un mundo ideal, hasta el momento, ha funcionado correctamente con todos los dispositivos probados: Pero llega un aciago d√≠a en el que nos toca controlar un nuevo tipo de dispositivo inteligente, por ejemplo una estufa. Y en este caso, para apagarla, primero es necesario ponerla en modo suspensi√≥n. Debido a esta nueva funcionalidad, es necesario realizar un cambio en nuestro c√≥digo anterior: En este caso, hemos tenido que modificar el c√≥digo debido a un √∫nico caso adicional, lo cual va en contra del principio de dise√±o que estamos tratando de seguir. De acuerdo con √©ste, debemos evitar realizar modificaciones en el c√≥digo existente. En su lugar, debemos asegurarnos de que nuestras clases est√©n abiertas para su extensi√≥n. Es por ello, que para resolver este problema podemos hacer uso de la herencia. En lugar de modificar la clase existente, crearemos una clase que herede de Device y extienda su funcionalidad para manejar la estufa: De esta manera, cumplimos con el principio abierto/cerrado. La clase original permanece intacta y cerrada para su modificaci√≥n, mientras que hemos creado una nueva clase que extiende su funcionalidad y est√° abierta para su extensi√≥n. Esto nos ha permitido modificar c√≥digo que ya funcionaba correctamente y hab√≠a sido probado exhaustivamente. Imaginemos lo que habr√≠a sucedido en el caso de haber modificado la clase original para incluir la funcionalidad adicional requerida: si hubi√©semos cometido un error en ese proceso, no solo la estufa no se apagar√≠a correctamente, sino que tambi√©n todos los dispositivos que antes se apagaban correctamente quiz√°s ahora hubieran dejado de hacerlo. Es importante tener en cuenta que, aunque este principio no impide que en el futuro tengamos que hacer cambios en la clase, estos cambios deber√≠an estar orientados principalmente a solucionar errores que puedan surgir, en lugar de a√±adir funcionalidades que la clase original no deber√≠a manejar. Conclusi√≥n El principio abierto/cerrado es esencial para el desarrollo de software de calidad. Al seguir este principio, podemos dise√±ar elementos de software que sean flexibles y extensibles sin comprometer su estabilidad o eficacia, lo que resulta en un c√≥digo m√°s limpio y f√°cil de mantener. Y aqu√≠ terminamos la explicaci√≥n del segundo principio SOLID. Como siempre, cualquier duda, sugerencia o correcci√≥n, ser√° bienvenida. Nos vemos en el cap√≠tulo :strong[L]{.text-green-500} (seguro que a quien sea fan de Death Note le ha hecho ilusi√≥n el nombre). Puedes ver un resumen en esta entrada de Instagram . M√°s art√≠culos de esta serie :strong[Cap√≠tulo S]{.text-red-500}: Single Responsibility Principle o Principio de responsabilidad √∫nica :strong[Cap√≠tulo L]{.text-green-500}: Liskov Substitution Principle o Principio de sustituci√≥n de Liskov :strong[Cap√≠tulo I]{.text-pink-500}: Interface Segregation Principle o Principio de segregaci√≥n de interfaces :strong[Cap√≠tulo D]{.text-violet-500}: Dependency Inversion Principle o Principio de inversi√≥n de dependencias",
    "imageMini": "/images/solid-logo-mini.webp"
  },
  {
    "slug": "20220107.html",
    "title": "Principios SOLID. Cap√≠tulo S: Single Responsibility Principle",
    "description": "En el principio Dahl y Nygaard crearon la programaci√≥n orientada a objetos. Y esta se encontraba desordenada y vac√≠a, y las tinieblas estaban sobre la faz de la programaci√≥n. Pero entonces Robert C. Martin, habl√≥ a los congregados y les dijo:",
    "url": "/articles/posts/20220107.html",
    "date": "2022-01-07",
    "categories": [
      "programaci√≥n",
      "dise√±o y arquitectura",
      "SOLID"
    ],
    "content": "Introducci√≥n En el principio Dahl y Nygaard crearon la programaci√≥n orientada a objetos. Y esta se encontraba desordenada y vac√≠a, y las tinieblas estaban sobre la faz de la programaci√≥n. Pero entonces Robert C. Martin , habl√≥ a los congregados y les dijo: &quot;Aqu√≠ ten√©is los 5 mandamientos de la programaci√≥n orientada a objetos. No son verdades absolutas y no siempre podr√°n vivir conjuntamente. Usadlos con mi benepl√°cito&quot;. Ejem.... perd√≥n, que quer√≠a realizar una idealizaci√≥n de nuestro pasado en la programaci√≥n. As√≠ que dejemos las introducciones grandilocuentes para comenzar a hablar de SOLID . ¬øQu√© es? ¬øCon que fin nace?. SOLID es un conjunto de pr√°cticas propuestas por Robert C. Martin con el fin de resolver los problemas existentes en las aplicaciones desarrolladas mediante programaci√≥n orientada a objetos (POO), y as√≠ hacerlas m√°s sencillas de leer, mantener y testear. El acr√≥nimo se compone de las iniciales de cada uno de los cinco principios o pr√°cticas que lo conforman: :strong[S]{.text-red-500}: Single Responsibility Principle o Principio de responsabilidad √∫nica :strong[O]{.text-orange-500}: Open-Closed Principle o Principio abierto/cerrado :strong[L]{.text-green-500}: Liskov Substitution Principle o Principio de sustituci√≥n de Liskov :strong[I]{.text-pink-500}: Interface Segregation Principle o Principio de segregaci√≥n de interfaces :strong[D]{.text-violet-500}: Dependency Inversion Principle o Principio de inversi√≥n de dependencias En muchas ocasiones, al buscar informaci√≥n sobre estos principios en la red, se encuentran datos poco claros o art√≠culos demasiado extensos que generan m√°s dudas que respuestas. Por esta raz√≥n, hemos creado una serie de cinco art√≠culos en los que explicaremos cada uno de los principios de forma clara y pr√°ctica, para que puedas saber cu√°ndo, c√≥mo y por qu√© aplicarlos en tus proyectos. Cabe destacar que estos principios, no quedan relegados a las clases, se puede aplicar a otros √°mbitos. (:strong[ S ]{.text-red-500}) Principio de responsabilidad √∫nica &quot;Una clase deber√≠a tener una, y s√≥lo una, raz√≥n para cambiar&quot; Robert C. Martin Una clase s√≥lo deber√≠a hacer una √∫nica cosa, es decir, tener s√≥lo una responsabilidad. Si hacemos que una clase se encargue de todo, cualquier cambio en la funcionalidad requerir√° de modificaciones en dicha clase, e incluso en partes en las que no deber√≠a cambiar. Para detectar si estamos cumpliendo este principio, podemos hacernos varias preguntas: ¬øLa clase es muy grande? Normalmente, esto puede indicar que est√° haciendo demasiadas cosas. ¬øCualquier cambio en otras capas del c√≥digo requieren cambios en la clase? Esto implica que la clase est√° llevando a cabo funciones de capas de la arquitectura que no deber√≠a ni saber que existen. Por ejemplo, que una clase con informaci√≥n de usuario tenga m√©todos de guardado de en base de datos. ¬øPor qu√© deber√≠a cambiar la clase Usuario si cambia la base de datos o las consultas? ¬øPor qu√© tengo &quot;grupos&quot; de atributos en la clase que no parecen estar relacionados entre s√≠? Volviendo al ejemplo del punto anterior, ¬øqu√© hace un atributo dbConnector en mi clase Usuario? ¬øPor qu√© tengo que configurar medio entorno para testear s√≥lo esta clase? A excepci√≥n de que quisieras hacer una prueba de la clase que carga toda tu aplicaci√≥n, en la clase Usuario no deber√≠a ser necesario configurar o mockear una gran cantidad de elementos para crear pruebas unitarias. Para ilustrar este punto, podemos tomar como ejemplo una clase mal dise√±ada llamada TextDocument, que contiene las propiedades de un documento y tambi√©n se encarga de compartirlos: La clase presenta un problema al tener dos responsabilidades. Por un lado, gestiona el documento y, por otro, se encarga de compartirlo. ¬øRealmente es algo que el documento debe saber? Y es que el compartir no es algo relativo a las propiedades de un documento, sino es una acci√≥n para realizar otro fin, por lo que esta responsabilidad no deber√≠a ser del documento. Es m√°s, esta parte estar√≠a muy acoplada a la forma de compartir, no es lo mismo enviar por correo electr√≥nico que compartir por Bluetooth. Por lo que volvemos a preguntarnos, ¬øun documento debe saber que hay correo electr√≥nico y Bluetooth en nuestro proyecto? La respuesta es bien sencilla, no debe saber nada del exterior o de lo que puedan hacer con √©l. Debe vivir en su mundo aislado cual hikikomori. Para solucionar este problema, dejamos que TextDocument tenga s√≥lo la responsabilidad de operar con un documento, y adem√°s creamos una clase que se encargue exclusivamente de compartir documentos. Yendo m√°s all√°, En lugar de tener una sola clase, podemos separar las responsabilidades en diferentes clases, como EmailSharer y BluetoothSharer. De esta forma, tenemos una estructura que se puede probar f√°cilmente y que adem√°s est√° desacoplada por funcionalidades. En resumen, el Principio de Responsabilidad √önica nos ayuda a crear clases m√°s cohesivas y modulares, lo que facilita la comprensi√≥n, mantenimiento y prueba de nuestro c√≥digo. En el siguiente art√≠culo pasaremos a la letra :strong[O]{.text-orange-500}: Open/Closed Principle. Si eres de esas personas que prefieren un resumen, puedes verlo en este post de Instagram . M√°s art√≠culos de esta serie :strong[Cap√≠tulo O]{.text-orange-500}: Open-Closed Principle o Principio abierto/cerrado :strong[Cap√≠tulo L]{.text-green-500}: Liskov Substitution Principle o Principio de sustituci√≥n de Liskov :strong[Cap√≠tulo I]{.text-pink-500}: Interface Segregation Principle o Principio de segregaci√≥n de interfaces :strong[Cap√≠tulo D]{.text-violet-500}: Dependency Inversion Principle o Principio de inversi√≥n de dependencias",
    "imageMini": "/images/solid-logo-mini.webp"
  },
  {
    "slug": "20220104.html",
    "title": "3 formas extra de definir constantes con TypeScript",
    "description": "Seguramente ya te has habituado al uso de `const` en TypeScript (y espero que en JavaScript tambi√©n, no me declares constantes con `let` o `var` &#x1f609;). Y sabemos que con elementos de tipo primitivo funciona de lujo:",
    "url": "/articles/posts/20220104.html",
    "date": "2022-01-04",
    "categories": [
      "programaci√≥n",
      "TypeScript"
    ],
    "content": "Seguramente ya te has habituado al uso de const en TypeScript (y espero que en JavaScript tambi√©n, no me declares constantes con let o var &#x1f609;). Y sabemos que con elementos de tipo primitivo funciona de lujo: Pero quiz√°s te has visto alguna vez con el caso siguiente: Y es que el declarar como constante un objeto, lo que no permite es reasignar la referencia al objeto, pero s√≠ podremos modificar el valor de sus atributos. Es decir, con el ejemplo superior, lo √∫nico que no podremos hacer es tener lo siguiente: person = { nuevo contenido } o person = anotherPerson . Hoy veremos varias formas de poder declarar objetos como constantes, de forma que no podamos tampoco cambiar sus atributos. Eso s√≠, s√≥lo desde TypeScript, en JavaScript no existen estas restricciones, por desgracia. M√©todo 1. Declarando un objeto como const En este caso, lo que usaremos es const como tipo del objeto. De esta forma ya no ser√° posible modificar sus atributos. M√©todo 2. Usando readonly Si usamos el modificador readonly en un atributo de una clase, un tipo, o una interfaz. √âste pasar√° a ser de s√≥lo lectura. Eso s√≠, mucho cuidado en las clases, porque hay un caso que no falla. Y es la asignaci√≥n dentro del constructor. Esto es debido a que en el constructor se permite inicializar todas las variables independientemente de que ya lo estuvieran: En este caso te recomiendo que llegues a un consenso para o inicializar los atributos readonly de las clases nada m√°s declararlos, o en el constructor, simplemente por claridad. M√©todo 3. Arrays constantes Este es otro de los casos m√°gicos que nos permite TypeScript, y es tener arrays con elementos constantes. Es decir, que una vez creado el array, ya no podr√° ser modificado. Para ello, los m√©todos push , pop , splice , etc, dejan de estar disponibles (es s√≥lo a nivel de compilaci√≥n de TypeScript, si accedes a ese array desde JavaScript ser√° como cualquier otro). Si quieres ver un resumen puedes revisar este cheat sheet de atributos constantes en Instagram .",
    "imageMini": "/images/typescript-mini.png"
  },
  {
    "slug": "20211231.html",
    "title": "11 cosas que quiz√°s no sab√≠as de JavaScript",
    "description": "Todo lenguaje de programaci√≥n tiene sus peque√±os secretos que no todo el mundo conoce. Hoy vamos a ver once caracter√≠sticas, cualidades, o mejoras de JavaScript que son poco conocidas. No me enrollo m√°s, y pasemos ¬°al turr√≥n! (buenas fechas para decirlo).",
    "url": "/articles/posts/20211231.html",
    "date": "2021-12-31",
    "categories": [
      "programaci√≥n",
      "JavaScript"
    ],
    "content": "Todo lenguaje de programaci√≥n tiene sus peque√±os secretos que no todo el mundo conoce. Hoy vamos a ver once caracter√≠sticas, cualidades, o mejoras de JavaScript que son poco conocidas. No me enrollo m√°s, y pasemos ¬°al turr√≥n! (buenas fechas para decirlo). 1. Cargar m√≥dulos sin librer√≠as De un tiempo a esta parte, es posible importar m√≥dulos en JavaScript sin necesidad de librer√≠as externas gracias a la sentencia import ( Ver compatibilidad en Can I Use? ). Veamos como funciona con un ejemplo sencillo: Si te gusta usar await est√°s de suerte, pues puedes hacer importaciones desde una funci√≥n tal que as√≠: 2. Esperar a que terminen todas las promesas El m√©todo Promise.all() ( Ver compatibilidad en Can I Use? ) termina en cuanto una promesa de las que recibe falla. Sin embargo en ocasiones puede que nos interese esperar a que todas las promesas vayan bien o mal. Para ello podemos usar Promise.allSettled() . Como siempre veamos un ejemplo aprovechando los import que vimos antes (que devuelven una promesa): Podemos ver como con allSettled() , recibimos un array de resultados de promesa como argumento de la funci√≥n utilizada en then . As√≠ podremos saber que llamadas han funcionado y las que han fallado. Una buen caso de uso para este ejemplo, se da en el caso de que necesitemos hacer varias llamadas REST de forma simult√°nea. As√≠ aunque una falle, podremos saber el resultado de las dem√°s. Un √∫ltimo apunte a destacar de allSettled() , y es que aunque fallen todas las promesas, siempre pasar√° por el camino then . En nuestro ejemplo lo pusimos a modo ilustrativo para ver que por ah√≠ no pasa. 3. Dejar de esperar varias promesas en cuanto termine una En esta ocasi√≥n, si lo que queremos es que se termine la espera en cuanto se resuelva una promesa de varias, lo que usaremos es any() ( Ver compatibilidad en Can I Use? ). Con ella, para que el c√≥digo pase por el catch , deber√°n fallar todas las promesas. 4. Hay un this global, pero de verdad de la buena Toda la gente que nos hemos peleado con JavaScript, hemos visto que dependiendo del entorno en que ejecutemos nuestros scripts, si llamamos a this a secas fuera de todo √°mbito, el objeto global cambia. En los navegadores es window , en Node.js es global y en los WebWorker es self . Pues a partir de ahora, si quer√©is hacer algo m√°s unificado, tan s√≥lo tendr√©is que llamar a globalThis ( Ver compatibilidad en Can I Use? ). Esta palabra clave tendr√° la instancia del objeto global que corresponda sin depender del entorno. 5. Acceder a atributos que pueden ser nulos o indefinidos A esta t√©cnica se le llama Optional chaining. Y para ello usamos el operador ?. ( Ver compatibilidad en Can I Use? ). Con esto ya no tendremos errores si un atributo no existe: El operador provoca un ‚Äúcortocircuito‚Äù cuando la propiedad a su izquierda no existe, o tiene valor null . Devolviendo autom√°ticamente el valor undefined , en lugar de un error como ocurre si quitamos este nuevo operador. 6. &quot;Aplanar&quot; arrays Otra cosita genial, es que ahora podemos pasar un array de varias dimensiones a s√≥lo una, gracias el m√©todo flat() ( Ver compatibilidad en Can I Use? ). En el c√≥digo siguiente, pongo varios saltos de l√≠nea para que os quede m√°s claro cada array de ejemplo: Si no pasamos par√°metros, por defecto, s√≥lo &quot;aplana&quot; la segunda dimensi√≥n (equivaldr√≠a a poner 1 como par√°metro), pero le podemos pasar el n√∫mero de dimensiones extra a comprobar. 7. El m√°gico operador ?? Este nuevo amiguito con nombre y apellidos, se llama nullish coalescing operator y viene representado por ?? ( Ver compatibilidad en Can I Use? ). En primera instancia puede parecer que su uso es como el operador || , que nos devuelve el primer valor que no sea falsy , pero es mejor, ya que s√≥lo funciona con null y undefined , devolviendo el resto de valores falsy . Mejor que lo ve√°is con un ejemplo: 8. Operadores de asignaci√≥n l√≥gicos El anterior operador m√°s los ya conocidos &amp;&amp; , || ya se pueden utilizar en la asignaci√≥n de valores, en este caso, se les llama operadores de asignaci√≥n l√≥gicos ( Ver compatibilidad en Can I Use? : Hay que destacar que, en el momento de escribir este art√≠culo, con las cadenas este tipo de operadores no funcionan como se espera (al menos con navegadores con motores Chromium y Gecko), ya que si probamos tenemos lo siguiente: 9. Separador num√©rico Puede que manejemos cifras que son grandes en nuestra aplicaci√≥n, y queda a veces enrevesado poder distinguir que cifra hay escrita si no se pone cierta atenci√≥n en su lectura. Pues el nuevo separador de miles de JavaScript acude en nuestra ayuda cual Chapul√≠n Colorado. Es tan sencillo como poner el s√≠mbolo _ ( Ver compatibilidad en Can I Use? ) para separar los miles: 10. Reemplazos en cadenas sin expresiones regulares ¬øCu√°ntas veces hemos usado una expresi√≥n regular para reemplazar todas las veces que aparec√≠a un texto en una cadena? Pues ¬°el &quot;expresionar&quot; se va a acabar! (Aquellas personas de cierta edad entender√°n el ‚Äúchiste‚Äù). Ahora las cadenas tienen un m√©todo nuevo llamado replaceAll() ( Ver compatibilidad en Can I Use? ) que hace todo el trabajo... sucio. S√≥lo hay que pasar el texto a reemplazar y el que queremos poner en su lugar, y har√° toda la magia. 11. En los arrays no todo son corchetes Seguro que muchas veces para acceder al √∫ltimo elemento de un array, has jugado con ir a la posici√≥n dada por la longitud del array - 1 . Ahora tenemos el m√©todo at() ( Ver compatibilidad en Can I Use? ) que con posiciones positivas funciona como los corchetes, pero al que si le pasamos posiciones negativas, comienza desde la parte de atr√°s del array. Veamos a nuestro amiguito en acci√≥n:",
    "imageMini": "/images/javascript-mini.webp"
  }
]