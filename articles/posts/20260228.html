<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DDD en un apocalipsis zombi. Parte 2 ‚Äî JAFS</title>
  <meta name="description" content="En la primera entrega de esta serie, sentamos las bases para integrar DDD en nuestro campamento. Establecimos un lenguaje ubicuo para acabar con la brecha en..." />
  <meta name="author" content="Jos√© Antonio Fuentes Santiago" />
  <meta name="keywords" content="Jos√© Antonio Fuentes Santiago, JAFS, Programaci√≥n, DDD" />
  <meta name="article:published_time" content="2026-02-22T12:30:00.000Z" />
  

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="article" />
  <meta property="og:url" content="https://jafs.github.io/articles/posts/20260228.html" />
  <meta property="og:title" content="DDD en un apocalipsis zombi. Parte 2" />
  <meta property="og:description" content="En la primera entrega de esta serie, sentamos las bases para integrar DDD en nuestro campamento. Establecimos un lenguaje ubicuo para acabar con la brecha en..." />
  <meta property="og:site_name" content="JAFS" />
  <meta property="og:locale" content="es_ES" />
  <meta property="og:image" content="/images/ddd.webp" />
  
  <meta property="article:published_time" content="2026-02-22T12:30:00.000Z" />
  
  <meta property="article:author" content="Jos√© Antonio Fuentes Santiago" />

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="DDD en un apocalipsis zombi. Parte 2" />
  <meta name="twitter:description" content="En la primera entrega de esta serie, sentamos las bases para integrar DDD en nuestro campamento. Establecimos un lenguaje ubicuo para acabar con la brecha en..." />
  <meta name="twitter:image" content="/images/ddd.webp" />
  

  <!-- Canonical URL -->
  <link rel="canonical" href="https://jafs.github.io/articles/posts/20260228.html" />

  <!-- Favicons -->
  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <link rel="shortcut icon" href="/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="manifest" href="/site.webmanifest" />

  <link rel="stylesheet" href="/css/dist.css">
  <link rel="stylesheet" href="/css/github-dark.min.css">

  <!-- JSON-LD Structured Data -->
  <script type="application/ld+json">
  {
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "DDD en un apocalipsis zombi. Parte 2",
  "author": {
    "@type": "Person",
    "name": "Jos√© Antonio Fuentes Santiago"
  },
  "publisher": {
    "@type": "Person",
    "name": "Jos√© Antonio Fuentes Santiago"
  },
  "description": "En la primera entrega de esta serie, sentamos las bases para integrar DDD en nuestro campamento. Establecimos un lenguaje ubicuo para acabar con la brecha en...",
  "url": "https://jafs.github.io/articles/posts/20260228.html",
  "inLanguage": "es",
  "datePublished": "2026-02-22T12:30:00.000Z",
  "image": "/images/ddd.webp"
}
  </script>

</head>
<body class="bg-gray-50 text-gray-900">
  <header class="bg-black text-white py-4 shadow-md">
    <div class="max-w-4xl mx-auto px-4 flex items-center justify-between">
      <a href="/" class="text-2xl font-bold">
        <img src="/images/logo-mini.webp" alt="JAFS" class="inline-block w-8 h-8 mr-2 align-middle" />
      </a>
      <div class="flex items-center gap-4">
        <nav class="flex gap-4">
          <a href="/index.html" class="text-gray-300 hover:text-white transition-colors">Inicio</a>
          <a href="/articles/" class="text-gray-300 hover:text-white transition-colors">Art√≠culos</a>
          <a href="/books/" class="text-gray-300 hover:text-white transition-colors">Libros</a>
          <a href="/about.html" class="text-gray-300 hover:text-white transition-colors">Sobre m√≠</a>
        </nav>
        <form action="/search.html" method="get">
          <input type="search" name="q" placeholder="Buscar..." class="px-3 py-2 rounded bg-gray-800 text-white text-sm placeholder-gray-400 border border-gray-700 focus:outline-none focus:border-cyan-500 focus:ring-1 focus:ring-cyan-500 w-40" aria-label="Buscar art√≠culos" />
        </form>
      </div>
    </div>
  </header>
  <main class="max-w-4xl mx-auto px-4 py-8">
    <article class="prose prose-lg max-w-none bg-white rounded-lg shadow-sm p-8">
      <h1 class="text-4xl font-bold mb-2">DDD en un apocalipsis zombi. Parte 2</h1><p class="text-gray-600 text-sm mb-6">22-02-2026</p><p>En la <a href="/articles/posts/20260221.html">primera entrega</a> de esta serie, sentamos las bases para integrar DDD en nuestro campamento. Establecimos un <strong>lenguaje ubicuo</strong> para acabar con la brecha entre lo que dice la l√≠der del grupo y lo que escribe el desarrollador. Dividimos el sistema en <strong>Bounded Contexts</strong> para que Sanidad, Log√≠stica y Comando no se pisoteen entre s√≠. Aprendimos a distinguir <strong>entidades</strong> de <strong>objetos de valor</strong> y, por √∫ltimo, vimos c√≥mo los <strong>agregados</strong> act√∫an como el guardi√°n en la puerta del refugio: nadie modifica nada sin pasar por √©l. Te recomiendo leerlo antes, ya que reutilizaremos varias de las clases que definimos en √©l.</p>
<p>Todo eso era el interior. El n√∫cleo. La l√≥gica que mantiene el orden dentro de las paredes.</p>
<p>Pero un refugio necesita algo m√°s para sobrevivir: operaciones que involucran a varios actores a la vez, mecanismos para comunicarse sin crear dependencias directas entre contextos, y una forma de persistir el estado sin que el dominio sepa si est√°s usando PostgreSQL o cuadernos viejunos. Alguien tiene que coordinar todo eso sin convertirse en la √∫nica persona que lo sabe todo y lo controla todo. Ya sabes c√≥mo va esto de los apocalipsis zombi: quien sabe d√≥nde est√°n las llaves del generador, tiene acceso a los suministros cr√≠ticos y entiende c√≥mo funciona el sistema de ventilaci√≥n es, invariablemente, la primera persona en convertirse en zombi en el peor momento posible. Y cuando eso pasa, el sistema entero se va a pique porque nadie m√°s sabe c√≥mo funciona.</p>
<p>En esta segunda parte vamos a ver exactamente eso: <strong>Servicios de Dominio</strong>, <strong>Repositories</strong>, la <strong>capa de Aplicaci√≥n</strong> y <strong>Eventos de Dominio</strong>.</p>
<p><img src="/images/20260228/ddd-parte2-refugio.webp" alt="Exterior del refugio: capacidad al l√≠mite y zombis merodeando fuera"></p>
<h2>1. Servicios de Dominio (Domain Services)</h2>
<p>A veces te encuentras con l√≥gica de negocio que no encaja naturalmente en ninguna entidad ni objeto de valor. No es responsabilidad de un √∫nico agregado, sino que involucra conceptos de varios o simplemente representa una operaci√≥n del dominio que no &quot;pertenece&quot; a nadie en particular.</p>
<h3>¬øCu√°ndo necesitas un Servicio de Dominio?</h3>
<p>Preg√∫ntate: ¬øesta l√≥gica es responsabilidad de un Superviviente? ¬øDe un Refugio? Si la respuesta es &quot;no realmente, sino que es algo que pasa entre ellos&quot; o &quot;es un c√°lculo que usa informaci√≥n de varios sitios&quot;, entonces probablemente necesitas un <strong>Servicio de Dominio</strong>.</p>
<p>Un Servicio de Dominio contiene l√≥gica de negocio pura: no realiza I/O (no accede a bases de datos ni a servicios externos), no mantiene estado interno y act√∫a sobre los par√°metros que recibe para devolver resultados. No debe convertirse en un caj√≥n de sastre con utilidades varias: su prop√≥sito es expresar reglas del dominio con nombre claro.</p>
<h3>Ejemplo real: C√°lculo de riesgo de contagio</h3>
<p>Imagina que Luis, uno de nuestros exploradores, acaba de volver con el traje rasgado y cara de susto. Estuvo rodeado de infectados pero dice que mantuvo distancia... m√°s o menos. El m√©dico del refugio necesita calcular la probabilidad real de contagio seg√∫n su proximidad a los zombis y el tiempo de exposici√≥n. Esta l√≥gica:</p>
<ul>
<li>No es responsabilidad de Luis (el <code>Superviviente</code>) (√©l no decide si se infecta o no, solo sufre las consecuencias).</li>
<li>No es responsabilidad del <code>Refugio</code> (es un c√°lculo que puede ocurrir fuera tambi√©n).</li>
<li>Es una <strong>regla del dominio</strong> que depende de factores f√≠sicos del apocalipsis zombi.</li>
</ul>
<p>Con las condiciones anteriores, es cuando entrar√≠a en juego un Servicio de Dominio:</p>
<pre><code class="language-typescript">export class InfectionSpreadService {
  /**
   * Calcula la probabilidad de contagio seg√∫n distancia y tiempo de exposici√≥n
   *
   * @param distanceMeters - Distancia al infectado en metros
   * @param exposureMinutes - Minutos de exposici√≥n
   * @returns Probabilidad entre 0 (sin riesgo) y 1 (contagio seguro)
   */
  public chanceOfInfection(
    distanceMeters: number,
    exposureMinutes: number
  ): number {
    // Regla del dominio: a menor distancia, mayor riesgo
    // A 0 metros = riesgo m√°ximo (1.0)
    // A 20+ metros = sin riesgo (0.0)
    const base = Math.max(0, 1 - distanceMeters / 20);

    // Regla del dominio: el tiempo de exposici√≥n aumenta el riesgo
    // Menos de 60 minutos = riesgo proporcional al tiempo
    // 60+ minutos = factor m√°ximo (1.0)
    const timeFactor = Math.min(1, exposureMinutes / 60);

    // F√≥rmula de contagio: combinamos distancia y tiempo
    // Base m√≠nima del 50%, incrementa hasta 100% con el tiempo
    return Math.min(1, base * (0.5 + 0.5 * timeFactor));
  }
}

const infectionSpreadService = new InfectionSpreadService();

// Uso del servicio
const riesgo1 = infectionSpreadService.chanceOfInfection(5, 30);
console.log(riesgo1);
// ~0.59 (59% de probabilidad ‚Äî hay que aislar a Luis)

const riesgo2 = infectionSpreadService.chanceOfInfection(15, 90);
console.log(riesgo2);
// ~0.25 (25% de probabilidad ‚Äî m√°s lejos, pero estuvo mucho tiempo)

const riesgo3 = infectionSpreadService.chanceOfInfection(1, 120);
console.log(riesgo3);
// ~0.95 (95% de probabilidad ‚Äî Luis ya est√° pr√°cticamente perdido)
</code></pre>
<h3>¬øQui√©n usa este servicio?</h3>
<p>Este servicio es <strong>pura l√≥gica de dominio</strong>, por lo que puede ser utilizado por:</p>
<ul>
<li>El agregado <code>Refugio</code> cuando eval√∫a si activar una cuarentena autom√°tica.</li>
<li>Un proceso que simula interacciones entre supervivientes.</li>
<li>La capa de aplicaci√≥n cuando necesita decidir si un <code>SupervivienteExpuesto</code> debe marcarse como <code>Infectado</code> (hablaremos de esa capa en la secci√≥n 3).</li>
</ul>
<p>Lo importante es que la l√≥gica de negocio (c√≥mo se calcula el contagio) est√° centralizada en un solo lugar con un nombre claro que refleja lo que hace. Si ma√±ana los expertos en zombis dicen &quot;en realidad, el contagio es m√°s r√°pido a trav√©s del aire&quot;, solo modificas este servicio.</p>
<h3>Cuando el servicio coordina m√∫ltiples agregados</h3>
<p>El ejemplo anterior es un servicio &quot;puro&quot;: solo hace c√°lculos con valores primitivos. Pero hay otra situaci√≥n igualmente v√°lida: l√≥gica de negocio que <strong>involucra a varios agregados a la vez</strong>.</p>
<p>Imagina que necesitamos transferir un superviviente de un refugio a otro. La operaci√≥n tiene reglas de negocio concretas:</p>
<ul>
<li>No se puede transferir a un superviviente infectado.</li>
<li>El refugio de destino debe tener capacidad libre.</li>
<li>Si el superviviente es un especialista (m√©dico, ingeniero), el refugio de origen no puede quedar por debajo del m√≠nimo de especialistas requerido.</li>
</ul>
<p>¬øD√≥nde vive esta l√≥gica? No en el refugio (<code>Shelter</code>) (no sabe nada del otro refugio) ni en los supervivientes (<code>Survivor</code>) (no decide a d√≥nde va). Es una regla que cruza dos agregados: aqu√≠ entra el Servicio de Dominio.</p>
<pre><code class="language-typescript">export class SurvivorTransferService {
  /**
   * Valida y ejecuta la transferencia de un superviviente entre dos refugios,
   * aplicando todas las reglas de negocio del dominio.
   *
   * ‚ö†Ô∏è Los agregados deben llegar ya cargados: este servicio
   * no accede a repositorios ni a la base de datos.
   */
  public transfer(
    survivor: Survivor,
    fromShelter: Shelter,
    toShelter: Shelter
  ): void {
    // Regla de dominio: los infectados no se trasladan
    if (survivor.isInfected()) {
      throw new DomainError(&quot;No se puede transferir a un superviviente infectado&quot;);
    }

    // Regla de dominio: el destino debe tener hueco
    if (!toShelter.hasCapacity()) {
      throw new DomainError(`El refugio ${toShelter.id} no tiene capacidad`);
    }

    // Regla de dominio: un especialista no puede marcharse si deja al refugio
    // origen por debajo del m√≠nimo de seguridad
    if (survivor.isSpecialist() &amp;&amp; fromShelter.wouldBeUnsafeWithout(survivor)) {
      throw new DomainError(
        `${survivor.name} es especialista y su marcha dejar√≠a el refugio en situaci√≥n cr√≠tica`
      );
    }

    // Aplicar el traslado en los dos agregados
    fromShelter.removeSurvivor(survivor.id);
    toShelter.admit(survivor);
  }
}
</code></pre>
<p>La clave est√° en el comentario: <strong>los agregados llegan ya cargados</strong>. Este servicio no sabe ni le importa si los datos vienen de PostgreSQL, de una cach√© o de un archivador mugroso. Solo aplica las reglas del dominio sobre objetos del dominio.</p>
<p>Aunque SurvivorTransferService coordine el movimiento entre dos refugios, la √∫ltima palabra la tienen los agregados. El servicio no hace <code>shelter.count++</code> manualmente (lo cual romper√≠a la encapsulaci√≥n), sino que llama a <code>toShelter.admit()</code>. Es el agregado quien se asegura de que su invariante (por ejemplo: &quot;nunca superar la capacidad m√°xima&quot;) se cumpla. Si el servicio intentara forzar algo ilegal, el agregado lanzar√≠a un error y proteger√≠a la integridad del refugio.</p>
<p><img src="/images/20260228/ddd-parte2-diagrama-servicio.png" alt="Diagrama de clases"></p>
<h2>2. Repositorios (Repositories)</h2>
<p>Tenemos agregados con reglas de negocio bien protegidas y Servicios de Dominio que calculan cosas importantes. Pero falta una pieza crucial: ¬øc√≥mo guardamos y recuperamos estos agregados de la base de datos?</p>
<h3>El problema de la persistencia</h3>
<p>Pi√©nsalo as√≠: el m√©dico del refugio sabe curar heridas, suturar mordeduras y detectar los primeros s√≠ntomas de infecci√≥n zombi. Pero no tiene por qu√© saber d√≥nde est√° el archivero con los historiales m√©dicos ni c√≥mo est√° organizado el almac√©n de material sanitario. Son dos responsabilidades completamente distintas. El d√≠a que cambiemos de sistema de archivo, el m√©dico no tiene que aprender nada nuevo: sigue haciendo su trabajo.</p>
<p>Lo mismo ocurre con el dominio y la persistencia.</p>
<p>Si dejamos que nuestros agregados sepan c√≥mo se guardan en base de datos, estar√≠amos mezclando dos responsabilidades completamente diferentes:</p>
<pre><code class="language-typescript">// ‚ùå HORRIBLE: El agregado sabe de SQL
class Shelter {
  public async save(): Promise&lt;void&gt; {
    await db.query(
      &quot;UPDATE shelters SET capacity = ?, current_count = ? WHERE id = ?&quot;,
      [this.capacity, this.currentCount, this.id]
    );
    // Y ahora qu√© hacemos con los supervivientes, ¬øotra tabla? ¬øJSON?
  }
}
</code></pre>
<p>Esto rompe completamente la separaci√≥n de responsabilidades. El dominio no deber√≠a saber si est√°s usando PostgreSQL, MongoDB, archivos JSON o palomas mensajeras para persistir datos.</p>
<h3>La soluci√≥n: Repositorios como abstracciones</h3>
<p>Un <strong>Repositorio</strong> es una abstracci√≥n que se comporta como una colecci√≥n en memoria, pero por debajo puede persistir los datos donde sea necesario. Es el intermediario perfecto entre el dominio puro y la infraestructura sucia. En DDD es siempre una <strong>interfaz</strong> (o clase abstracta). El dominio usa esta interfaz sin saber c√≥mo est√° implementada:</p>
<pre><code class="language-typescript">// Esto va en la capa de DOMINIO
// Define QU√â operaciones necesitamos, no C√ìMO se hacen
export interface ShelterRepository {
  // Buscar un refugio por su ID
  findById(id: string): Promise&lt;Shelter | null&gt;;

  // Guardar un refugio (crear o actualizar)
  save(shelter: Shelter): Promise&lt;void&gt;;

  // Buscar refugios cercanos a unas coordenadas
  findAllNear(coords: Coordinates, radiusKm: number): Promise&lt;Shelter[]&gt;;

  // Buscar todos los refugios con capacidad disponible
  findWithCapacity(): Promise&lt;Shelter[]&gt;;
}
</code></pre>
<p>F√≠jate en lo que <strong>NO</strong> est√° en esta interfaz:</p>
<ul>
<li>‚ùå Nada de SQL, MongoDB, o cualquier tecnolog√≠a espec√≠fica</li>
<li>‚ùå Nada sobre tablas, colecciones, o estructura de datos</li>
<li>‚ùå Nada sobre conexiones, transacciones, o pooling</li>
</ul>
<p>Solo operaciones del dominio expresadas en el lenguaje del negocio: &quot;buscar refugio&quot;, &quot;guardar refugio&quot;, &quot;encontrar cercanos&quot;.</p>
<h3>Las implementaciones van en Infraestructura</h3>
<p>La implementaci√≥n concreta (SQL, Mongo, memoria) se coloca en la <strong>capa de infraestructura</strong>, completamente separada del dominio:</p>
<pre><code class="language-typescript">// Esto va en la capa de INFRAESTRUCTURA
export class PostgreSQLShelterRepository implements ShelterRepository {
  async findById(id: string): Promise&lt;Shelter | null&gt; {
    const row = await db.query(&quot;SELECT * FROM shelters WHERE id = ?&quot;, [id]);
    if (!row) return null;

    // Aqu√≠ hacemos el mapeo de base de datos a agregado
    return this.mapToAggregate(row);
  }

  async save(shelter: Shelter): Promise&lt;void&gt; {
    // Aqu√≠ decidimos c√≥mo persistir el agregado
    await db.query(
      &quot;INSERT INTO shelters ... ON CONFLICT UPDATE ...&quot;,
      [shelter.id, shelter.capacity, /* etc */]
    );
  }

  // ... resto de m√©todos
}

// Tambi√©n podr√≠amos tener una implementaci√≥n en memoria para tests
export class InMemoryShelterRepository implements ShelterRepository {
  private shelters: Map&lt;string, Shelter&gt; = new Map();

  async findById(id: string): Promise&lt;Shelter | null&gt; {
    return this.shelters.get(id) || null;
  }

  async save(shelter: Shelter): Promise&lt;void&gt; {
    this.shelters.set(shelter.id, shelter);
  }

  // ... resto de m√©todos
}
</code></pre>
<h3>Ventajas de este enfoque</h3>
<ol>
<li><strong>Dominio puro</strong>: Los agregados no saben nada de persistencia. Solo contienen l√≥gica de negocio.</li>
<li><strong>Testeable</strong>: Puedes testear tu dominio usando un <code>InMemoryRepository</code> sin necesidad de levantar una base de datos real.</li>
<li><strong>Flexible</strong>: Puedes cambiar de PostgreSQL a MongoDB sin tocar una sola l√≠nea del dominio. Solo cambias la implementaci√≥n del Repositorio.</li>
<li><strong>Inversi√≥n de dependencias</strong>: El dominio define la interfaz que necesita. La infraestructura implementa esa interfaz. El dominio no depende de la infraestructura, es al rev√©s (esto es la <a href="/articles/posts/20220131.html">D de SOLID</a>).</li>
</ol>
<p>En resumen: los Repositorios son la frontera entre el mundo puro de las reglas de negocio y el mundo sucio de bases de datos, APIs y archivos. Y esa frontera est√° muy bien definida por una interfaz.</p>
<h2>3. Aplicaci√≥n: el director de orquesta</h2>
<p>Ya tenemos agregados con reglas de negocio y repositorios que persisten datos. Pero falta algo: ¬øqui√©n coordina todo esto? ¬øQui√©n recibe las peticiones del exterior y las traduce en operaciones del dominio?</p>
<p>Aqu√≠ entra la <strong>capa de aplicaci√≥n</strong>. Su trabajo es <strong>orquestar</strong>, no contener l√≥gica de negocio. Es el director de orquesta que dice &quot;t√∫ haz esto, luego t√∫ aquello, y finalmente t√∫ lo otro&quot;.</p>
<h3>¬øQu√© hace la capa de aplicaci√≥n?</h3>
<p>La capa de aplicaci√≥n es responsable de:</p>
<ol>
<li><strong>Recibir comandos o peticiones</strong> del exterior (API REST, GraphQL, CLI, etc.)</li>
<li><strong>Validar permisos y autorizaci√≥n</strong> (¬øpuede este usuario hacer esto?)</li>
<li><strong>Cargar agregados</strong> desde los repositorios</li>
<li><strong>Invocar m√©todos del dominio</strong> (donde vive la l√≥gica de negocio real)</li>
<li><strong>Guardar los cambios</strong> a trav√©s de los repositorios</li>
<li><strong>Publicar eventos</strong> de dominio para que otros se enteren (los veremos en la secci√≥n siguiente)</li>
</ol>
<p>Pero lo m√°s importante es tambi√©n saber lo que <strong>NO</strong> hace la capa de aplicaci√≥n:</p>
<ul>
<li>‚ùå Contener reglas de negocio (eso es el dominio)</li>
<li>‚ùå Saber de detalles de persistencia (eso es infraestructura)</li>
<li>‚ùå Formatear respuestas para HTTP, GraphQL, etc. (eso es la capa de presentaci√≥n)</li>
</ul>
<h3>Casos de uso y el patr√≥n Command + Handler</h3>
<p>Cada operaci√≥n del sistema accesible desde el exterior es un <strong>caso de uso</strong>. Por ejemplo:</p>
<ul>
<li>Admitir un superviviente</li>
<li>Transferir suministros</li>
<li>Activar una cuarentena</li>
</ul>
<p>La capa de aplicaci√≥n se organiza en torno a ellos: un caso de uso por operaci√≥n, con toda la orquestaci√≥n necesaria y nada m√°s.</p>
<p>Un patr√≥n muy com√∫n en DDD para implementar esos casos de uso es usar <strong>Commands</strong> (comandos) y <strong>Handlers</strong> (manejadores). El Command describe la intenci√≥n; el Handler es el caso de uso implementado:</p>
<pre><code class="language-typescript">// Un Command representa una INTENCI√ìN
// &quot;Quiero admitir a este superviviente en este refugio&quot;
export class AdmitSurvivorCommand {
  constructor(
    public readonly shelterId: string,
    public readonly survivor: Survivor
  ) {}
}

// El Handler es quien EJECUTA la intenci√≥n
export class AdmitSurvivorHandler {
  constructor(
    private shelterRepo: ShelterRepository,
    private eventBus: EventBus
  ) {}

  async handle(cmd: AdmitSurvivorCommand): Promise&lt;void&gt; {
    // 1. Cargar el agregado desde el repositorio
    const shelter = await this.shelterRepo.findById(cmd.shelterId);
    if (!shelter) {
      throw new Error(&quot;Refugio no encontrado&quot;);
    }

    // 2. Invocar m√©todo del dominio
    // AQU√ç es donde se validan las reglas de negocio (capacidad, etc.)
    shelter.admit(cmd.survivor);

    // 3. Persistir los cambios
    await this.shelterRepo.save(shelter);

    // 4. Publicar evento de dominio (lo explicaremos en la secci√≥n siguiente)
    // ...
  }
}
</code></pre>
<h3>El flujo completo</h3>
<p>Una de las grandes ventajas de organizar la capa de aplicaci√≥n en casos de uso es que el mismo caso de uso puede ser invocado desde cualquier punto de entrada del sistema: una API REST, una interfaz de l√≠nea de comandos, un evento que llega de otro servicio o un proceso batch autom√°tico. La l√≥gica de negocio y la orquestaci√≥n no cambian en ning√∫n caso; lo √∫nico que cambia es qui√©n construye el <code>Command</code> y se lo pasa al <code>Handler</code>.</p>
<p>Ve√°moslo con un ejemplo. Aqu√≠ una API REST invoca el caso de uso que acabamos de definir:</p>
<pre><code class="language-typescript">// La API recibe una petici√≥n HTTP (capa de presentaci√≥n)
app.post(&quot;/shelters/:id/admit&quot;, async (req, res) =&gt; {
  const command = new AdmitSurvivorCommand(
    req.params.id,
    new Survivor(req.body.survivorId, req.body.name, req.body.health)
  );

  // Construye el Command y delega en el caso de uso
  await admitSurvivorHandler.handle(command);

  res.status(200).json({ message: &quot;Superviviente admitido&quot; });
});
</code></pre>
<p>F√≠jate en la separaci√≥n de responsabilidades:</p>
<ul>
<li><strong>API (Presentaci√≥n)</strong>: Recibe HTTP, construye el comando, devuelve HTTP</li>
<li><strong>Handler (Aplicaci√≥n)</strong>: Orquesta el caso de uso, sin l√≥gica de negocio</li>
<li><strong>Shelter (Dominio)</strong>: Valida la capacidad, aplica las reglas, protege invariantes</li>
<li><strong>Repository (Infraestructura)</strong>: Persiste en la base de datos</li>
</ul>
<p>Si ma√±ana quisieras admitir supervivientes desde una CLI, desde un mensaje de otro sistema o desde un proceso nocturno autom√°tico, solo cambiar√≠a c√≥mo se construye el <code>AdmitSurvivorCommand</code>. El caso de uso ‚Äîel <code>AdmitSurvivorHandler</code>‚Äî permanece intacto. Y el dominio ni se entera.</p>
<h3>Servicio de Dominio vs. Capa de Aplicaci√≥n</h3>
<p>Aqu√≠ es donde mucha gente se confunde, porque un caso de uso de la capa de aplicaci√≥n tambi√©n &quot;coordina&quot; cosas. La diferencia es fundamental:</p>
<pre><code class="language-typescript">// SERVICIO DE DOMINIO
// Recibe objetos ya cargados, aplica reglas de negocio, sin I/O
transferService.transfer(survivor, shelterA, shelterB);

// HANDLER DE APLICACI√ìN
// Carga objetos, llama al dominio, guarda cambios, despacha eventos
class TransferSurvivorHandler {
  public constructor(
    private survivorRepo: SurvivorRepository,
    private shelterRepo: ShelterRepository,
    private transferService: SurvivorTransferService
  ) { }

  async handle(cmd: TransferSurvivorCommand): Promise&lt;void&gt; {
    // 1. CARGAR (I/O: acceso a repositorios)
    const survivor = await this.survivorRepo.findById(cmd.survivorId);
    const fromShelter = await this.shelterRepo.findById(cmd.fromShelterId);
    const toShelter = await this.shelterRepo.findById(cmd.toShelterId);

    // 2. DOMINIO (sin I/O: solo l√≥gica de negocio)
    this.transferService.transfer(survivor, fromShelter, toShelter);

    // 3. GUARDAR (I/O: acceso a repositorios)
    await this.shelterRepo.save(fromShelter);
    await this.shelterRepo.save(toShelter);
    await this.survivorRepo.save(survivor);
  }
}
</code></pre>
<p>Con la siguiente tabla puedes hacerte una idea de las diferencias entre ambos servicios para evitar confusiones:</p>
<table>
<thead>
<tr>
<th></th>
<th>Servicio de Dominio</th>
<th>Servicio de Aplicaci√≥n</th>
</tr>
</thead>
<tbody><tr>
<td>¬øQu√© hace?</td>
<td>Aplica reglas de negocio</td>
<td>Orquesta un caso de uso completo</td>
</tr>
<tr>
<td>¬øCon qu√© trabaja?</td>
<td>Objetos del dominio ya cargados</td>
<td>Repositorios, eventos, servicios externos</td>
</tr>
<tr>
<td>¬øTiene I/O?</td>
<td>‚ùå Nunca</td>
<td>‚úÖ Siempre</td>
</tr>
<tr>
<td>¬øContiene l√≥gica de negocio?</td>
<td>‚úÖ S√≠</td>
<td>‚ùå No (delega en el dominio)</td>
</tr>
<tr>
<td>¬øSabe de conexiones externas?</td>
<td>‚ùå Nunca</td>
<td>Indirectamente, a trav√©s de repositorios</td>
</tr>
</tbody></table>
<p>Dicho de otra manera: el Servicio de Dominio sabe <strong>qu√© reglas</strong> gobiernan una operaci√≥n del negocio. El Servicio de Aplicaci√≥n sabe <strong>c√≥mo ejecutar</strong> ese caso de uso de principio a fin. El primero es l√≥gica; el segundo, coordinaci√≥n u orquestaci√≥n.</p>
<p>Si en alg√∫n momento te preguntas &quot;¬øesto deber√≠a ser un Servicio de Dominio o un caso de uso?&quot;, busca la respuesta en el I/O: si el c√≥digo necesita acceder a repositorios o a cualquier infraestructura externa, es Aplicaci√≥n. Si solo opera sobre objetos del dominio que ya tienes en memoria, es Dominio.</p>
<h2>4. Eventos de Dominio (Domain Events)</h2>
<p>Los <strong>Eventos de Dominio</strong> representan hechos que ya han ocurrido en el pasado y que son importantes para el negocio. No son √≥rdenes ni peticiones, son <strong>notificaciones</strong> de algo que pas√≥ y que otras partes del sistema podr√≠an querer saber.</p>
<h3>¬øPor qu√© son importantes?</h3>
<p>Los eventos son la clave para <strong>desacoplar</strong> partes del sistema que no deber√≠an conocerse directamente. Pensemos en nuestro apocalipsis:</p>
<p>Imagina que un zombi consigue colarse por una brecha en el per√≠metro. El centinela que lo detecta no puede salir corriendo a avisar al m√©dico, luego al encargado de Log√≠stica y luego al mando, uno por uno. Para cuando terminase el recorrido, ya habr√≠a medio refugio infectado. En su lugar, toca la alarma. Con esa acci√≥n, reaccionar√° toda la gente que necesite hacerlo. El centinela no sabe ni le importa qui√©n escucha la alarma: su trabajo es detectar y avisar, no coordinar. Eso son exactamente los Eventos de Dominio.</p>
<p>Como siempre, para hacer un poco m√°s sencilla la explicaci√≥n lo veremos con un ejemplo en c√≥digo: piensa al admitir a alguien en el grupo de supervivientes del refugio, ¬øqu√© debe pasar?</p>
<ul>
<li>El equipo de <strong>Log√≠stica</strong> necesita saber que hay una boca m√°s que alimentar</li>
<li>El equipo de <strong>Sanidad</strong> debe registrar al superviviente para hacer un chequeo m√©dico</li>
<li>El equipo de <strong>Comando</strong> actualiza el mapa de distribuci√≥n de personal</li>
</ul>
<p>Si hicieras esto directamente en el m√©todo <code>admit()</code> del refugio, tendr√≠as algo as√≠:</p>
<pre><code class="language-typescript">// ‚ùå MAL: El refugio conoce demasiados detalles
public admit(survivor: Survivor): void {
  this.survivors.push(survivor);
  this.logisticService.updateFoodConsumption(this.id);
  this.medicalService.scheduleCheckup(survivor.id);
  this.commandService.updateMap(this.id, this.currentCount);
}
</code></pre>
<p>Esto es terrible porque:</p>
<ul>
<li>El <code>Refugio</code> ahora depende de 3 servicios que no son su responsabilidad</li>
<li>Si ma√±ana quieres que algo m√°s reaccione a la admisi√≥n, tienes que modificar el <code>Refugio</code></li>
<li>Est√°s acoplando contextos que deber√≠an estar separados</li>
</ul>
<h3>La soluci√≥n: Eventos de Dominio</h3>
<p>En lugar de llamar directamente a todos esos servicios, el Handler ‚Äîque ya conocemos de la secci√≥n anterior‚Äî publica un <strong>evento</strong> despu√©s de guardar el agregado. Quien est√© interesado en ese evento, que reaccione.</p>
<p>Primero definimos los eventos como tipos con nombres en pasado (ya ocurrieron, son hechos consumados):</p>
<pre><code class="language-typescript">type DomainEvent =
  | {
      type: &quot;SurvivorAdmitted&quot;;
      shelterId: string;
      survivorId: string;
      timestamp: string;
    }
  | {
      type: &quot;SurvivorInfected&quot;;
      survivorId: string;
      infectedBy?: string; // Opcional: qui√©n lo infect√≥
      timestamp: string;
    }
  | {
      type: &quot;ShelterRestocked&quot;;
      shelterId: string;
      supplies: Array&lt;{ name: string; amount: number }&gt;;
      timestamp: string;
    }
  | {
      type: &quot;QuarantineActivated&quot;;
      shelterId: string;
      reason: string;
      affectedCount: number;
      timestamp: string;
    };
</code></pre>
<p>El m√©todo <code>admit()</code> del refugio permanece limpio: solo aplica reglas y cambia estado, sin saber nada de lo que ocurre despu√©s:</p>
<pre><code class="language-typescript">public admit(s: Survivor): void {
  if (this.currentCount + 1 &gt; this.capacity) {
    throw new Error(&quot;Refugio lleno&quot;);
  }
  this.survivors.push(s);
  this.currentCount++;
  // Nada m√°s: el dominio aplica reglas y cambia estado
}
</code></pre>
<p>Y el Handler es quien publica el evento, siempre despu√©s de guardar. El Handler sabe qu√© operaci√≥n acaba de ejecutar, por eso puede publicar el evento correcto:</p>
<pre><code class="language-typescript">class AdmitSurvivorHandler {
  async handle(cmd: AdmitSurvivorCommand): Promise&lt;void&gt; {
    const shelter = await this.shelterRepo.findById(cmd.shelterId);
    shelter.admit(cmd.survivor);
    await this.shelterRepo.save(shelter);

    // Si todo fue bien, notifica el evento.
    await this.eventBus.publish({
      type: &quot;SurvivorAdmitted&quot;,
      shelterId: shelter.id,
      survivorId: cmd.survivor.id,
      timestamp: new Date().toISOString()
    });
  }
}
</code></pre>
<p><div class="rounded-md bg-gray-100 p-4 border-t-4 border-t-gray-400">üóíÔ∏è <strong>NOTA</strong><br />En sistemas robustos, se suele utilizar el patr√≥n Outbox para garantizar la consistencia de que tras realizar todas las transacciones se publique correctamente el evento. Lo dejaremos fuera del alcance de este art√≠culo. Pero si os interesa siempre pod√©is dejar alg√∫n comentario en LinkedIn para profundizar en √©l.</div></p>
<h3>¬øQui√©n escucha los eventos?</h3>
<p>Diferentes partes del sistema pueden suscribirse a los eventos que les interesan:</p>
<pre><code class="language-typescript">// El servicio de Log√≠stica escucha admisiones
eventBus.on(&quot;SurvivorAdmitted&quot;, (event) =&gt; {
  logisticService.updateFoodConsumption(event.shelterId);
});

// El servicio de Sanidad tambi√©n
eventBus.on(&quot;SurvivorAdmitted&quot;, (event) =&gt; {
  medicalService.scheduleCheckup(event.survivorId);
});

// Comando reacciona a infecciones para evaluar evacuaciones
eventBus.on(&quot;SurvivorInfected&quot;, (event) =&gt; {
  commandService.evaluateEvacuation(event.shelterId);
});

// Sanidad emite alertas ante brotes
eventBus.on(&quot;QuarantineActivated&quot;, (event) =&gt; {
  alertService.sendUrgentNotification(
    `¬°Cuarentena activada en ${event.shelterId}! Motivo: ${event.reason}`
  );
});
</code></pre>
<h3>Ventajas de usar eventos</h3>
<ol>
<li><strong>Desacoplamiento</strong>: El <code>Refugio</code> no sabe qui√©n reacciona a sus eventos, ni le importa. Solo publica lo que pas√≥.</li>
<li><strong>Extensibilidad</strong>: Si ma√±ana necesitas que otro servicio reaccione a <code>SurvivorAdmitted</code>, solo a√±ades un listener. No tocas el c√≥digo del <code>Refugio</code>.</li>
<li><strong>Auditor√≠a</strong>: Los eventos son un registro de todo lo que ha pasado. Como cualquiera puede recibirlos, puedes guardarlos y tener un historial completo de eventos del apocalipsis.</li>
<li><strong>Procesos as√≠ncronos</strong>: Los eventos permiten desencadenar procesos que no necesitan completarse inmediatamente (enviar alertas, actualizar dashboards, generar informes, etc.).</li>
<li><strong>Event Sourcing</strong>: Si adem√°s guardas todos los eventos de forma cronol√≥gica, estar√≠as a un paso del Event Sourcing, que como dir√≠a Doc Brown, es la verdadera m√°quina del tiempo del dominio: te permite reconstruir todo lo que pas√≥, paso a paso, desde el d√≠a 0 del apocalipsis.</li>
</ol>
<p>Los eventos son la columna vertebral de sistemas complejos bien dise√±ados. En DDD, son el pegamento que mantiene unidos los Bounded Contexts sin crear dependencias directas entre ellos.</p>
<p><img src="/images/20260228/ddd-parte2-eventos.webp" alt="Reacci√≥n en cadena al detectar una brecha zombi: cada equipo reacciona al mismo evento sin que nadie los coordine directamente"></p>
<h2>Para terminar</h2>
<p>Implementar estas capas puede parecer mucho trabajo extra cuando hay zombis golpeando la puerta, pero es lo que diferencia a un grupo de supervivientes organizado de una cena buffet para no-muertos. Gracias a que el equipo m√©dico (Dominio) y la gente encargada de suministros (Infraestructura) hablan el mismo idioma y respetan sus fronteras, Luis est√° ahora en una zona de aislamiento segura en lugar de estar deambulando por el comedor buscando cerebros.</p>
<p>Hemos pasado de tener &quot;c√≥digo que funciona&quot; a tener un sistema que refleja la realidad de nuestra supervivencia.</p>
<p>En el siguiente art√≠culo, daremos el paso final: c√≥mo evitar que todo vuele por los aires cuando varias cosas pasan a la vez (transacciones), qu√© errores no debes cometer nunca (antipatrones) y c√≥mo probar que nuestro refugio es realmente impenetrable (testing). ¬°Mantened las puertas cerradas y el c√≥digo limpio!</p>

    </article>
  </main>
  <footer class="bg-black text-white py-4 mt-12">
    <div class="max-w-4xl mx-auto px-4 flex flex-col items-center gap-4">
      <div class="flex gap-4">
        <a href="https://www.linkedin.com/in/joseafs/" target="_blank" rel="noopener noreferrer" class="text-white hover:text-gray-300 transition-colors" aria-label="LinkedIn">
          <img src="/images/linkedin.svg" alt="LinkedIn" class="w-6 h-6" />
        </a>
        <a href="https://www.youtube.com/@jafsdeveloper" target="_blank" rel="noopener noreferrer" class="text-white hover:text-gray-300 transition-colors" aria-label="YouTube">
          <img src="/images/youtube.svg" alt="YouTube" class="w-6 h-6" />
        </a>
        <a href="https://www.instagram.com/jafs_developer/" target="_blank" rel="noopener noreferrer" class="text-white hover:text-gray-300 transition-colors" aria-label="Instagram">
          <img src="/images/instagram.svg" alt="Instagram" class="w-6 h-6" />
        </a>
      </div>
      <div class="text-center">¬© 2025 ‚Äî Jos√© Antonio Fuentes Santiago</div>
    </div>
  </footer>
  <script src="/js/highlight.min.js"></script>
  <script src="/js/main.js"></script>
</body>
</html>